2000-01-18:

* The amlazy file Data.sml containing a structure called Data: parse
  as AnonStruct, then resolve in the compiler

* Avoid shift/reduce and reduce/reduce conflicts in the parser.

* Documentation: 

  - manual
  - syntax

+ Emitcode: switch larger than 256 ?  OK because the switch
  compilation in Back breaks switches into chunks of size < 256

* Size of .ui files: sharing?

+ Kit: It is functor Parse in k42.sml that causes trouble --- even
  when actions in k32.sml is commented out.  Functor Parse is declared
  in k35.sml.  More precisely, the application of functor GrammarUtils
  inside the Parse functor in k35.sml:

    structure GrammarUtils =
      GrammarUtils (structure TopdecGrammar = TopdecGrammar
		    structure LexBasics = LexBasics
		    structure ParseInfo = ParseInfo
		    structure Report = Report
		    structure PrettyPrint = PrettyPrint
		    structure Crash = Crash
		      )
  Functor GrammarUtils is declared in k32.sml.
 
  Problem: open of local decs.

+ Back.sml -- array size 65000 -> 4000 (used only for the locals of 
  the init code)

+ Size of mosmllex and mosmllnk: avoid linking in Types

+ exnName and exnMessage -> runtime

  prim_val exnname : exn -> string = 1 "sml_exnname";

  prim_val exnMessage : exn -> string = 1 "sml_exnmessage";

+ Add documentation to General.fke

+ Implement sharing of literals (strings, reals, etc) as globals cf
  the hol98 and cholera problems: Updated Patch and Reloc and Code_dec
  and Link.

+ Cleanup of the dynlibs; moved stable structures to src/mosmllib

+ Fix mgd dynlib to use new GD package and PNG format.

+ Fix mosmllib/test/Makefile to create sym- and hardlinks as needed

+ Fix errormessage in compiler/Emitcode

+ Fix printing of overloaded ops to distinguish num, numtxt etc

* Fix exn tag access under lambda in Match.sml

* In general, compile better code for accessing subvalues in matches.
  However, should never evaluate accesses that aren't needed (safe but
  unnecessarily slow). The matching function may return an `envelope'
  of let-bindings?

+ Include runtime system *.h files in distribution (for the sake of
  user-written C code and dynlibs)

* Perhaps fix mgdbm to use new GDBM?

+ Inexhaustive and redundant excon matches -- why not reported correctly?
  Because EExn carries IdInfo as argument, and that includes the location 
  of the identifier.  Of course no two identifier occurrences have the same 
  location.  How fix it?  Translate the exnname accesses early, and
  compare the access paths (the lambda code): equal access paths must
  produce equal string refs...

* Add an Odbc interface to unixODBC.

+ .h files in mosml/include

+ make dynlibs/* refer to mosml/include

+ move .so files from mosml/bin to mosml/lib

+ strange bug in dynlibs/interface/ for Solaris.  Crashes.  Fails
  test7, because it doesn't pass the fifth argument (a boolean)
  correctly.  test 7 works if the number of arguments is reduced to 4.
  test10 fails as well, why?  NON-BUG.  A symbolic link had been
  extended by corecursive file copying.

+ Non-blocking IO in TextIO.  input calls fast_input, which is
  io.input in the runtime.  It calls getblock, which may call
  really_read if necessary to obtain data not in the buffer; and
  really_read calls Unix read.  This will raise sys_error in case Unix
  read fails (cannot obtain any data).

  Two solutions: (1) handle the SysError (and check that it is
  EAGAIN), or (2) add an extra parameter to really_read so that it
  avoids raising the SysError.

  (1) is inefficient, 

  (2) may be done as follows: Add a new boolean parameter `nonblocking' to
  really_read.  If it is true, then use fcntl to change to
  non-blocking (and back), and if read fails, return -1 instead of
  raising sys_error.

  void nonblocking_mode(int fd, int nonblocking) {
    int retcode = fcntl(fd, F_GETFL);
    if (retcode != -1) {
      if (blocking) 
        retcode = fcntl(fd, F_SETFL, retcode | O_NONBLOCK);
      else
        retcode = fcntl(fd, F_SETFL, retcode & (~O_NONBLOCK));
    }
    if (retcode == -1)
      failwith("set_blocking_io");
  }

  static int really_read(int fd, char * p, unsigned n, int nonblocking) {
    if (nonblocking)
      nonblocking_mode(fd, TRUE);		/* set non-blocking   */

    ...

    leave_blocking_section();
    if (nonblocking) {
      nonblocking_mode(fd, FALSE);		/* unset non-blocking */
      if (retcode == -1 && errno != EAGAIN)
        sys_error(NULL);
    } else if (retcode == -1)
        sys_error(NULL);
    return retcode;
  }

  Function input_scan_line must call really_read with nonblocking = false.

  Add a new parameter nonblocking to getblock.  It must be passed on
  to really_read.  Getblock must check whether really_read returns
  -1, which should be treated the same as 0, except that it does not mean 
  end of file:

int getblock(struct channel * channel, char * p, unsigned n, 
   int nonblocking)
{
  unsigned m, l;

  m = channel->max - channel->curr;
  if (n <= m) {
    bcopy(channel->curr, p, n);
    channel->curr += n;
    return n;
  } else if (m > 0) {
    bcopy(channel->curr, p, m);
    channel->curr += m;
    return m;
  } else if (n < IO_BUFFER_SIZE) {
    l = really_read(channel->fd, channel->buff, IO_BUFFER_SIZE, nonblocking);
    if (l == -1) /* Non-blocking read returned no data */ 
      return -1;
    else {
      channel->offset += l;
      channel->max = channel->buff + l;
      if (n > l) n = l;
      bcopy(channel->buff, p, n);
      channel->curr = channel->buff + n;
      return n;
    }
  } else {
    channel->curr = channel->buff;
    channel->max = channel->buff;
    l = really_read(channel->fd, p, n, nonblocking);
    if (l == -1)	/* Non-blocking read returned no data */ 
      return -1;
    else {
      channel->offset += l;
      return l;
    }
  }
}

Function input will just call getblock with non-blocking = FALSE:

value input(value channel, value buff, value start, value length) /* ML */
{
  return Val_long(getblock((struct channel *) channel,
                           &Byte(buff, Long_val(start)),
                           (unsigned) Long_val(length),
	                   /* nonblocking = */ FALSE));
}



Make really_getblock call getblock with nonblocking=FALSE:

int really_getblock(struct channel * chan, char * p, unsigned long n)
{
  unsigned r;
  while (n > 0) {
    r = (unsigned)getblock(chan, p, (unsigned) n, /* nonblocking = */ FALSE);
    if (r == 0) return 0;
    p += r;
    n -= r;
  }
  return 1;
}


  Add a new function input_nonblocking, which will call getblock with
  nonblocking=TRUE.  Returns NONE if getblock returns -1, otherwise 
  returns SOME 

value input_nonblocking(value channel, value buff, value start, value length) /* ML */
{ int n = getblock((struct channel *) channel,
                   &Byte(buff, Long_val(start)),
                   (unsigned) Long_val(length),
	           /* nonblocking = */ TRUE));
  if (n == -1)		/* Non-blocking read returned no data */ 
    return Val_NONE;
  else {
    value res = alloc(1, SOMEtag);
    Field(res, 0) = Val_long(n);
    return res;
  }
}

  
* 2000-03-15 Ken: Parametre til lexer-funktioner

  rule comment depth = parse ...

  for at kunne lave en rent funktionel lexing af indlejrede kommentarer.

* 2000-03-28: Add a parser combinator module called Parse.
  Reimplement to use NONE/SOME instead of exceptions.  

  Add a formatting (unparsing) module called Format, using Olivier's
  ideas but avoiding repeated string concatenation (e.g. using a
  wseq-like structure) and having also a prsep style
  iterator-with-separator plus an prmap style iterator.

* If we change constructor ordering, change also dynlibs/interface/cside.c  

  Some change in runtime/sys.c and/or runtime/alloc.c wrt TextIO,
  BasicIO, BinIO, Nonstdio.

  Others?

+ Meta.fke;  Meta.system

* Meta.fke; documentation

+ Lexing.sig

+ Parsing.sig

* mosmllib/README

* Parser combinators: 

* TextIO.scanStream -- get rid of cs?

* Should gc time be subtracted from sys time?  (Timer, Mosml)

* Non-blocking IO should have a function canInput : int -> SOME int instead.

http://www.dina.kvl.dk/~sestoft/sml/imperative-io.html#IMPERATIVE_IO:SIG:SPEC

* 2000-04-26: Michael NorrishL this crashes mosml 1.44 (and 1.99):

datatype 'a result =
    FIRST of 'a
  | SECOND of 'a;
val zz = case FIRST() of
    FIRST _ => ()
  | _ => ();     

while this works:

val z = case SECOND() of
    FIRST _ => ()
  | _ => ();

compiler/Rtvals.sml function prSeq; decode_obj thinks zz is a record
of length 1.  Why?  Has nothing to do with the polymorphism of result.

And really, the *representation* of the result is wrong; here zz
evaluates to false:

datatype result =
    FIRST of int
  | SECOND of int;
val zz = () = (case FIRST 1 of
    FIRST _ => ()
  | _ => ());     

But the generated code looks OK:

(prim (set_global Top.zz/3) 
	(prim (ccall2 sml_equal) (BLOCK 0:1 ) 
	      let (BLOCK 0:2 1) in 
	          ((switch:2 var:0 of 
	              0:2 : (BLOCK 0:1 )) 
	            statichandle (BLOCK 0:1 )) 
              end))

But the Kcode is wrong:

(BLOCK 0:1 ); 
push; 
(BLOCK 0:2 1); 
push; 
access 0; 
strictbranchifnot 1; 
branch 2; 
label 2; (BLOCK 0:1 ); 
label 1; pop 1; 
ccall2 sml_equal;
set_global Top.zz/1

Problem: the returned value is the argument of FIRST (which is a block
of length 1 in this case): nothing is pushed between strictbranchifnot
1 and branch 2.  Probably we forget to generate code to put unit in
the accumulator???  Back.sml line 721, optimization for the case where
the else-branch is a constunit ().  In that case, then other branches
are () too (but may have side effects).

The problem is caused by an optimization in the compiler backend, file
compiler/Back.sml line 721.  If you want to get rid of it, uncomment
this code:

         (* if ifnot = Lconst constUnit
            then let val (lbl, C1) = labelCode C
                 in Kstrictbranchifnot lbl :: compexp sz dp ifso C1 end
            else *)

I'm afraid I introduced this optimization in 1997.  The reasoning was
that if some branch of a switch evaluates to () : unit, then all
branches do, and they are evaluated only for their side effects.  Not
so.  
