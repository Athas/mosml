(* Internal run-time library for lexers generated by mosmllex.
 * Closely based on the library for camllex.  Copyright 1993 INRIA, France. 
 *)

local open Obj in

(*** Lexer buffers *)

type lexbuf;
        (* The type of lexer buffers. A lexer buffer is the argument passed
           to the scanning functions defined by the generated scanners.
           The lexer buffer holds the current state of the scanner, plus
           a function to refill the buffer from the input. *)

prim_val getLexBuffer     : lexbuf -> string           = 1 "field1";
prim_val getLexAbsPos     : lexbuf -> int              = 1 "field2";
prim_val getLexStartPos   : lexbuf -> int              = 1 "field3";
prim_val getLexCurrPos    : lexbuf -> int              = 1 "field4";
prim_val getLexLastPos    : lexbuf -> int              = 1 "field5";
prim_val getLexLastAction : lexbuf -> (lexbuf -> obj)  = 1 "field6";

prim_val setLexAbsPos     : lexbuf -> int -> unit             = 2 "setfield2";
prim_val setLexStartPos   : lexbuf -> int -> unit             = 2 "setfield3";
prim_val setLexCurrPos    : lexbuf -> int -> unit             = 2 "setfield4";
prim_val setLexLastPos    : lexbuf -> int -> unit             = 2 "setfield5";
prim_val setLexLastAction : lexbuf -> (lexbuf -> obj) -> unit = 2 "setfield6";

val createLexerString : string -> lexbuf;
        (* Create a lexer buffer which reads from
           the given string. Reading starts from the first character in
           the string. An end-of-input condition is generated when the
           end of the string is reached. *)

val createLexer : (CharArray.array -> int -> int) -> lexbuf;
        (* Create a lexer buffer with the given function as its reading method.
           When the scanner needs more characters, it will call the given
           function, giving it a character string [s] and a character
           count [n]. The function should put [n] characters or less in [s],
           starting at character number 0, and return the number of characters
           provided. A return value of 0 means end of input. *)

(*** Functions for lexer semantic actions *)

        (* The following functions can be called from the semantic actions
           of lexer definitions (the ML code enclosed in braces that
           computes the value returned by lexing functions). They give
           access to the character string matched by the regular expression
           associated with the semantic action. These functions must be
           applied to the argument [lexbuf], which, in the code generated by
           camllex, is bound to the lexer buffer passed to the parsing
           function. *)

val getLexeme : lexbuf -> string;
        (* [getLexeme lexbuf] returns the string matched by
           the regular expression. *)

val getLexemeChar : lexbuf -> int -> char;
        (* [getLexemeChar lexbuf i] returns character number [i] in
           the matched string. *)

val getLexemeStart : lexbuf -> int;
        (* [getLexemeStart lexbuf] returns the position in the input stream
           of the first character of the matched string. The first character
           of the stream has position 0. *)

val getLexemeEnd : lexbuf -> int;
        (* [getLexemeEnd lexbuf] returns the position in the input stream
           of the character following the last character of the matched
           string. The first character of the stream has position 0. *)
(*--*)

(* The following definitions are used by the generated scanners only.
   They are not intended to be used by user programs. *)

val dummyAction : lexbuf -> obj;
prim_val getNextChar : lexbuf -> char = 1 "get_next_char";
val backtrack : lexbuf -> 'a;

end;
