Moscow ML version 1.44cvr3 (internal release) (16th January 2000)
Enter `quit();' to quit.
- linking values
OK: a
OK: b
OK: c
OK: d
OK: e
OK: f
OK: g
OK: h
OK: i
OK: j
OK: k
OK: l
open A
OK:  a
OK:  b
OK:  c
OK:  d
OK:  e
OK:  f
OK:  g
OK:  h
OK:  i
OK:  j
OK:  k
OK:  l
local open A
OK: a
OK: b
OK: c
OK: d
OK: e
OK: f
OK: g
OK: h
OK: i
OK: j
OK: k
OK: llinking structures
OK: a
OK: b
OK: c
OK: d
OK: e
OK: f
OK: g
OK: h
OK: i
OK: j
OK: k
OK: l
open A
OK: a
OK: b
OK: c
OK: d
OK: e
OK: f
OK: g
OK: h
OK: i
OK: j
OK: k
OK: l
local open A
OK: a
OK: b
OK: c
OK: d
OK: e
OK: f
OK: g
OK: h
OK: i
OK: j
OK: k
OK: llinking functors
OK: a
OK: b
OK: c
OK: d
OK: e
OK: f
OK: g
OK: h
OK: i
OK: j
OK: k
OK: l
open A
OK: a
OK: b
OK: c
OK: d
OK: e
OK: f
OK: g
OK: h
OK: i
OK: j
OK: k
OK: l
local open A in
OK:  a
OK:  b
OK:  c
OK:  d
OK:  e
OK:  f
OK:  g
OK:  h
OK:  i
OK:  j
OK:  k
OK:  l
open A B X
value OK: X.a
value OK: B.b
value OK: X.x
value OK: B.y
structure OK: X.a
structure OK: B.b
structure OK: X.x
structure OK: B.y
functor OK: X.a
functor OK: B.b
functor OK: X.x
functor OK: B.y
local open A Y.B X
value OK: X.a
value OK: B.b
value OK: X.x
value OK: B.y
structure OK: X.a
structure OK: B.b
structure OK: X.x
structure OK: B.y
functor OK: X.a
functor OK: B.b
functor OK: X.x
functor OK: B.y
open B A X
value OK: X.a
value OK: b
value OK: X.x
value OK: B.y
structure OK: X.a
structure OK: b
structure OK: X.x
structure OK: B.y
functor OK: X.a
functor OK: b
functor OK: X.x
functor OK: B.y
local open B A X
value OK: X.a
value OK: b
value OK: X.x
value OK: B.y
structure OK: X.a
structure OK: b
structure OK: X.x
structure OK: B.y
functor OK: X.a
functor OK: b
functor OK: X.x
functor OK: B.y
open B X A
value OK: a
value OK: b
value OK: X.x
value OK: B.y
structure OK: a
structure OK: b
structure OK: X.x
structure OK: B.y
functor OK: a
functor OK: b
functor OK: X.x
functor OK: B.y
local open B X A
value OK: a
value OK: b
value OK: X.x
value OK: B.y
structure OK: a
structure OK: b
structure OK: X.x
structure OK: B.y
functor OK: a
functor OK: b
functor OK: X.x
functor OK: B.y
open A X B
value OK: B.a
value OK: B.b
value OK: X.x
value OK: B.y
structure OK: B.a
structure OK: B.b
structure OK: X.x
structure OK: B.y
functor OK: B.a
functor OK: B.b
functor OK: X.x
functor OK: B.y
local open A X B
value OK: B.a
value OK: B.b
value OK: X.x
value OK: B.y
structure OK: B.a
structure OK: B.b
structure OK: X.x
structure OK: B.y
functor OK: B.a
functor OK: B.b
functor OK: X.x
functor OK: B.y
open X A B
value OK: B.a
value OK: B.b
value OK: X.x
value OK: B.y
structure OK: B.a
structure OK: B.b
structure OK: X.x
structure OK: B.y
functor OK: B.a
functor OK: B.b
functor OK: X.x
functor OK: B.y
local open X A B
value OK: B.a
value OK: B.b
value OK: X.x
value OK: B.y
structure OK: B.a
structure OK: B.b
structure OK: X.x
structure OK: B.y
functor OK: B.a
functor OK: B.b
functor OK: X.x
functor OK: B.y
open X B A
value OK: a
value OK: b
value OK: X.x
value OK: B.y
structure OK: a
structure OK: b
structure OK: X.x
structure OK: B.y
functor OK: a
functor OK: b
functor OK: X.x
functor OK: B.y
local open X B A
value OK: a
value OK: b
value OK: X.x
value OK: B.y
structure OK: a
structure OK: b
structure OK: X.x
structure OK: B.y
functor OK: a
functor OK: b
functor OK: X.x
functor OK: B.y- 
- 
Moscow ML version 1.44cvr3 (internal release) (16th January 2000)
Enter `quit();' to quit.
- > structure A :
  {structure a : {val v : string},
   structure b : {val v : string},
   structure c : {val v : string},
   structure d : {val v : string},
   structure e : {val v : string},
   structure f : {val v : string},
   structure g : {val v : string},
   structure h : {val v : string},
   structure i : {val v : string},
   structure j : {val v : string},
   structure k : {val v : string},
   structure l : {val v : string},
   functor a : {}->{val v : string},
   functor b : {}->{val v : string},
   functor c : {}->{val v : string},
   functor d : {}->{val v : string},
   functor e : {}->{val v : string},
   functor f : {}->{val v : string},
   functor g : {}->{val v : string},
   functor h : {}->{val v : string},
   functor i : {}->{val v : string},
   functor j : {}->{val v : string},
   functor k : {}->{val v : string},
   functor l : {}->{val v : string},
   val a : string,
   val b : string,
   val c : string,
   val d : string,
   val e : string,
   val f : string,
   val g : string,
   val h : string,
   val i : string,
   val j : string,
   val k : string,
   val l : string}
- > structure Y :
  {structure A1 :
     {structure a : {val v : string},
      structure b : {val v : string},
      structure c : {val v : string},
      structure d : {val v : string},
      structure e : {val v : string},
      structure f : {val v : string},
      structure g : {val v : string},
      structure h : {val v : string},
      structure i : {val v : string},
      structure j : {val v : string},
      structure k : {val v : string},
      structure l : {val v : string},
      functor a : {}->{val v : string},
      functor b : {}->{val v : string},
      functor c : {}->{val v : string},
      functor d : {}->{val v : string},
      functor e : {}->{val v : string},
      functor f : {}->{val v : string},
      functor g : {}->{val v : string},
      functor h : {}->{val v : string},
      functor i : {}->{val v : string},
      functor j : {}->{val v : string},
      functor k : {}->{val v : string},
      functor l : {}->{val v : string},
      val a : string,
      val b : string,
      val c : string,
      val d : string,
      val e : string,
      val f : string,
      val g : string,
      val h : string,
      val i : string,
      val j : string,
      val k : string,
      val l : string},
   structure B :
     {structure a : {val v : string},
      structure b : {val v : string},
      structure y : {val v : string},
      functor a : {}->{val v : string},
      functor b : {}->{val v : string},
      functor y : {}->{val v : string},
      val a : string,
      val b : string,
      val y : string},
   structure C1 :
     {structure a : {val v : string},
      structure b : {val v : string},
      structure c : {val v : string},
      structure d : {val v : string},
      structure e : {val v : string},
      structure f : {val v : string},
      structure g : {val v : string},
      structure h : {val v : string},
      structure i : {val v : string},
      structure j : {val v : string},
      structure k : {val v : string},
      structure l : {val v : string},
      functor a : {}->{val v : string},
      functor b : {}->{val v : string},
      functor c : {}->{val v : string},
      functor d : {}->{val v : string},
      functor e : {}->{val v : string},
      functor f : {}->{val v : string},
      functor g : {}->{val v : string},
      functor h : {}->{val v : string},
      functor i : {}->{val v : string},
      functor j : {}->{val v : string},
      functor k : {}->{val v : string},
      functor l : {}->{val v : string},
      val a : string,
      val b : string,
      val c : string,
      val d : string,
      val e : string,
      val f : string,
      val g : string,
      val h : string,
      val i : string,
      val j : string,
      val k : string,
      val l : string},
   structure D1 :
     {structure a : {val v : string},
      structure b : {val v : string},
      structure c : {val v : string},
      structure d : {val v : string},
      structure e : {val v : string},
      structure f : {val v : string},
      structure g : {val v : string},
      structure h : {val v : string},
      structure i : {val v : string},
      structure j : {val v : string},
      structure k : {val v : string},
      structure l : {val v : string},
      functor a : {}->{val v : string},
      functor b : {}->{val v : string},
      functor c : {}->{val v : string},
      functor d : {}->{val v : string},
      functor e : {}->{val v : string},
      functor f : {}->{val v : string},
      functor g : {}->{val v : string},
      functor h : {}->{val v : string},
      functor i : {}->{val v : string},
      functor j : {}->{val v : string},
      functor k : {}->{val v : string},
      functor l : {}->{val v : string},
      val a : string,
      val b : string,
      val c : string,
      val d : string,
      val e : string,
      val f : string,
      val g : string,
      val h : string,
      val i : string,
      val j : string,
      val k : string,
      val l : string},
   functor A1 : {}->{},
   val a : string}
- linking values- > val check = fn : string -> string -> unit
- 
OK: a- 
OK: b- 
OK: c- 
OK: d- 
OK: e- 
OK: f- 
OK: g- 
OK: h- 
OK: i- 
OK: j- 
OK: k- 
OK: l- 
open A
OK: a
OK: b
OK: c
OK: d
OK: e
OK: f
OK: g
OK: h
OK: i
OK: j
OK: k
OK: l- 
local open A
OK: a
OK: b
OK: c
OK: d
OK: e
OK: f
OK: g
OK: h
OK: i
OK: j
OK: k
OK: l- linking structures
OK: a
OK: b
OK: c
OK: d
OK: e
OK: f
OK: g
OK: h
OK: i
OK: j
OK: k
OK: l- 
open A
OK: a
OK: b
OK: c
OK: d
OK: e
OK: f
OK: g
OK: h
OK: i
OK: j
OK: k
OK: l- 
local open A
OK: a
OK: b
OK: c
OK: d
OK: e
OK: f
OK: g
OK: h
OK: i
OK: j
OK: k
OK: l- linking functors
OK: a
OK: b
OK: c
OK: d
OK: e
OK: f
OK: g
OK: h
OK: i
OK: j
OK: k
OK: l- 
open A
OK: a
OK: b
OK: c
OK: d
OK: e
OK: f
OK: g
OK: h
OK: i
OK: j
OK: k
OK: l- 
local open A in
OK: a
OK: b
OK: c
OK: d
OK: e
OK: f
OK: g
OK: h
OK: i
OK: j
OK: k
OK: l- > structure X :
  {structure a : {val v : string},
   structure x : {val v : string},
   functor a : {}->{val v : string},
   functor x : {}->{val v : string},
   val a : string,
   val x : string}
  val check = fn : string -> string -> string -> unit
- 
open A B X
value OK: X.a
value OK: B.b
value OK: X.x
value OK: B.y
structure OK: X.a
structure OK: B.b
structure OK: X.x
structure OK: B.y
functor OK: X.a
functor OK: B.b
functor OK: X.x
functor OK: B.y- 
local open A Y.B X
value OK: X.a
value OK: B.b
value OK: X.x
value OK: B.y
structure OK: X.a
structure OK: B.b
structure OK: X.x
structure OK: B.y
functor OK: X.a
functor OK: B.b
functor OK: X.x
functor OK: B.y- 
open B A X
value OK: X.a
value OK: b
value OK: X.x
value OK: B.y
structure OK: X.a
structure OK: b
structure OK: X.x
structure OK: B.y
functor OK: X.a
functor OK: b
functor OK: X.x
functor OK: B.y- 
local open B A X
value OK: X.a
value OK: b
value OK: X.x
value OK: B.y
structure OK: X.a
structure OK: b
structure OK: X.x
structure OK: B.y
functor OK: X.a
functor OK: b
functor OK: X.x
functor OK: B.y- 
open B X A
value OK: a
value OK: b
value OK: X.x
value OK: B.y
structure OK: a
structure OK: b
structure OK: X.x
structure OK: B.y
functor OK: a
functor OK: b
functor OK: X.x
functor OK: B.y
local open B X A
value OK: a
value OK: b
value OK: X.x
value OK: B.y
structure OK: a
structure OK: b
structure OK: X.x
structure OK: B.y
functor OK: a
functor OK: b
functor OK: X.x
functor OK: B.y- 
open A X B
value OK: B.a
value OK: B.b
value OK: X.x
value OK: B.y
structure OK: B.a
structure OK: B.b
structure OK: X.x
structure OK: B.y
functor OK: B.a
functor OK: B.b
functor OK: X.x
functor OK: B.y- 
local open A X B
value OK: B.a
value OK: B.b
value OK: X.x
value OK: B.y
structure OK: B.a
structure OK: B.b
structure OK: X.x
structure OK: B.y
functor OK: B.a
functor OK: B.b
functor OK: X.x
functor OK: B.y- 
open X A B
value OK: B.a
value OK: B.b
value OK: X.x
value OK: B.y
structure OK: B.a
structure OK: B.b
structure OK: X.x
structure OK: B.y
functor OK: B.a
functor OK: B.b
functor OK: X.x
functor OK: B.y- 
local open X A B
value OK: B.a
value OK: B.b
value OK: X.x
value OK: B.y
structure OK: B.a
structure OK: B.b
structure OK: X.x
structure OK: B.y
functor OK: B.a
functor OK: B.b
functor OK: X.x
functor OK: B.y- 
open X B A
value OK: a
value OK: b
value OK: X.x
value OK: B.y
structure OK: a
structure OK: b
structure OK: X.x
structure OK: B.y
functor OK: a
functor OK: b
functor OK: X.x
functor OK: B.y- 
local open X B A
value OK: a
value OK: b
value OK: X.x
value OK: B.y
structure OK: a
structure OK: b
structure OK: X.x
structure OK: B.y
functor OK: a
functor OK: b
functor OK: X.x
functor OK: B.y- 
- 
Moscow ML version 1.44cvr3 (internal release) (16th January 2000)
Enter `quit();' to quit.
- > val it = () : unit
- > val it = () : unit
- > val it = () : unit
- > val it = () : unit
- > val it = () : unit
- linking values
OK: a
OK: b
OK: c
OK: d
OK: e
OK: f
OK: g
OK: h
OK: i
OK: j
OK: k
OK: l
open A
OK: a
OK: b
OK: c
OK: d
OK: e
OK: f
OK: g
OK: h
OK: i
OK: j
OK: k
OK: l
local open A
OK: a
OK: b
OK: c
OK: d
OK: e
OK: f
OK: g
OK: h
OK: i
OK: j
OK: k
OK: llinking structures
OK: a
OK: b
OK: c
OK: d
OK: e
OK: f
OK: g
OK: h
OK: i
OK: j
OK: k
OK: l
open A
OK: a
OK: b
OK: c
OK: d
OK: e
OK: f
OK: g
OK: h
OK: i
OK: j
OK: k
OK: l
local open A
OK: a
OK: b
OK: c
OK: d
OK: e
OK: f
OK: g
OK: h
OK: i
OK: j
OK: k
OK: llinking functors
OK: a
OK: b
OK: c
OK: d
OK: e
OK: f
OK: g
OK: h
OK: i
OK: j
OK: k
OK: l
open A
OK: a
OK: b
OK: c
OK: d
OK: e
OK: f
OK: g
OK: h
OK: i
OK: j
OK: k
OK: l
local open A in
OK: a
OK: b
OK: c
OK: d
OK: e
OK: f
OK: g
OK: h
OK: i
OK: j
OK: k
OK: l
 open A B X
value OK: X.a
value OK: B.b
value OK: X.x
value OK: B.y
structure OK: X.a
structure OK: B.b
structure OK: X.x
structure OK: B.y
functor OK: X.a
functor OK: B.b
functor OK: X.x
functor OK: B.y
local open A B X
value OK: X.a
value OK: B.b
value OK: X.x
value OK: B.y
structure OK: X.a
structure OK: B.b
structure OK: X.x
structure OK: B.y
functor OK: X.a
functor OK: B.b
functor OK: X.x
functor OK: B.y
open B A X
value OK: X.a
value OK: b
value OK: X.x
value OK: B.y
structure OK: X.a
structure OK: b
structure OK: X.x
structure OK: B.y
functor OK: X.a
functor OK: b
functor OK: X.x
functor OK: B.y
local open B A X
value OK: X.a
value OK: b
value OK: X.x
value OK: B.y
structure OK: X.a
structure OK: b
structure OK: X.x
structure OK: B.y
functor OK: X.a
functor OK: b
functor OK: X.x
functor OK: B.y
open B X A
value OK: a
value OK: b
value OK: X.x
value OK: B.y
structure OK: a
structure OK: b
structure OK: X.x
structure OK: B.y
functor OK: a
functor OK: b
functor OK: X.x
functor OK: B.y
local open B X A
value OK: a
value OK: b
value OK: X.x
value OK: B.y
structure OK: a
structure OK: b
structure OK: X.x
structure OK: B.y
functor OK: a
functor OK: b
functor OK: X.x
functor OK: B.y
open A X B
value OK: B.a
value OK: B.b
value OK: X.x
value OK: B.y
structure OK: B.a
structure OK: B.b
structure OK: X.x
structure OK: B.y
functor OK: B.a
functor OK: B.b
functor OK: X.x
functor OK: B.y
local open A X B
value OK: B.a
value OK: B.b
value OK: X.x
value OK: B.y
structure OK: B.a
structure OK: B.b
structure OK: X.x
structure OK: B.y
functor OK: B.a
functor OK: B.b
functor OK: X.x
functor OK: B.y
open X A B
value OK: B.a
value OK: B.b
value OK: X.x
value OK: B.y
structure OK: B.a
structure OK: B.b
structure OK: X.x
structure OK: B.y
functor OK: B.a
functor OK: B.b
functor OK: X.x
functor OK: B.y
local open X A B
value OK: B.a
value OK: B.b
value OK: X.x
value OK: B.y
structure OK: B.a
structure OK: B.b
structure OK: X.x
structure OK: B.y
functor OK: B.a
functor OK: B.b
functor OK: X.x
functor OK: B.y
open X B A
value OK: a
value OK: b
value OK: X.x
value OK: B.y
structure OK: a
structure OK: b
structure OK: X.x
structure OK: B.y
functor OK: a
functor OK: b
functor OK: X.x
functor OK: B.y
local open X B A
value OK: a
value OK: b
value OK: X.x
value OK: B.y
structure OK: a
structure OK: b
structure OK: X.x
structure OK: B.y
functor OK: a
functor OK: b
functor OK: X.x
functor OK: B.y
> val it = () : unit
- 
Moscow ML version 1.44cvr3 (internal release) (16th January 2000)
Enter `quit();' to quit.
- > signature Array =
  /\array.
    {type 'a array = 'a array,
     val 'a init : 'a -> 'a array,
     val 'a sub : 'a array -> int -> 'a,
     val 'a update : 'a array -> int -> 'a -> 'a array}
- > structure ArrayZero :
  {type 'a array = 'a,
   val 'a init : 'a -> 'a,
   val ('a, 'b) sub : 'a -> 'b -> 'a,
   val ('a, 'b, 'c) update : 'a -> 'b -> 'c -> 'c}
- > functor ArraySucc :
  !array.
   {type 'a array = 'a array,
    val 'a init : 'a -> 'a array,
    val 'a sub : 'a array -> int -> 'a,
    val 'a update : 'a array -> int -> 'a -> 'a array}->
       {type 'a array = 'a array * 'a array,
        val 'a init : 'a -> 'a array * 'a array,
        val 'a sub : 'a array * 'a array -> int -> 'a,
        val 'a update :
          'a array * 'a array -> int -> 'a -> 'a array * 'a array}
- > val mkArray = fn :
  int ->
  [?array.
    {type 'a array = 'a array,
     val 'a init : 'a -> 'a array,
     val 'a sub : 'a array -> int -> 'a,
     val 'a update : 'a array -> int -> 'a -> 'a array}]
- > val two = fn : int -> int
- > val n = 10 : int
- > val max = 1024 : int
- > val 'a iter = fn : ('a -> int -> 'a) -> 'a -> int -> 'a
- > New type names: array
  structure A :
  {type 'a array = 'a array,
   val 'a init : 'a -> 'a array,
   val 'a sub : 'a array -> int -> 'a,
   val 'a update : 'a array -> int -> 'a -> 'a array}
- > val a = <array> : int array
- > val test1 = "OK" : string
- > val a = <array> : int array
- > val l =
    [1024, 1023, 1022, 1021, 1020, 1019, 1018, 1017, 1016, 1015, 1014, 1013,
     1012, 1011, 1010, 1009, 1008, 1007, 1006, 1005, 1004, 1003, 1002, 1001,
     1000, 999, 998, 997, 996, 995, 994, 993, 992, 991, 990, 989, 988, 987,
     986, 985, 984, 983, 982, 981, 980, 979, 978, 977, 976, 975, 974, 973, 972,
     971, 970, 969, 968, 967, 966, 965, 964, 963, 962, 961, 960, 959, 958, 957,
     956, 955, 954, 953, 952, 951, 950, 949, 948, 947, 946, 945, 944, 943, 942,
     941, 940, 939, 938, 937, 936, 935, 934, 933, 932, 931, 930, 929, 928, 927,
     926, 925, 924, 923, 922, 921, 920, 919, 918, 917, 916, 915, 914, 913, 912,
     911, 910, 909, 908, 907, 906, 905, 904, 903, 902, 901, 900, 899, 898, 897,
     896, 895, 894, 893, 892, 891, 890, 889, 888, 887, 886, 885, 884, 883, 882,
     881, 880, 879, 878, 877, 876, 875, 874, 873, 872, 871, 870, 869, 868, 867,
     866, 865, 864, 863, 862, 861, 860, 859, 858, 857, 856, 855, 854, 853, 852,
     851, 850, 849, 848, 847, 846, 845, 844, 843, 842, 841, 840, 839, 838, 837,
     836, 835, 834, 833, 832, 831, 830, 829, 828, 827, 826, 825, ...] :
  int list
  val test2 = "OK" : string
- 
Moscow ML version 1.44cvr3 (internal release) (16th January 2000)
Enter `quit();' to quit.
- > signature Array =
  /\array.
    {type 'a array = 'a array,
     val 'a init : 'a -> 'a array,
     val 'a update : 'a array -> int -> 'a -> 'a array,
     val 'a sub : 'a array -> int -> 'a}
- > structure ArrayZero :
  {type 'a array = 'a,
   val 'a init : 'a -> 'a,
   val ('a, 'b) sub : 'a -> 'b -> 'a,
   val ('a, 'b, 'c) update : 'a -> 'b -> 'c -> 'c}
- > functor ArraySucc :
  !array.
   {type 'a array = 'a array,
    val 'a init : 'a -> 'a array,
    val 'a update : 'a array -> int -> 'a -> 'a array,
    val 'a sub : 'a array -> int -> 'a}->
       {type 'a array = 'a array * 'a array,
        val 'a init : 'a -> 'a array * 'a array,
        val 'a sub : 'a array * 'a array -> int -> 'a,
        val 'a update :
          'a array * 'a array -> int -> 'a -> 'a array * 'a array}
- > val mkArray = fn :
  int ->
  [?array.
    {type 'a array = 'a array,
     val 'a init : 'a -> 'a array,
     val 'a update : 'a array -> int -> 'a -> 'a array,
     val 'a sub : 'a array -> int -> 'a}]
- > val two = fn : int -> int
- > val n = 10 : int
- > val max = 1024 : int
- > val 'a iter = fn : ('a -> int -> 'a) -> 'a -> int -> 'a
- > New type names: array
  structure A :
  {type 'a array = 'a array,
   val 'a init : 'a -> 'a array,
   val 'a sub : 'a array -> int -> 'a,
   val 'a update : 'a array -> int -> 'a -> 'a array}
- > val a = <array> : int array
- > val test1 = "OK" : string
- > val a = <array> : int array
- > val l =
    [1024, 1023, 1022, 1021, 1020, 1019, 1018, 1017, 1016, 1015, 1014, 1013,
     1012, 1011, 1010, 1009, 1008, 1007, 1006, 1005, 1004, 1003, 1002, 1001,
     1000, 999, 998, 997, 996, 995, 994, 993, 992, 991, 990, 989, 988, 987,
     986, 985, 984, 983, 982, 981, 980, 979, 978, 977, 976, 975, 974, 973, 972,
     971, 970, 969, 968, 967, 966, 965, 964, 963, 962, 961, 960, 959, 958, 957,
     956, 955, 954, 953, 952, 951, 950, 949, 948, 947, 946, 945, 944, 943, 942,
     941, 940, 939, 938, 937, 936, 935, 934, 933, 932, 931, 930, 929, 928, 927,
     926, 925, 924, 923, 922, 921, 920, 919, 918, 917, 916, 915, 914, 913, 912,
     911, 910, 909, 908, 907, 906, 905, 904, 903, 902, 901, 900, 899, 898, 897,
     896, 895, 894, 893, 892, 891, 890, 889, 888, 887, 886, 885, 884, 883, 882,
     881, 880, 879, 878, 877, 876, 875, 874, 873, 872, 871, 870, 869, 868, 867,
     866, 865, 864, 863, 862, 861, 860, 859, 858, 857, 856, 855, 854, 853, 852,
     851, 850, 849, 848, 847, 846, 845, 844, 843, 842, 841, 840, 839, 838, 837,
     836, 835, 834, 833, 832, 831, 830, 829, 828, 827, 826, 825, ...] :
  int list
  val test2 = "OK" : string
- 
Moscow ML version 1.44cvr3 (internal release) (16th January 2000)
Enter `quit();' to quit.
- > val divides = fn : int -> int -> bool
- > val succ = fn : int -> int
- > signature Stream =
  /\state.
    {type state = state,
     val start : state,
     val next : state -> state,
     val value : state -> int}
- > val sift = fn :
  [?state.
    {type state = state,
     val start : state,
     val next : state -> state,
     val value : state -> int}] ->
  [?state.
    {type state = state,
     val start : state,
     val next : state -> state,
     val value : state -> int}]
- > New type names: state
  structure Sieve :
  {type state = state,
   val next : state -> state,
   val start : state,
   val value : state -> int}
- > val nthstate = fn : int -> state
- > val nthprime = fn : int -> int
- > val primes = fn : int -> int list
- > structure StratSieve :
  {structure Start :
     {type state = int,
      val next : int -> int,
      val start : int,
      val 'a value : 'a -> 'a},
   functor Next :
     !state'.
      {type state = state',
       val start : state',
       val next : state' -> state',
       val value : state' -> int}->
          {type state = state',
           val divisor : int,
           val filter : state' -> state',
           val next : state' -> state',
           val start : state',
           val value : state' -> int},
   functor Value :
     !state'.
      {type state = state',
       val start : state',
       val next : state' -> state',
       val value : state' -> int}->{val value : int}}
- > val hundred_primes =
    [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,
     71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149,
     151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229,
     233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313,
     317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409,
     419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499,
     503, 509, 521, 523, 541] : int list
- > val test = "OK" : string
- 
Moscow ML version 1.44cvr3 (internal release) (16th January 2000)
Enter `quit();' to quit.
- > signature POLY =
  /\nat.
    {structure Nat :
       {type nat = nat,
        val z : nat,
        val s : nat -> nat,
        val 'a i : 'a -> ('a -> 'a) -> nat -> 'a},
     val eval : nat -> nat list -> nat}
- > functor MkPoly :
  !nat.
   {type nat = nat,
    val z : nat,
    val s : nat -> nat,
    val 'a i : 'a -> ('a -> 'a) -> nat -> 'a}->
       ({type nat = nat,
         val z : nat,
         val s : nat -> nat,
         val 'a i : 'a -> ('a -> 'a) -> nat -> 'a}->
            {val add : nat -> nat -> nat})->
           ({type nat = nat,
             val z : nat,
             val s : nat -> nat,
             val 'a i : 'a -> ('a -> 'a) -> nat -> 'a}->
                ({type nat = nat,
                  val z : nat,
                  val s : nat -> nat,
                  val 'a i : 'a -> ('a -> 'a) -> nat -> 'a}->
                     {val add : nat -> nat -> nat})->
                    {val mult : nat -> nat -> nat})->
               {structure Add : {val add : nat -> nat -> nat},
                structure Mult : {val mult : nat -> nat -> nat},
                structure Nat :
                  {type nat = nat,
                   val 'a i : 'a -> ('a -> 'a) -> nat -> 'a,
                   val s : nat -> nat,
                   val z : nat},
                val eval : nat -> nat list -> nat}
- > structure Nat :
  {type nat = int,
   val 'a i : 'a -> ('a -> 'a) -> int -> 'a,
   val s : int -> int,
   val z : int}
- > structure N :
  {type nat = int,
   val 'a i : 'a -> ('a -> 'a) -> int -> 'a,
   val s : int -> int,
   val z : int}
- > functor A :
  {type nat = int,
   val z : int,
   val s : int -> int,
   val 'a i : 'a -> ('a -> 'a) -> int -> 'a}->{val add : int -> int -> int}
- > functor M :
  {type nat = int,
   val z : int,
   val s : int -> int,
   val 'a i : 'a -> ('a -> 'a) -> int -> 'a}->
      ({type nat = int,
        val z : int,
        val s : int -> int,
        val 'a i : 'a -> ('a -> 'a) -> int -> 'a}->
           {val add : int -> int -> int})->
          {structure Add : {val add : int -> int -> int},
           val mult : int -> int -> int}
- > structure Poly :
  {structure Add : {val add : int -> int -> int},
   structure Mult : {val mult : int -> int -> int},
   structure Nat :
     {type nat = int,
      val 'a i : 'a -> ('a -> 'a) -> int -> 'a,
      val s : int -> int,
      val z : int},
   val eval : int -> int list -> int}
- > val test = 10 : int
- > functor A' :
  !nat.
   {type nat = nat,
    val s : nat -> nat,
    val i : nat -> (nat -> nat) -> nat -> nat}->
       {val add : nat -> nat -> nat, val sum : nat -> nat list -> nat}
- > structure Poly' :
  {structure Add : {val add : int -> int -> int},
   structure Mult : {val mult : int -> int -> int},
   structure Nat :
     {type nat = int,
      val 'a i : 'a -> ('a -> 'a) -> int -> 'a,
      val s : int -> int,
      val z : int},
   val eval : int -> int list -> int}
- > structure N :
  {type nat = int,
   val 'a i : 'a -> ('a -> 'a) -> int -> 'a,
   val s : int -> int,
   val z : int}
- > functor A : {}->{val add : int -> int -> int}
- > functor M :
  {}->
      ({type nat = int,
        val z : int,
        val s : int -> int,
        val 'a i : 'a -> ('a -> 'a) -> int -> 'a}->{})->
          {val mult : int -> int -> int}
- > structure IntPoly :
  {structure Add : {val add : int -> int -> int},
   structure Mult : {val mult : int -> int -> int},
   structure Nat :
     {type nat = int,
      val 'a i : 'a -> ('a -> 'a) -> int -> 'a,
      val s : int -> int,
      val z : int},
   val eval : int -> int list -> int}
- > val test = 10 : int
- > New type names: nat
  structure FastNat :
  {structure N :
     {type nat = nat,
      val 'a i : 'a -> ('a -> 'a) -> nat -> 'a,
      val s : nat -> nat,
      val z : nat},
   functor A : {}->{val add : nat -> nat -> nat},
   functor M :
     {}->
         ({type nat = nat,
           val z : nat,
           val s : nat -> nat,
           val 'a i : 'a -> ('a -> 'a) -> nat -> 'a}->{})->
             {val mult : nat -> nat -> nat}}
- > structure FastPoly :
  {structure Add : {val add : nat -> nat -> nat},
   structure Mult : {val mult : nat -> nat -> nat},
   structure Nat :
     {type nat = nat,
      val 'a i : 'a -> ('a -> 'a) -> nat -> 'a,
      val s : nat -> nat,
      val z : nat},
   val eval : nat -> nat list -> nat}
- 
Moscow ML version 1.44cvr3 (internal release) (16th January 2000)
Enter `quit();' to quit.
- > functor F : {val a : unit}->{val b : unit}->{val c : unit}->{}
- > structure A : {val a : unit}
  structure B : {val b : unit}
  structure C : {val c : unit}
- > functor F : {val a : unit}->{val b : unit}->{val c : unit}->{}
- > functor FA : {val b : unit}->{val c : unit}->{}
- > functor FAB : {val c : unit}->{}
- > structure FABC : {}
- > functor H : ({}->{})->{}->{}
- > structure X : {}
- > signature A = /\a.{type a = a, val a : a}
- > signature B = /\b.{type b = b, val b : b}
- > signature C = /\c.{type c = c, val c : c}
- > functor X : !a.{type a = a, val a : a}->{type a = a, val a : a}
- > functor X : !a.{type a = a, val a : a}->?a'.{type a = a', val a : a'}
- > functor X : !a.{type a = a, val a : a}->?a'.{type a = a', val a : a'}
- > functor X :
  !a.
   {type a = a, val a : a}->
       !b.
        {type b = b, val b : b}->
            !c.{type c = c, val c : c}->{type a = a, val a : a}
- > functor X :
  !a.
   {type a = a, val a : a}->
       !b.
        {type b = b, val b : b}->
            !c.{type c = c, val c : c}->?a'.{type a = a', val a : a'}
- > functor X :
  !a.
   {type a = a, val a : a}->
       !b.
        {type b = b, val b : b}->
            !c.{type c = c, val c : c}->?a'.{type a = a', val a : a'}
- > signature F = !a.{type a = a, val a : a}->?b.{type b = b, val b : b}
- > signature G =
  (!a.{type a = a, val a : a}->?b.{type b = b, val b : b})->
      ?c.{type c = c, val c : c}
- > signature H =
  ((!a.{type a = a, val a : a}->?b.{type b = b, val b : b})->
       ?c.{type c = c, val c : c})->
      (!a.{type a = a, val a : a}->?b.{type b = b, val b : b})->
          ?c.{type c = c, val c : c}
- > structure A : {type a = int, val a : int}
- > structure B : {type b = int, val b : int}
- > structure C : {type c = int, val c : int}
- > functor F : !a.{type a = a, val a : a}->{type b = int, val b : int}
- > structure FA : {type b = int, val b : int}
- > functor G :
  (!a.{type a = a, val a : a}->?b.{type b = b, val b : b})->
      ?b.{type c = int, val c : int}
- > New type names: b
  structure GF : {type c = int, val c : int}
- > functor F : {}->{}
- > structure FA : {}
- > functor F : !a.{type a = a, val a : a}->{}
- > structure FA : {}
- > functor F : !a.{type a = a, val a : a}->{}
- > structure FA : {}
- > signature A = /\a.{type a = a, val a : a}
- > signature B = /\b'.{type b = b', val b : b'}
- > signature C = /\c.{type c = c, val c : c}
- > signature S =
  {functor F1 : !a.{type a = a, val a : a}->?b'.{type b = b', val b : b'},
   functor F2 : !a.{type a = a, val a : a}->?b'.{type b = b', val b : b'},
   functor F3 :
     !a.
      {type a = a, val a : a}->
          !b'.{type b = b', val b : b'}->?c.{type c = c, val c : c}}
- > signature F = !t.{type t = t}->{}
- > signature F = /\u.{}->{type u = u}
- > signature F = /\u.!t.{type t = t}->{type u = (u t)}
- > New type names: =u, =v
  functor F :
  !t w x.
   {type t = t, type w = w, type x = x}->
       {datatype u = ((u t w x),{con C : (u t w x)}),
        datatype v = ((v t w x),{con D : (v t w x)}),
        con C : (u t w x),
        con D : (v t w x)}
- > New type names: =u', =v'
  functor F :
  !t w x.
   {type t = t, type w = w, type x = x}->
       {datatype 'a u = ('a (u' t w x),{con 'a C : 'a -> 'a (u' t w x)}),
        datatype 'a v = ('a (v' t w x),{con 'b D : 'b -> 'b (v' t w x)}),
        con 'a C : 'a -> 'a (u' t w x),
        con 'b D : 'b -> 'b (v' t w x)}
- 
Moscow ML version 1.44cvr3 (internal release) (16th January 2000)
Enter `quit();' to quit.
- > functor ok :
  !u.(!t.{type t = t'}->{type u = (u t')})->!t.{type t = t}->?u'.{type u = u'}
- ! Toplevel input:
!     op F:functor X:sig type t end -> sig type u end;
!     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Scope Violation: type constructor u of the range has specification:
!   type u = (u t)
! in the signature
! but is implemented by the declaration: 
!   type u = u'
! in the module
! The declaration violates the specification because 
! the type constructor u' is a parameter 
! that is declared within the scope of u.
- > signature S = /\u.!w.{type w = w, type t = w}->{type u = (u w)}
- > functor F : !w.{type w = w, type t = w}->{type u = w * w}
- > functor G : !w.{type w = w, type t = w}->{type u = int * int}
- ! Toplevel input:
! functor Fail = (functor (X:sig type t  end) => struct datatype u = C of X.t * X.t end):S;
!                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Scope Violation: type constructor u of the range has specification:
!   type u = (u w)
! in the signature
! but is implemented by the declaration: 
!   datatype u = (u',{con C : w * w -> u'})
! in the module
! The declaration violates the specification because 
! the type constructor u' is a parameter 
! that is declared within the scope of u.
- > New type names: u
  functor F :
  !t.
   {type t = t, val x : t}->
       {datatype u = ((u t),{con C : t -> (u t), con D : (u t) -> (u t)}),
        con C : t -> (u t),
        con D : (u t) -> (u t),
        val y : (u t),
        val z : (u t)}
- > structure X :
  {datatype u =
     ((u string),
      {con C : string -> (u string), con D : (u string) -> (u string)}),
   con C : string -> (u string),
   con D : (u string) -> (u string),
   val y : (u string),
   val z : (u string)}
- > datatype u =
  ((u string),{con C : string -> (u string), con D : (u string) -> (u string)})
  con C = fn : string -> (u string)
  con D = fn : (u string) -> (u string)
  val y = C "x" : (u string)
  val z = D(C "x") : (u string)
- > New type names: u'
  functor F :
  !s t.
   {type s = s, val w : s, type t = t, val x : t}->
       {datatype u =
          ((u' s t),{con C : s * t -> (u' s t), con D : (u' s t) -> (u' s t)}),
        con C : s * t -> (u' s t),
        con D : (u' s t) -> (u' s t),
        val y : (u' s t),
        val z : (u' s t)}
- > structure X :
  {datatype u =
     ((u' bool string),
      {con C : bool * string -> (u' bool string),
       con D : (u' bool string) -> (u' bool string)}),
   con C : bool * string -> (u' bool string),
   con D : (u' bool string) -> (u' bool string),
   val y : (u' bool string),
   val z : (u' bool string)}
- > datatype u =
  ((u' bool string),
   {con C : bool * string -> (u' bool string),
    con D : (u' bool string) -> (u' bool string)})
  con C = fn : bool * string -> (u' bool string)
  con D = fn : (u' bool string) -> (u' bool string)
  val y = C(true, "x") : (u' bool string)
  val z = D(C(true, "x")) : (u' bool string)
- > New type names: u''
  functor F :
  !s t.
   {type s = s, val w : s, type t = t, val x : t}->
       {datatype 'a u =
          ('a (u'' s t),
           {con 'a C : s * t * 'a -> 'a (u'' s t),
            con 'a D : ('a * 'a) (u'' s t) -> 'a (u'' s t)}),
        con 'a C : s * t * 'a -> 'a (u'' s t),
        con 'a D : ('a * 'a) (u'' s t) -> 'a (u'' s t),
        val y : int (u'' s t),
        val z : int (u'' s t)}
- > structure X :
  {datatype 'a u =
     ('a (u'' bool string),
      {con 'a C : bool * string * 'a -> 'a (u'' bool string),
       con 'a D : ('a * 'a) (u'' bool string) -> 'a (u'' bool string)}),
   con 'a C : bool * string * 'a -> 'a (u'' bool string),
   con 'a D : ('a * 'a) (u'' bool string) -> 'a (u'' bool string),
   val y : int (u'' bool string),
   val z : int (u'' bool string)}
- > datatype 'a u =
  ('a (u'' bool string),
   {con 'a C : bool * string * 'a -> 'a (u'' bool string),
    con 'a D : ('a * 'a) (u'' bool string) -> 'a (u'' bool string)})
  con 'a C = fn : bool * string * 'a -> 'a (u'' bool string)
  con 'a D = fn : ('a * 'a) (u'' bool string) -> 'a (u'' bool string)
  val y = C(true, "x", 1) : int (u'' bool string)
  val z = D(C(true, "x", (1, 1))) : int (u'' bool string)
- > New type names: u'''
  functor A :
  !b a.
   {type a = a, type b = b, val a : a, val b : b}->
       {datatype u = ((u''' b a),{con C : a * b -> (u''' b a)}),
        con C : a * b -> (u''' b a),
        val y : (u''' b a)}
- > structure A :
  {datatype u = ((u''' bool int),{con C : int * bool -> (u''' bool int)}),
   con C : int * bool -> (u''' bool int),
   val y : (u''' bool int)}
- > datatype u = ((u''' bool int),{con C : int * bool -> (u''' bool int)})
  con C = fn : int * bool -> (u''' bool int)
  val y = C(1, false) : (u''' bool int)
- > New type names: u'''', v, =w, x
  functor A :
  !c b a.
   {type a = a,
    type b = b,
    type 'a c = 'a c,
    val 'a a : a,
    val 'a b : b,
    val 'a f : 'a -> 'a c}->
       {datatype u = ((u'''' c b a),{con C : a * b -> (u'''' c b a)}),
        datatype v =
          ((v c b a),
           {con B : (v c b a), con D : a * b * (v c b a) -> (v c b a)}),
        datatype 'a w =
          ('a (w c b a),
           {con 'a B : 'a -> 'a (w c b a),
            con 'a D : ('a * 'a) (w c b a) -> 'a (w c b a)}),
        datatype 'a x =
          ('a (x c b a),
           {con 'a B : 'a -> 'a (x c b a),
            con 'a D : 'a c (x c b a) -> 'a (x c b a)}),
        con 'a B : 'a -> 'a (x c b a),
        con C : a * b -> (u'''' c b a),
        con 'a D : 'a c (x c b a) -> 'a (x c b a),
        val u : (u'''' c b a),
        val v : (v c b a),
        val w : (a * b) (w c b a),
        val x : (a * b) (x c b a)}
- > structure A :
  {datatype u =
     ((u'''' (/\'a.{l : 'a, r : 'a}) bool int),
      {con C : int * bool -> (u'''' (/\'a.{l : 'a, r : 'a}) bool int)}),
   datatype v =
     ((v (/\'a.{l : 'a, r : 'a}) bool int),
      {con B : (v (/\'a.{l : 'a, r : 'a}) bool int),
       con D :
         int * bool * (v (/\'a.{l : 'a, r : 'a}) bool int) ->
         (v (/\'a.{l : 'a, r : 'a}) bool int)}),
   datatype 'a w =
     ('a (w (/\'a'.{l : 'a', r : 'a'}) bool int),
      {con 'a B : 'a -> 'a (w (/\'a'.{l : 'a', r : 'a'}) bool int),
       con 'a D :
         ('a * 'a) (w (/\'a'.{l : 'a', r : 'a'}) bool int) ->
         'a (w (/\'a'.{l : 'a', r : 'a'}) bool int)}),
   datatype 'a x =
     ('a (x (/\'a'.{l : 'a', r : 'a'}) bool int),
      {con 'a B : 'a -> 'a (x (/\'a'.{l : 'a', r : 'a'}) bool int),
       con 'a D :
         {l : 'a, r : 'a} (x (/\'a'.{l : 'a', r : 'a'}) bool int) ->
         'a (x (/\'a'.{l : 'a', r : 'a'}) bool int)}),
   con 'a B : 'a -> 'a (x (/\'a'.{l : 'a', r : 'a'}) bool int),
   con C : int * bool -> (u'''' (/\'a.{l : 'a, r : 'a}) bool int),
   con 'a D :
     {l : 'a, r : 'a} (x (/\'a'.{l : 'a', r : 'a'}) bool int) ->
     'a (x (/\'a'.{l : 'a', r : 'a'}) bool int),
   val u : (u'''' (/\'a.{l : 'a, r : 'a}) bool int),
   val v : (v (/\'a.{l : 'a, r : 'a}) bool int),
   val w : (int * bool) (w (/\'a.{l : 'a, r : 'a}) bool int),
   val x : (int * bool) (x (/\'a.{l : 'a, r : 'a}) bool int)}
- > datatype u =
  ((u'''' (/\'a.{l : 'a, r : 'a}) bool int),
   {con C : int * bool -> (u'''' (/\'a.{l : 'a, r : 'a}) bool int)})
  datatype v =
  ((v (/\'a.{l : 'a, r : 'a}) bool int),
   {con B : (v (/\'a.{l : 'a, r : 'a}) bool int),
    con D :
      int * bool * (v (/\'a.{l : 'a, r : 'a}) bool int) ->
      (v (/\'a.{l : 'a, r : 'a}) bool int)})
  datatype 'a w =
  ('a (w (/\'a'.{l : 'a', r : 'a'}) bool int),
   {con 'a B : 'a -> 'a (w (/\'a'.{l : 'a', r : 'a'}) bool int),
    con 'a D :
      ('a * 'a) (w (/\'a'.{l : 'a', r : 'a'}) bool int) ->
      'a (w (/\'a'.{l : 'a', r : 'a'}) bool int)})
  datatype 'a x =
  ('a (x (/\'a'.{l : 'a', r : 'a'}) bool int),
   {con 'a B : 'a -> 'a (x (/\'a'.{l : 'a', r : 'a'}) bool int),
    con 'a D :
      {l : 'a, r : 'a} (x (/\'a'.{l : 'a', r : 'a'}) bool int) ->
      'a (x (/\'a'.{l : 'a', r : 'a'}) bool int)})
  con 'a B = fn : 'a -> 'a (x (/\'a'.{l : 'a', r : 'a'}) bool int)
  con C = fn : int * bool -> (u'''' (/\'a.{l : 'a, r : 'a}) bool int)
  con 'a D = fn :
  {l : 'a, r : 'a} (x (/\'a'.{l : 'a', r : 'a'}) bool int) ->
  'a (x (/\'a'.{l : 'a', r : 'a'}) bool int)
  val u = C(1, false) : (u'''' (/\'a.{l : 'a, r : 'a}) bool int)
  val v = D(1, false, D(1, false, D(1, false, B))) :
  (v (/\'a.{l : 'a, r : 'a}) bool int)
  val w = D(B((1, false), (1, false))) :
  (int * bool) (w (/\'a.{l : 'a, r : 'a}) bool int)
  val x = D(B{l = (1, false), r = (1, false)}) :
  (int * bool) (x (/\'a.{l : 'a, r : 'a}) bool int)
- 
Moscow ML version 1.44cvr3 (internal release) (16th January 2000)
Enter `quit();' to quit.
- > structure A :
  {structure B : {val b : bool, val c : string},
   type t = int,
   val a : int,
   val 'a d : 'a list,
   exn e : exn}
- > val it = 1 : int
- > val it = true : bool
- > val it = true : bool
- > val it = "c" : string
- > val 'a it = [] : 'a list
- > val it = e : exn
- > val it = e : exn
- > val it = "c" : string
- > val it = "c" : string
- > type u = int
- > type u = int
- > New type names: =v
  functor A : {}->{datatype v = (v,{con C : v}), con C : v}
- > type u = v
- > datatype u = (v,{con C : v})
  con C = C : v
- ! Toplevel input:
! type fail = X.t where X = struct type v = int datatype t = C of t end;
!             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Illegal projection: this projection causes an existential type constructor to escape its scope
- ! Toplevel input:
! type fail = X.v where X = struct datatype t = C of t type v = t end;
!             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Illegal projection: this projection causes an existential type constructor to escape its scope
- > functor G : {}->?=v'.{datatype v = (v',{con C : v'}), con C : v'}
- ! Toplevel input:
! type fail = X.v where X = G();
!             ^^^^^^^^^^^^^^^^^
! Illegal projection: this projection causes an existential type constructor to escape its scope
- ! Toplevel input:
! val fail = X.C where X = struct datatype t = C of t end;
!            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Type clash: expression of type
!   t -> t
! cannot have type
!   'a
! because of a scope violation:
! the type constructor t is a parameter 
! that is declared within the scope of 'a
- > functor G : {}->?=v'.{datatype v = (v',{con C : v'}), con C : v'}
- ! Toplevel input:
! val fail = X.C where X = G();
!            ^^^^^^^^^^^^^^^^^
! Type clash: expression of type
!   v'
! cannot have type
!   'a
! because of a scope violation:
! the type constructor v' is a parameter 
! that is declared within the scope of 'a
- > functor G : {}->?=v'.{datatype v = (v',{con C : v'}), con C : v'}
- > New type names: =v'
  structure OK : {datatype v = (v',{con C : v'}), con C : v'}
- 
Moscow ML version 1.44cvr3 (internal release) (16th January 2000)
Enter `quit();' to quit.
- > signature Collection =
  /\e t.{type e = e, type t = t, val empty : t, val add : e -> t -> t}
- > functor Set :
  !e.
   {type e = e, val ord : e * e -> bool}->
       ?t.{type e = e, type t = t, val add : e -> t -> t, val empty : t}
- > New type names: t
  structure IncSet :
  {type e = int, type t = t, val add : int -> t -> t, val empty : t}
- > New type names: t'
  structure DecSet :
  {type e = int, type t = t', val add : int -> t' -> t', val empty : t'}
- ! Toplevel input:
! val fail =  DecSet.add 2 (IncSet.add 1 IncSet.empty);
!                           ^^^^^^^^^^^^^^^^^^^^^^^^^
! Type clash: expression of type
!   t
! cannot have type
!   t'
- > New type names: t''
  functor List :
  !e.
   {type e = e}->
       {type e = e,
        type t = (t'' e),
        val add : e -> (t'' e) -> (t'' e),
        val empty : (t'' e)}
- > structure IncList :
  {type e = int,
   type t = (t'' int),
   val add : int -> (t'' int) -> (t'' int),
   val empty : (t'' int)}
- > structure DecList :
  {type e = int,
   type t = (t'' int),
   val add : int -> (t'' int) -> (t'' int),
   val empty : (t'' int)}
- > val ok = <t'' int> : (t'' int)
- > structure BoolList :
  {type e = bool,
   type t = (t'' bool),
   val add : bool -> (t'' bool) -> (t'' bool),
   val empty : (t'' bool)}
- ! Toplevel input:
! val fail = BoolList.add true (IncList.add 1 IncList.empty);
!                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Type clash: expression of type
!   (t'' int)
! cannot have type
!   (t'' bool)
- 
Moscow ML version 1.44cvr3 (internal release) (16th January 2000)
Enter `quit();' to quit.
- > structure X : {type 'a r = 'a ref}
- > type 'a r = 'a ref
- > structure Y : {type 'a r = 'a ref}
- > structure Z : {type 'a r = 'a ref}
  type 'a r = 'a ref
- 
Moscow ML version 1.44cvr3 (internal release) (16th January 2000)
Enter `quit();' to quit.
- > New type names: =u
  structure A :
  {datatype u = ((u unit),{con C : unit ref -> (u unit)}),
   con C : unit ref -> (u unit)}
  functor F :
  !t.
   {type t = t}->
       {datatype u = ((u t),{con C : t ref -> (u t)}), con C : t ref -> (u t)}
- > val ok = fn : (u unit) * (u unit) -> bool
- > structure B :
  {datatype u =
     ((u (unit -> unit)),{con C : (unit -> unit) ref -> (u (unit -> unit))}),
   con C : (unit -> unit) ref -> (u (unit -> unit))}
- > val ok = fn : (u (unit -> unit)) * (u (unit -> unit)) -> bool
- > New type names: u'
  functor G :
  !t.
   {type t = t}->
       {datatype u = ((u' t),{con C : t -> (u' t)}), con C : t -> (u' t)}
- > structure C :
  {datatype u = ((u' unit),{con C : unit -> (u' unit)}),
   con C : unit -> (u' unit)}
- ! Toplevel input:
! val fail = op = : C.u * C.u -> bool;
!            ^^^^
! Type clash: expression of type
!   ''a * ''a -> bool
! cannot have type
!   (u' unit) * (u' unit) -> bool
- > structure D :
  {datatype u =
     ((u' (unit -> unit)),{con C : (unit -> unit) -> (u' (unit -> unit))}),
   con C : (unit -> unit) -> (u' (unit -> unit))}
- ! Toplevel input:
! val fail = op = : D.u * D.u -> bool;
!            ^^^^
! Type clash: expression of type
!   ''a * ''a -> bool
! cannot have type
!   (u' (unit -> unit)) * (u' (unit -> unit)) -> bool
- > New type names: =u''
  functor H :
  !=t.
   {type t = t}->
       {datatype u = ((u'' t),{con C : t -> (u'' t)}), con C : t -> (u'' t)}
- > structure E :
  {datatype u = ((u'' unit),{con C : unit -> (u'' unit)}),
   con C : unit -> (u'' unit)}
- > val ok = fn : (u'' unit) * (u'' unit) -> bool
- > New type names: =u'''
  functor I :
  !s =t.
   {type s = s, type t = t}->
       {datatype u = ((u''' s t),{con C : t -> (u''' s t)}),
        con C : t -> (u''' s t)}
- > structure F :
  {datatype u = ((u''' unit unit),{con C : unit -> (u''' unit unit)}),
   con C : unit -> (u''' unit unit)}
- > val ok = fn : (u''' unit unit) * (u''' unit unit) -> bool
- > structure G :
  {datatype u =
     ((u''' (unit -> unit) unit),{con C : unit -> (u''' (unit -> unit) unit)}),
   con C : unit -> (u''' (unit -> unit) unit)}
- > val ok = fn : (u''' (unit -> unit) unit) * (u''' (unit -> unit) unit) -> bool
- > functor ok :
  !=u''''.
   (!t.{type t = t'}->{type u = (u'''' t')})->
       !t.{type t = t}->{type u = (u'''' t)}
- > functor ok :
  !=u''''.
   (!t.{type t = t'}->{type u = (u'''' t')})->
       !=t.{type t = t}->{type u = (u'''' t)}
- > functor ok :
  !=u''''.
   (!t.{type t = t'}->{type u = (u'''' t')})->
       !t.{type t = t}->{type u = (u'''' t)}
- > functor ok :
  !=u''''.
   (!t.{type t = t'}->{type u = (u'''' t')})->
       !=t.{type t = t}->{type u = (u'''' t)}
- ! Toplevel input:
!     op F:functor X:sig type t end -> sig type u end;
!     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Equality type mismatch: type constructor t of the domain is specified as admitting equality in the module
!   type t = t
! but its declaration does not admit equality in the signature
!   type t = t'
- ! Toplevel input:
!     op F:functor X:sig eqtype t end -> sig eqtype u end;
!     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Equality type mismatch: type constructor u of the range is specified as admitting equality in the signature
!   type u = (u'''' t)
! but its declaration does not admit equality in the module
!   type u = (u''''' t)
- 
Moscow ML version 1.44cvr3 (internal release) (16th January 2000)
Enter `quit();' to quit.
- > val 'a ok = fn : 'a -> 'a
- > val ('a, 'b) ok = fn : ('a -> 'b) -> 'a -> 'b
- ! Toplevel input:
! type fail = 'a -> 'b;
! ^^^^^^^^^^^^^^^^^^^^
! Unguarded type variables at the top-level
- > val 'a ok = fn : 'a -> 'a
- > val 'b ok = fn : 'b -> int
- ! Toplevel input:
! val fail = fn x:'b => let datatype d = C type t = 'b * d in (x,C): t end;
!                                                                ^
! Type clash: expression of type
!   d
! cannot have type
!   'a
! because of a scope violation:
! the type constructor d is a parameter 
! that is declared within the scope of 'a
- > val 'a ok = fn : 'a -> 'a
- > New type names: =t
  structure Ok : {datatype t = (t,{con c : int -> t}), con c : int -> t}
- > New type names: t', t''
  structure Ok' :
  {datatype t = (t',{con c : (unit -> unit) -> t'}),
   con c : (unit -> unit) -> t'}
  structure Ok :
  {datatype t = (t'',{con c : (bool -> bool) -> t''}),
   con c : (bool -> bool) -> t''}
- > val it = () : unit
- > New type names: t''', t''''
  structure Ok' :
  {datatype t = (t''',{con c : (unit -> unit) -> t'''}),
   con c : (unit -> unit) -> t'''}
  structure Ok :
  {datatype t = (t'''',{con c : (bool -> bool) -> t''''}),
   con c : (bool -> bool) -> t''''}
- > val it = () : unit
- > val 'a ok = fn : 'a -> 'a
- > val 'a ok = fn : 'a -> [{val x : 'a}]
- > signature Fail = {val 'a x : 'a -> 'a}
- > val 'a ok = fn : 'a -> [{val x : 'a}]
- ! Toplevel input:
!     in [structure struct val x = x end as S ]
!        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the structure does not match the signature ...
! Scheme mismatch: value identifier x is specified with type scheme 
!   val 'a' x : 'a'
! in the signature
! but its declaration has the unrelated type scheme 
!   val x : 'a
! in the structure
! The declared type scheme should be at least as general as the specified type scheme
- ! Toplevel input:
!     in [structure struct val x = x end as S ]
!        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the structure does not match the signature ...
! Scheme mismatch: value identifier x is specified with type scheme 
!   val 'b x : 'b
! in the signature
! but its declaration has the unrelated type scheme 
!   val x : 'a
! in the structure
! The declared type scheme should be at least as general as the specified type scheme
- > val 'a ok = fn : 'a -> [{val x : 'a -> 'a}]
- > val 'a ok = fn : 'a -> [{val 'a' x : 'a' -> 'a'}]
- > val 'a ok = fn : 'a -> [{val 'b x : 'b -> 'b}]
- ! Toplevel input:
! ....(functor(X:sig type t end)=>struct datatype u = C of X.t end)
!     :functor X:sig type t end -> sig type u end.
! Signature mismatch: the module does not match the signature ...
! Scope Violation: type constructor u of the range has specification:
!   type u = (u t''''')
! in the signature
! but is implemented by the declaration: 
!   datatype u = (u',{con C : t''''' -> u'})
! in the module
! The declaration violates the specification because 
! the type constructor u' is a parameter 
! that is declared within the scope of u.
- 
Moscow ML version 1.44cvr3 (internal release) (16th January 2000)
Enter `quit();' to quit.
- > New type names: =v, =u, =t
  val matchsuc = "OK" : string
- 
Moscow ML version 1.44cvr3 (internal release) (16th January 2000)
Enter `quit();' to quit.
- ! Toplevel input:
! structure X = struct open General end: sig val + : (int * int) -> int end;
!               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Scheme mismatch: value identifier + is specified with type scheme 
!   val + : int * int -> int
! in the signature
! but its declaration has the unrelated type scheme 
!   val + : num * num -> num 
! in the module
! The declared type scheme should be at least as general as the specified type scheme
- ! Toplevel input:
! structure X = struct val x = fn 1 => Div end : sig exception x of int end;
!               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Status mismatch: identifier x is specified as an exception in the signature
!   exn x : int -> exn
! but declared as an ordinary value in the module
!   val x : int -> exn
- ! Toplevel input:
! structure X = struct val x = fn y => y end : sig prim_val  x : 'a ->'a = 1 "identity" end;
!               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Status mismatch: identifier x is specified as a primitive in the signature
!   val 'a x : 'a -> 'a
! but declared as an ordinary value in the module
!   val 'a x : 'a -> 'a
- > exn e = e : exn
- > structure X : {exn e : exn}
- ! Toplevel input:
! structure X = struct val x = fn 1 => 1 end : sig val x : 'a -> 'a end;
!               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Scheme mismatch: value identifier x is specified with type scheme 
!   val 'a x : 'a -> 'a
! in the signature
! but its declaration has the unrelated type scheme 
!   val x : int -> int
! in the module
! The declared type scheme should be at least as general as the specified type scheme
- ! Toplevel input:
! structure X = struct val x = fn 1 => Div end : sig exception x of int end;
!               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Status mismatch: identifier x is specified as an exception in the signature
!   exn x : int -> exn
! but declared as an ordinary value in the module
!   val x : int -> exn
- ! Toplevel input:
! structure X = struct val x = fn y => y end : sig prim_val  x : 'a ->'a = 1 "identity" end;
!               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Status mismatch: identifier x is specified as a primitive in the signature
!   val 'a x : 'a -> 'a
! but declared as an ordinary value in the module
!   val 'a x : 'a -> 'a
- ! Toplevel input:
! structure X = struct datatype t = C of int end : sig datatype t = C of bool end;
!               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Scheme mismatch: value identifier C is specified with type scheme 
!   con C : bool -> t
! in the signature
! but its declaration has the unrelated type scheme 
!   con C : int -> t
! in the module
! The declared type scheme should be at least as general as the specified type scheme
- ! Toplevel input:
! signature S = sig type t end where type 'a t = int;
!                                    ^^^^^^^^^^^^^^^
! Illegal where constraint: the type constructor t cannot be constrained in this way because ...
! Arity mismatch: type constructor t is specified with arity 0 in the signature
!   type t = t
! but declared with arity 1 in the constraint
!   type 'a t = int
! The arities should agree
- ! Toplevel input:
! signature S = sig structure X : sig type t end end where type 'a X.t = int;
!                                                          ^^^^^^^^^^^^^^^^^
! Illegal where constraint: the type constructor X.t cannot be constrained in this way because ...
! Arity mismatch: type constructor X.t is specified with arity 0 in the signature
!   type t = t
! but declared with arity 1 in the constraint
!   type 'a t = int
! The arities should agree
- ! Toplevel input:
! signature S = sig structure Y : sig structure X : sig type t end end end where type 'a Y.X.t = int;
!                                                                                ^^^^^^^^^^^^^^^^^^^
! Illegal where constraint: the type constructor Y.X.t cannot be constrained in this way because ...
! Arity mismatch: type constructor Y.X.t is specified with arity 0 in the signature
!   type t = t
! but declared with arity 1 in the constraint
!   type 'a t = int
! The arities should agree
- ! Toplevel input:
! structure X = struct end:functor(X:sig end)->sig end;
!               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Module mismatch: The signature specifies a functor
! but the module is a structure
- ! Toplevel input:
! functor X = (functor(X:sig end)=>struct end) : sig end;
!             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Module mismatch: The signature specifies a structure
! but the module is a functor
- ! Toplevel input:
! functor X = (functor(X:sig end)=>struct end): functor(X:sig end)->functor(X:sig end)->sig end;
!             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Module mismatch: the range is specified as a functor in the signature
! but declared as a structure in the module
- ! Toplevel input:
! functor X = (functor(X:sig end)=>functor(X:sig end)=>struct end): functor(X:sig end)->sig end;
!             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Module mismatch: the range is specified as a structure in the signature
! but declared as a functor in the module
- ! Toplevel input:
! functor X = (functor(X:functor(X:sig end)->sig end)=>struct end): functor(X:sig end)->sig end;
!             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Module mismatch: the domain is specified as a functor in the module
! but declared as a structure in the signature
- ! Toplevel input:
! functor X = (functor(X:sig end)=>struct end): functor(F:functor(X:sig end)->sig end)->sig end;
!             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Module mismatch: the domain is specified as a structure in the module
! but declared as a functor in the signature
- > signature G = {type t = unit}
- > signature L = {}
- ! Toplevel input:
!   L:G;
!   ^^^
! Signature mismatch: the module does not match the signature ...
! Missing declaration: type t is specified in the signature as 
!   type t = unit
! but not declared in the module
- ! Toplevel input:
!   LL:functor(L:L)->G;
!   ^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Missing declaration: type t of the range is specified in the signature as 
!   type t = unit
! but not declared in the module
- ! Toplevel input:
!   GL:functor(L:L)->L;
!   ^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Missing declaration: type t of the domain is specified in the module as 
!   type t = unit
! but not declared in the signature
- ! Toplevel input:
!   YL:sig structure Y: G end;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Missing declaration: type Y.t is specified in the signature as 
!   type t = unit
! but not declared in the module
- ! Toplevel input:
!   L_YL:functor(L:L)->sig structure Y: G end;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Missing declaration: type Y.t of the range is specified in the signature as 
!   type t = unit
! but not declared in the module
- ! Toplevel input:
!   YG_L:functor(YL:sig structure Y: L end)->L;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Missing declaration: type Y.t of the domain is specified in the module as 
!   type t = unit
! but not declared in the signature
- ! Toplevel input:
!   L_YG_L:functor(L:L)->functor(YL:sig structure Y:L end)->L;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Missing declaration: type Y.t of the domain of the range is specified in the module as 
!   type t = unit
! but not declared in the signature
- ! Toplevel input:
!   FLYGL:sig functor F: functor(L:L)->functor(YL:sig structure Y:L end)->L end;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Missing declaration: type Y.t of the domain of the range of F is specified in the module as 
!   type t = unit
! but not declared in the signature
- > signature G = {val x : unit}
- > signature L = {}
- ! Toplevel input:
!   L:G;
!   ^^^
! Signature mismatch: the module does not match the signature ...
! Missing declaration: value x is specified in the signature as 
!   val x : unit
! but not declared in the module
- ! Toplevel input:
!   LL:functor(L:L)->G;
!   ^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Missing declaration: value x of the range is specified in the signature as 
!   val x : unit
! but not declared in the module
- ! Toplevel input:
!   GL:functor(L:L)->L;
!   ^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Missing declaration: value x of the domain is specified in the module as 
!   val x : unit
! but not declared in the signature
- ! Toplevel input:
!   YL:sig structure Y: G end;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Missing declaration: value Y.x is specified in the signature as 
!   val x : unit
! but not declared in the module
- ! Toplevel input:
!   L_YL:functor(L:L)->sig structure Y: G end;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Missing declaration: value Y.x of the range is specified in the signature as 
!   val x : unit
! but not declared in the module
- ! Toplevel input:
!   YG_L:functor(YL:sig structure Y: L end)->L;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Missing declaration: value Y.x of the domain is specified in the module as 
!   val x : unit
! but not declared in the signature
- ! Toplevel input:
!   L_YG_L:functor(L:L)->functor(YL:sig structure Y:L end)->L;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Missing declaration: value Y.x of the domain of the range is specified in the module as 
!   val x : unit
! but not declared in the signature
- ! Toplevel input:
!   FLYGL:sig functor F: functor(L:L)->functor(YL:sig structure Y:L end)->L end;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Missing declaration: value Y.x of the domain of the range of F is specified in the module as 
!   val x : unit
! but not declared in the signature
- > signature G = {structure X : {}}
- > signature L = {}
- ! Toplevel input:
!   L:G;
!   ^^^
! Signature mismatch: the module does not match the signature ...
! Missing declaration: structure X is specified in the signature as 
!   structure X : {}
! but not declared in the module
- ! Toplevel input:
!   LL:functor(L:L)->G;
!   ^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Missing declaration: structure X of the range is specified in the signature as 
!   structure X : {}
! but not declared in the module
- ! Toplevel input:
!   GL:functor(L:L)->L;
!   ^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Missing declaration: structure X of the domain is specified in the module as 
!   structure X : {}
! but not declared in the signature
- ! Toplevel input:
!   YL:sig structure Y: G end;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Missing declaration: structure Y.X is specified in the signature as 
!   structure X : {}
! but not declared in the module
- ! Toplevel input:
!   L_YL:functor(L:L)->sig structure Y: G end;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Missing declaration: structure Y.X of the range is specified in the signature as 
!   structure X : {}
! but not declared in the module
- ! Toplevel input:
!   YG_L:functor(YL:sig structure Y: L end)->L;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Missing declaration: structure Y.X of the domain is specified in the module as 
!   structure X : {}
! but not declared in the signature
- ! Toplevel input:
!   L_YG_L:functor(L:L)->functor(YL:sig structure Y:L end)->L;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Missing declaration: structure Y.X of the domain of the range is specified in the module as 
!   structure X : {}
! but not declared in the signature
- ! Toplevel input:
!   FLYGL:sig functor F: functor(L:L)->functor(YL:sig structure Y:L end)->L end;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Missing declaration: structure Y.X of the domain of the range of F is specified in the module as 
!   structure X : {}
! but not declared in the signature
- > signature G = {functor F : {}->{}}
- > signature L = {}
- ! Toplevel input:
!   L:G;
!   ^^^
! Signature mismatch: the module does not match the signature ...
! Missing declaration: functor F is specified in the signature as 
!   functor F : {}->{}
! but not declared in the module
- ! Toplevel input:
!   LL:functor(L:L)->G;
!   ^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Missing declaration: functor F of the range is specified in the signature as 
!   functor F : {}->{}
! but not declared in the module
- ! Toplevel input:
!   GL:functor(L:L)->L;
!   ^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Missing declaration: functor F of the domain is specified in the module as 
!   functor F : {}->{}
! but not declared in the signature
- ! Toplevel input:
!   YL:sig structure Y: G end;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Missing declaration: functor Y.F is specified in the signature as 
!   functor F : {}->{}
! but not declared in the module
- ! Toplevel input:
!   L_YL:functor(L:L)->sig structure Y: G end;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Missing declaration: functor Y.F of the range is specified in the signature as 
!   functor F : {}->{}
! but not declared in the module
- ! Toplevel input:
!   YG_L:functor(YL:sig structure Y: L end)->L;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Missing declaration: functor Y.F of the domain is specified in the module as 
!   functor F : {}->{}
! but not declared in the signature
- ! Toplevel input:
!   L_YG_L:functor(L:L)->functor(YL:sig structure Y:L end)->L;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Missing declaration: functor Y.F of the domain of the range is specified in the module as 
!   functor F : {}->{}
! but not declared in the signature
- ! Toplevel input:
!   FLYGL:sig functor F: functor(L:L)->functor(YL:sig structure Y:L end)->L end;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Missing declaration: functor Y.F of the domain of the range of F is specified in the module as 
!   functor F : {}->{}
! but not declared in the signature
- > signature G = {val 'a x : 'a -> 'a}
- > signature L = {val x : int -> int}
- ! Toplevel input:
!   L:G;
!   ^^^
! Signature mismatch: the module does not match the signature ...
! Scheme mismatch: value identifier x is specified with type scheme 
!   val 'a x : 'a -> 'a
! in the signature
! but its declaration has the unrelated type scheme 
!   val x : int -> int
! in the module
! The declared type scheme should be at least as general as the specified type scheme
- ! Toplevel input:
!   LL:functor(L:L)->G;
!   ^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Scheme mismatch: value identifier x of the range is specified with type scheme 
!   val 'a x : 'a -> 'a
! in the signature
! but its declaration has the unrelated type scheme 
!   val x : int -> int
! in the module
! The declared type scheme should be at least as general as the specified type scheme
- ! Toplevel input:
!   GL:functor(L:L)->L;
!   ^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Scheme mismatch: value identifier x of the domain is specified with type scheme 
!   val 'a x : 'a -> 'a
! in the module
! but its declaration has the unrelated type scheme 
!   val x : int -> int
! in the signature
! The declared type scheme should be at least as general as the specified type scheme
- ! Toplevel input:
!   YL:sig structure Y: G end;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Scheme mismatch: value identifier Y.x is specified with type scheme 
!   val 'a x : 'a -> 'a
! in the signature
! but its declaration has the unrelated type scheme 
!   val x : int -> int
! in the module
! The declared type scheme should be at least as general as the specified type scheme
- ! Toplevel input:
!   L_YL:functor(L:L)->sig structure Y: G end;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Scheme mismatch: value identifier Y.x of the range is specified with type scheme 
!   val 'a x : 'a -> 'a
! in the signature
! but its declaration has the unrelated type scheme 
!   val x : int -> int
! in the module
! The declared type scheme should be at least as general as the specified type scheme
- ! Toplevel input:
!   YG_L:functor(YL:sig structure Y: L end)->L;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Scheme mismatch: value identifier Y.x of the domain is specified with type scheme 
!   val 'a x : 'a -> 'a
! in the module
! but its declaration has the unrelated type scheme 
!   val x : int -> int
! in the signature
! The declared type scheme should be at least as general as the specified type scheme
- ! Toplevel input:
!   L_YG_L:functor(L:L)->functor(YL:sig structure Y:L end)->L;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Scheme mismatch: value identifier Y.x of the domain of the range is specified with type scheme 
!   val 'a x : 'a -> 'a
! in the module
! but its declaration has the unrelated type scheme 
!   val x : int -> int
! in the signature
! The declared type scheme should be at least as general as the specified type scheme
- ! Toplevel input:
!   FLYGL:sig functor F: functor(L:L)->functor(YL:sig structure Y:L end)->L end;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Scheme mismatch: value identifier Y.x of the domain of the range of F is specified with type scheme 
!   val 'a x : 'a -> 'a
! in the module
! but its declaration has the unrelated type scheme 
!   val x : int -> int
! in the signature
! The declared type scheme should be at least as general as the specified type scheme
- ! Toplevel input:
! 	  L:G;
! 	  ^^^
! Signature mismatch: the module does not match the signature ...
! Scheme mismatch: value identifier x is specified with type scheme 
!   val 'a x : ('a -> 'a) -> 'a -> 'a
! in the signature
! but its declaration has the unrelated type scheme 
!   val 'a x : ('a -> 'a) -> 'b -> 'b
! in the module
! The declared type scheme should be at least as general as the specified type scheme
- ! Toplevel input:
! 	  LL:functor(L:L)->G;
! 	  ^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Scheme mismatch: value identifier x of the range is specified with type scheme 
!   val 'a x : ('a -> 'a) -> 'a -> 'a
! in the signature
! but its declaration has the unrelated type scheme 
!   val 'a x : ('a -> 'a) -> 'b -> 'b
! in the module
! The declared type scheme should be at least as general as the specified type scheme
- ! Toplevel input:
! 	  GL:functor(L:L)->L;
! 	  ^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Scheme mismatch: value identifier x of the domain is specified with type scheme 
!   val 'a x : ('a -> 'a) -> 'a -> 'a
! in the module
! but its declaration has the unrelated type scheme 
!   val 'a x : ('a -> 'a) -> 'b -> 'b
! in the signature
! The declared type scheme should be at least as general as the specified type scheme
- ! Toplevel input:
! 	  YL:sig structure Y: G end;
! 	  ^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Scheme mismatch: value identifier Y.x is specified with type scheme 
!   val 'a x : ('a -> 'a) -> 'a -> 'a
! in the signature
! but its declaration has the unrelated type scheme 
!   val 'a x : ('a -> 'a) -> 'b -> 'b
! in the module
! The declared type scheme should be at least as general as the specified type scheme
- ! Toplevel input:
! 	  L_YL:functor(L:L)->sig structure Y: G end;
! 	  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Scheme mismatch: value identifier Y.x of the range is specified with type scheme 
!   val 'a x : ('a -> 'a) -> 'a -> 'a
! in the signature
! but its declaration has the unrelated type scheme 
!   val 'a x : ('a -> 'a) -> 'b -> 'b
! in the module
! The declared type scheme should be at least as general as the specified type scheme
- ! Toplevel input:
! 	  YG_L:functor(YL:sig structure Y: L end)->L;
! 	  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Scheme mismatch: value identifier Y.x of the domain is specified with type scheme 
!   val 'a x : ('a -> 'a) -> 'a -> 'a
! in the module
! but its declaration has the unrelated type scheme 
!   val 'a x : ('a -> 'a) -> 'b -> 'b
! in the signature
! The declared type scheme should be at least as general as the specified type scheme
- ! Toplevel input:
! 	  L_YG_L:functor(L:L)->functor(YL:sig structure Y:L end)->L;
! 	  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Scheme mismatch: value identifier Y.x of the domain of the range is specified with type scheme 
!   val 'a x : ('a -> 'a) -> 'a -> 'a
! in the module
! but its declaration has the unrelated type scheme 
!   val 'a x : ('a -> 'a) -> 'b -> 'b
! in the signature
! The declared type scheme should be at least as general as the specified type scheme
- ! Toplevel input:
! 	  FLYGL:sig functor F: functor(L:L)->functor(YL:sig structure Y:L end)->L end;
! 	  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Scheme mismatch: value identifier Y.x of the domain of the range of F is specified with type scheme 
!   val 'a x : ('a -> 'a) -> 'a -> 'a
! in the module
! but its declaration has the unrelated type scheme 
!   val 'a x : ('a -> 'a) -> 'b -> 'b
! in the signature
! The declared type scheme should be at least as general as the specified type scheme
- > signature G = {exn x : exn}
- > signature L = {val x : exn}
- ! Toplevel input:
!   L:G;
!   ^^^
! Signature mismatch: the module does not match the signature ...
! Status mismatch: identifier x is specified as an exception in the signature
!   exn x : exn
! but declared as an ordinary value in the module
!   val x : exn
- ! Toplevel input:
!   LL:functor(L:L)->G;
!   ^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Status mismatch: identifier x of the range is specified as an exception in the signature
!   exn x : exn
! but declared as an ordinary value in the module
!   val x : exn
- ! Toplevel input:
!   GL:functor(L:L)->L;
!   ^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Status mismatch: identifier x of the domain is specified as an exception in the module
!   exn x : exn
! but declared as an ordinary value in the signature
!   val x : exn
- ! Toplevel input:
!   YL:sig structure Y: G end;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Status mismatch: identifier Y.x is specified as an exception in the signature
!   exn x : exn
! but declared as an ordinary value in the module
!   val x : exn
- ! Toplevel input:
!   L_YL:functor(L:L)->sig structure Y: G end;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Status mismatch: identifier Y.x of the range is specified as an exception in the signature
!   exn x : exn
! but declared as an ordinary value in the module
!   val x : exn
- ! Toplevel input:
!   YG_L:functor(YL:sig structure Y: L end)->L;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Status mismatch: identifier Y.x of the domain is specified as an exception in the module
!   exn x : exn
! but declared as an ordinary value in the signature
!   val x : exn
- ! Toplevel input:
!   L_YG_L:functor(L:L)->functor(YL:sig structure Y:L end)->L;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Status mismatch: identifier Y.x of the domain of the range is specified as an exception in the module
!   exn x : exn
! but declared as an ordinary value in the signature
!   val x : exn
- ! Toplevel input:
!   FLYGL:sig functor F: functor(L:L)->functor(YL:sig structure Y:L end)->L end;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Status mismatch: identifier Y.x of the domain of the range of F is specified as an exception in the module
!   exn x : exn
! but declared as an ordinary value in the signature
!   val x : exn
- > signature G = /\=t.{datatype t = (t,{con C : int -> t}), con C : int -> t}
- > signature L = /\=t.{datatype t = (t,{con D : int -> t}), con D : int -> t}
- ! Toplevel input:
!   L:G;
!   ^^^
! Signature mismatch: the module does not match the signature ...
! Datatype mismatch: type constructor t is specified as the datatype
!   datatype t = (t,{con C : int -> t})
! in the signature
! but declared as the different datatype
!   datatype t = (t,{con D : int -> t})
! in the module
! The datatypes should agree on the names and the order of value constructors
- ! Toplevel input:
!   LL:functor(L:L)->G;
!   ^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Datatype mismatch: type constructor t of the range is specified as the datatype
!   datatype t = (t,{con C : int -> t})
! in the signature
! but declared as the different datatype
!   datatype t = (t,{con D : int -> t})
! in the module
! The datatypes should agree on the names and the order of value constructors
- ! Toplevel input:
!   GL:functor(L:L)->L;
!   ^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Datatype mismatch: type constructor t of the domain is specified as the datatype
!   datatype t = (t,{con C : int -> t})
! in the module
! but declared as the different datatype
!   datatype t = (t,{con D : int -> t})
! in the signature
! The datatypes should agree on the names and the order of value constructors
- ! Toplevel input:
!   YL:sig structure Y: G end;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Datatype mismatch: type constructor Y.t is specified as the datatype
!   datatype t = (t,{con C : int -> t})
! in the signature
! but declared as the different datatype
!   datatype t = (t,{con D : int -> t})
! in the module
! The datatypes should agree on the names and the order of value constructors
- ! Toplevel input:
!   L_YL:functor(L:L)->sig structure Y: G end;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Datatype mismatch: type constructor Y.t of the range is specified as the datatype
!   datatype t = (t,{con C : int -> t})
! in the signature
! but declared as the different datatype
!   datatype t = (t,{con D : int -> t})
! in the module
! The datatypes should agree on the names and the order of value constructors
- ! Toplevel input:
!   YG_L:functor(YL:sig structure Y: L end)->L;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Datatype mismatch: type constructor Y.t of the domain is specified as the datatype
!   datatype t = (t,{con C : int -> t})
! in the module
! but declared as the different datatype
!   datatype t = (t,{con D : int -> t})
! in the signature
! The datatypes should agree on the names and the order of value constructors
- ! Toplevel input:
!   L_YG_L:functor(L:L)->functor(YL:sig structure Y:L end)->L;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Datatype mismatch: type constructor Y.t of the domain of the range is specified as the datatype
!   datatype t = (t,{con C : int -> t})
! in the module
! but declared as the different datatype
!   datatype t = (t,{con D : int -> t})
! in the signature
! The datatypes should agree on the names and the order of value constructors
- ! Toplevel input:
!   FLYGL:sig functor F: functor(L:L)->functor(YL:sig structure Y:L end)->L end;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Datatype mismatch: type constructor Y.t of the domain of the range of F is specified as the datatype
!   datatype t = (t,{con C : int -> t})
! in the module
! but declared as the different datatype
!   datatype t = (t,{con D : int -> t})
! in the signature
! The datatypes should agree on the names and the order of value constructors
- > signature G = {type t = unit}
- > signature L = {type 'a t = unit}
- ! Toplevel input:
!   L:G;
!   ^^^
! Signature mismatch: the module does not match the signature ...
! Arity mismatch: type constructor t is specified with arity 0 in the signature
!   type t = unit
! but declared with arity 1 in the module
!   type 'a t = unit
! The arities should agree
- ! Toplevel input:
!   LL:functor(L:L)->G;
!   ^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Arity mismatch: type constructor t of the range is specified with arity 0 in the signature
!   type t = unit
! but declared with arity 1 in the module
!   type 'a t = unit
! The arities should agree
- ! Toplevel input:
!   GL:functor(L:L)->L;
!   ^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Arity mismatch: type constructor t of the domain is specified with arity 0 in the module
!   type t = unit
! but declared with arity 1 in the signature
!   type 'a t = unit
! The arities should agree
- ! Toplevel input:
!   YL:sig structure Y: G end;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Arity mismatch: type constructor Y.t is specified with arity 0 in the signature
!   type t = unit
! but declared with arity 1 in the module
!   type 'a t = unit
! The arities should agree
- ! Toplevel input:
!   L_YL:functor(L:L)->sig structure Y: G end;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Arity mismatch: type constructor Y.t of the range is specified with arity 0 in the signature
!   type t = unit
! but declared with arity 1 in the module
!   type 'a t = unit
! The arities should agree
- ! Toplevel input:
!   YG_L:functor(YL:sig structure Y: L end)->L;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Arity mismatch: type constructor Y.t of the domain is specified with arity 0 in the module
!   type t = unit
! but declared with arity 1 in the signature
!   type 'a t = unit
! The arities should agree
- ! Toplevel input:
!   L_YG_L:functor(L:L)->functor(YL:sig structure Y:L end)->L;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Arity mismatch: type constructor Y.t of the domain of the range is specified with arity 0 in the module
!   type t = unit
! but declared with arity 1 in the signature
!   type 'a t = unit
! The arities should agree
- ! Toplevel input:
!   FLYGL:sig functor F: functor(L:L)->functor(YL:sig structure Y:L end)->L end;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Arity mismatch: type constructor Y.t of the domain of the range of F is specified with arity 0 in the module
!   type t = unit
! but declared with arity 1 in the signature
!   type 'a t = unit
! The arities should agree
- > signature G = {type 'a myref = 'a ref}
- > signature L = {type 'a myref = 'a}
- ! Toplevel input:
!   L:G;
!   ^^^
! Signature mismatch: the module does not match the signature ...
! Equality type mismatch: type constructor myref is specified as a `prim_EQtype' in the signature
!   type 'a myref = 'a ref
! but is not declared as a `prim_EQtype' in the module
!   type 'a myref = 'a
- ! Toplevel input:
!   LL:functor(L:L)->G;
!   ^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Equality type mismatch: type constructor myref of the range is specified as a `prim_EQtype' in the signature
!   type 'a myref = 'a ref
! but is not declared as a `prim_EQtype' in the module
!   type 'a myref = 'a
- ! Toplevel input:
!   GL:functor(L:L)->L;
!   ^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Equality type mismatch: type constructor myref of the domain is specified as a `prim_EQtype' in the module
!   type 'a myref = 'a ref
! but is not declared as a `prim_EQtype' in the signature
!   type 'a myref = 'a
- ! Toplevel input:
!   YL:sig structure Y: G end;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Equality type mismatch: type constructor Y.myref is specified as a `prim_EQtype' in the signature
!   type 'a myref = 'a ref
! but is not declared as a `prim_EQtype' in the module
!   type 'a myref = 'a
- ! Toplevel input:
!   L_YL:functor(L:L)->sig structure Y: G end;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Equality type mismatch: type constructor Y.myref of the range is specified as a `prim_EQtype' in the signature
!   type 'a myref = 'a ref
! but is not declared as a `prim_EQtype' in the module
!   type 'a myref = 'a
- ! Toplevel input:
!   YG_L:functor(YL:sig structure Y: L end)->L;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Equality type mismatch: type constructor Y.myref of the domain is specified as a `prim_EQtype' in the module
!   type 'a myref = 'a ref
! but is not declared as a `prim_EQtype' in the signature
!   type 'a myref = 'a
- ! Toplevel input:
!   L_YG_L:functor(L:L)->functor(YL:sig structure Y:L end)->L;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Equality type mismatch: type constructor Y.myref of the domain of the range is specified as a `prim_EQtype' in the module
!   type 'a myref = 'a ref
! but is not declared as a `prim_EQtype' in the signature
!   type 'a myref = 'a
- ! Toplevel input:
!   FLYGL:sig functor F: functor(L:L)->functor(YL:sig structure Y:L end)->L end;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Equality type mismatch: type constructor Y.myref of the domain of the range of F is specified as a `prim_EQtype' in the module
!   type 'a myref = 'a ref
! but is not declared as a `prim_EQtype' in the signature
!   type 'a myref = 'a
- > signature G = /\=t.{type t = t}
- > signature L = /\t.{type t = t}
- ! Toplevel input:
!   L:G;
!   ^^^
! Signature mismatch: the module does not match the signature ...
! Equality type mismatch: type constructor t is specified as a `prim_EQtype' in the signature
!   type t = t
! but is not declared as a `prim_EQtype' in the module
!   type t = t'
- ! Toplevel input:
!   LL:functor(L:L)->G;
!   ^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Equality type mismatch: type constructor t of the range is specified as a `prim_EQtype' in the signature
!   type t = t
! but is not declared as a `prim_EQtype' in the module
!   type t = t'
- ! Toplevel input:
!   GL:functor(L:L)->L;
!   ^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Equality type mismatch: type constructor t of the domain is specified as a `prim_EQtype' in the module
!   type t = t
! but is not declared as a `prim_EQtype' in the signature
!   type t = t'
- ! Toplevel input:
!   YL:sig structure Y: G end;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Equality type mismatch: type constructor Y.t is specified as a `prim_EQtype' in the signature
!   type t = t
! but is not declared as a `prim_EQtype' in the module
!   type t = t'
- ! Toplevel input:
!   L_YL:functor(L:L)->sig structure Y: G end;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Equality type mismatch: type constructor Y.t of the range is specified as a `prim_EQtype' in the signature
!   type t = t
! but is not declared as a `prim_EQtype' in the module
!   type t = t'
- ! Toplevel input:
!   YG_L:functor(YL:sig structure Y: L end)->L;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Equality type mismatch: type constructor Y.t of the domain is specified as a `prim_EQtype' in the module
!   type t = t
! but is not declared as a `prim_EQtype' in the signature
!   type t = t'
- ! Toplevel input:
!   L_YG_L:functor(L:L)->functor(YL:sig structure Y:L end)->L;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Equality type mismatch: type constructor Y.t of the domain of the range is specified as a `prim_EQtype' in the module
!   type t = t
! but is not declared as a `prim_EQtype' in the signature
!   type t = t'
- ! Toplevel input:
!   FLYGL:sig functor F: functor(L:L)->functor(YL:sig structure Y:L end)->L end;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Equality type mismatch: type constructor Y.t of the domain of the range of F is specified as a `prim_EQtype' in the module
!   type t = t
! but is not declared as a `prim_EQtype' in the signature
!   type t = t'
- > signature G = /\=t.{type t = t}
- > signature L = {type t = unit -> unit}
- ! Toplevel input:
!   L:G;
!   ^^^
! Signature mismatch: the module does not match the signature ...
! Equality type mismatch: type constructor t is specified as admitting equality in the signature
!   type t = t
! but its declaration does not admit equality in the module
!   type t = unit -> unit
- ! Toplevel input:
!   LL:functor(L:L)->G;
!   ^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Equality type mismatch: type constructor t of the range is specified as admitting equality in the signature
!   type t = t
! but its declaration does not admit equality in the module
!   type t = unit -> unit
- ! Toplevel input:
!   GL:functor(L:L)->L;
!   ^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Equality type mismatch: type constructor t of the domain is specified as admitting equality in the module
!   type t = t
! but its declaration does not admit equality in the signature
!   type t = unit -> unit
- ! Toplevel input:
!   YL:sig structure Y: G end;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Equality type mismatch: type constructor Y.t is specified as admitting equality in the signature
!   type t = t
! but its declaration does not admit equality in the module
!   type t = unit -> unit
- ! Toplevel input:
!   L_YL:functor(L:L)->sig structure Y: G end;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Equality type mismatch: type constructor Y.t of the range is specified as admitting equality in the signature
!   type t = t
! but its declaration does not admit equality in the module
!   type t = unit -> unit
- ! Toplevel input:
!   YG_L:functor(YL:sig structure Y: L end)->L;<EOF>
!   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Equality type mismatch: type constructor Y.t of the domain is specified as admitting equality in the module
!   type t = t
! but its declaration does not admit equality in the signature
!   type t = unit -> unit
- ! Toplevel input:
!   L_YG_L:functor(L:L)->functor(YL:sig structure Y:L end)->L;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Equality type mismatch: type constructor Y.t of the domain of the range is specified as admitting equality in the module
!   type t = t
! but its declaration does not admit equality in the signature
!   type t = unit -> unit
- ! Toplevel input:
!   FLYGL:sig functor F: functor(L:L)->functor(YL:sig structure Y:L end)->L end;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Equality type mismatch: type constructor Y.t of the domain of the range of F is specified as admitting equality in the module
!   type t = t
! but its declaration does not admit equality in the signature
!   type t = unit -> unit
- > signature G = {type t = unit}
- > signature L = {type t = unit -> unit}
- ! Toplevel input:
!   L:G;
!   ^^^
! Signature mismatch: the module does not match the signature ...
! Equality type mismatch: type constructor t is specified as admitting equality in the signature
!   type t = unit
! but its declaration does not admit equality in the module
!   type t = unit -> unit
- ! Toplevel input:
!   LL:functor(L:L)->G;
!   ^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Equality type mismatch: type constructor t of the range is specified as admitting equality in the signature
!   type t = unit
! but its declaration does not admit equality in the module
!   type t = unit -> unit
- ! Toplevel input:
!   GL:functor(L:L)->L;
!   ^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Equality type mismatch: type constructor t of the domain is specified as admitting equality in the module
!   type t = unit
! but its declaration does not admit equality in the signature
!   type t = unit -> unit
- ! Toplevel input:
!   YL:sig structure Y: G end;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Equality type mismatch: type constructor Y.t is specified as admitting equality in the signature
!   type t = unit
! but its declaration does not admit equality in the module
!   type t = unit -> unit
- ! Toplevel input:
!   L_YL:functor(L:L)->sig structure Y: G end;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Equality type mismatch: type constructor Y.t of the range is specified as admitting equality in the signature
!   type t = unit
! but its declaration does not admit equality in the module
!   type t = unit -> unit
- ! Toplevel input:
!   YG_L:functor(YL:sig structure Y: L end)->L;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Equality type mismatch: type constructor Y.t of the domain is specified as admitting equality in the module
!   type t = unit
! but its declaration does not admit equality in the signature
!   type t = unit -> unit
- ! Toplevel input:
!   L_YG_L:functor(L:L)->functor(YL:sig structure Y:L end)->L;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Equality type mismatch: type constructor Y.t of the domain of the range is specified as admitting equality in the module
!   type t = unit
! but its declaration does not admit equality in the signature
!   type t = unit -> unit
- ! Toplevel input:
!   FLYGL:sig functor F: functor(L:L)->functor(YL:sig structure Y:L end)->L end;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Equality type mismatch: type constructor Y.t of the domain of the range of F is specified as admitting equality in the module
!   type t = unit
! but its declaration does not admit equality in the signature
!   type t = unit -> unit
- > signature G = /\=t.{datatype t = (t,{con C : t}), con C : t}
- > signature L = {type t = unit}
- ! Toplevel input:
!   L:G;
!   ^^^
! Signature mismatch: the module does not match the signature ...
! Datatype mismatch: type constructor t is specified as a datatype in the signature
!   datatype t = (unit,{con C : unit})
! but not declared as a datatype in the module
!   type t = unit
! The declaration should also be a datatype
- ! Toplevel input:
!   LL:functor(L:L)->G;
!   ^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Datatype mismatch: type constructor t of the range is specified as a datatype in the signature
!   datatype t = (unit,{con C : unit})
! but not declared as a datatype in the module
!   type t = unit
! The declaration should also be a datatype
- ! Toplevel input:
!   GL:functor(L:L)->L;
!   ^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Datatype mismatch: type constructor t of the domain is specified as a datatype in the module
!   datatype t = (unit,{con C : unit})
! but not declared as a datatype in the signature
!   type t = unit
! The declaration should also be a datatype
- ! Toplevel input:
!   YL:sig structure Y: G end;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Datatype mismatch: type constructor Y.t is specified as a datatype in the signature
!   datatype t = (unit,{con C : unit})
! but not declared as a datatype in the module
!   type t = unit
! The declaration should also be a datatype
- ! Toplevel input:
!   L_YL:functor(L:L)->sig structure Y: G end;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Datatype mismatch: type constructor Y.t of the range is specified as a datatype in the signature
!   datatype t = (unit,{con C : unit})
! but not declared as a datatype in the module
!   type t = unit
! The declaration should also be a datatype
- ! Toplevel input:
!   YG_L:functor(YL:sig structure Y: L end)->L;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Datatype mismatch: type constructor Y.t of the domain is specified as a datatype in the module
!   datatype t = (unit,{con C : unit})
! but not declared as a datatype in the signature
!   type t = unit
! The declaration should also be a datatype
- ! Toplevel input:
!   L_YG_L:functor(L:L)->functor(YL:sig structure Y:L end)->L;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Datatype mismatch: type constructor Y.t of the domain of the range is specified as a datatype in the module
!   datatype t = (unit,{con C : unit})
! but not declared as a datatype in the signature
!   type t = unit
! The declaration should also be a datatype
- ! Toplevel input:
!   FLYGL:sig functor F: functor(L:L)->functor(YL:sig structure Y:L end)->L end;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Datatype mismatch: type constructor Y.t of the domain of the range of F is specified as a datatype in the module
!   datatype t = (unit,{con C : unit})
! but not declared as a datatype in the signature
!   type t = unit
! The declaration should also be a datatype
- > signature G = /\u.!t.{type t = t}->{type u = (u t)}
- > signature L = !t.{type t = t}->?u.{type u = u}
- ! Toplevel input:
!   L:G;
!   ^^^
! Signature mismatch: the module does not match the signature ...
! Scope Violation: type constructor u of the range has specification:
!   type u = (u t)
! in the signature
! but is implemented by the declaration: 
!   type u = u'
! in the module
! The declaration violates the specification because 
! the type constructor u' is a parameter 
! that is declared within the scope of u.
- ! Toplevel input:
!   LL:functor(L:L)->G;
!   ^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Scope Violation: type constructor u of the range of the range has specification:
!   type u = (u t)
! in the signature
! but is implemented by the declaration: 
!   type u = u'
! in the module
! The declaration violates the specification because 
! the type constructor u' is a parameter 
! that is declared within the scope of u.
- ! Toplevel input:
!   GL:functor(L:L)->L;
!   ^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Scope Violation: type constructor u of the range of the domain has specification:
!   type u = (u t)
! in the module
! but is implemented by the declaration: 
!   type u = u'
! in the signature
! The declaration violates the specification because 
! the type constructor u' is a parameter 
! that is declared within the scope of u.
- > signature G = /\u.{functor F : !t.{type t = t}->{type u = (u t)}}
- > signature L = {functor F : !t.{type t = t}->?u.{type u = u}}
- ! Toplevel input:
!   YL:sig structure Y: G end;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Scope Violation: type constructor u of the range of Y.F has specification:
!   type u = (u t)
! in the signature
! but is implemented by the declaration: 
!   type u = u'
! in the module
! The declaration violates the specification because 
! the type constructor u' is a parameter 
! that is declared within the scope of u.
- ! Toplevel input:
!   L_YL:functor(L:L)->sig structure Y: G end;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Scope Violation: type constructor u of the range of Y.F of the range has specification:
!   type u = (u t)
! in the signature
! but is implemented by the declaration: 
!   type u = u'
! in the module
! The declaration violates the specification because 
! the type constructor u' is a parameter 
! that is declared within the scope of u.
- ! Toplevel input:
!   YG_L:functor(YL:sig structure Y: L end)->L;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Scope Violation: type constructor u of the range of Y.F of the domain has specification:
!   type u = (u t)
! in the module
! but is implemented by the declaration: 
!   type u = u'
! in the signature
! The declaration violates the specification because 
! the type constructor u' is a parameter 
! that is declared within the scope of u.
- ! Toplevel input:
!   L_YG_L:functor(L:L)->functor(YL:sig structure Y:L end)->L;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Scope Violation: type constructor u of the range of Y.F of the domain of the range has specification:
!   type u = (u t)
! in the module
! but is implemented by the declaration: 
!   type u = u'
! in the signature
! The declaration violates the specification because 
! the type constructor u' is a parameter 
! that is declared within the scope of u.
- ! Toplevel input:
!   FLYGL:sig functor F: functor(L:L)->functor(YL:sig structure Y:L end)->L end;
!   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Signature mismatch: the module does not match the signature ...
! Scope Violation: type constructor u of the range of Y.F of the domain of the range of F has specification:
!   type u = (u t)
! in the module
! but is implemented by the declaration: 
!   type u = u'
! in the signature
! The declaration violates the specification because 
! the type constructor u' is a parameter 
! that is declared within the scope of u.
- 
Moscow ML version 1.44cvr3 (internal release) (16th January 2000)
Enter `quit();' to quit.
- > signature OK = {type t = int}
- > signature OK = {structure X : {type t = int}}
- > signature OK = {structure Y : {structure X : {type t = int}}}
- > signature OK = /\t.{type t = t, type u = t}
- > signature OK = /\u.{type u = u, type t = u}
- > signature OK = /\t.{structure X : {type t = t, type u = t}, type u = t}
- > signature OK =
  /\t.
    {structure Y : {structure X : {type t = t, type u = t}, type u = t},
     type u = t}
- > signature OK =
  /\t u u' a v.
    {structure Y :
       {structure X : {type t = t, type u = u}, type u = u', type a = a},
     structure Z :
       {structure Y :
          {structure X : {type t = t, type u = u}, type u = u', type v = v}},
     structure W : {type u = u', type v = v}}
- 
Moscow ML version 1.44cvr3 (internal release) (16th January 2000)
Enter `quit();' to quit.
- > structure X : {exn e : int -> exn}
- > structure Y : {val e : int -> exn}
- > val it = "OK" : string
- > functor F : {}->{exn e : int -> exn}
- > structure X : {exn e : int -> exn}
- > structure Y : {exn e : int -> exn}
- > val it = "OK" : string
- > val it = "OK" : string
- > exn s = s : exn
- > val it = (s, s) : exn * exn
- 
Moscow ML version 1.44cvr3 (internal release) (16th January 2000)
Enter `quit();' to quit.
- > signature S = {}
- > signature F = {}->{}
- > functor Ok : {}->{}
- ! Toplevel input:
! functor Fail(X:S) = op X;
!                     ^^^^
! Unbound functor identifier: X
! (In this context, it is assumed that 
!    op X
!  refers to a functor.
!  If you actually meant the structure of the same name,
!  you must use the syntax: 
!    X
!  to indicate this.)
- > functor Ok : ({}->{})->{}->{}
- ! Toplevel input:
! functor Fail(X:F) = X;
!                     ^
! Cannot access unit X before it has been loaded.
! (In this context, it is assumed that 
!    X
!  refers to a structure.
!  If you actually meant the functor of the same name,
!  you must use the syntax: 
!    op X
!  to indicate this.)
- > functor Ok : {}->{}
- > functor OK : {}->{}
- > functor Ok : ({}->{})->{}->{}
- > functor OK : ({}->{})->{}->{}
- > functor Ok : {}->{}
- > functor OK : {}->{}
- > functor Ok : ({}->{})->{}->{}
- > functor OK : ({}->{})->{}->{}
- > structure S : {}
- > functor F : {}->{}
- > functor H : ({}->{})->{}->{}
- > structure Ok : {}
- > structure Ok : {}
- > functor Ok : {}->{}
- > functor Ok : {}->{}
- > structure S : {}
- ! Toplevel input:
! structure F = functor(X:sig end)struct end;
!                                 ^^^^^^
! Syntax error.
- > functor G : {}->{}
- > functor H : ({}->{})->{}->{}
- > structure Ok : {}
- > structure Ok : {}
- > functor Ok : {}->{}
- > functor Ok : {}->{}
- > functor Ok : {}->{}
- ! Toplevel input:
! functor Fail(X:S) = op X where Y = struct end;
!                     ^^^^^^^^^^^^^^^^^^^^^^^^^
! Unbound functor identifier: X
! (In this context, it is assumed that 
!    op X
!  refers to a functor.
!  If you actually meant the structure of the same name,
!  you must use the syntax: 
!    X
!  to indicate this.)
- > functor Ok : ({}->{})->{}->{}
- ! Toplevel input:
! functor Fail(X:F) = X where Y = struct end;
!                     ^^^^^^^^^^^^^^^^^^^^^^
! Cannot access unit X before it has been loaded.
! (In this context, it is assumed that 
!    X
!  refers to a structure.
!  If you actually meant the functor of the same name,
!  you must use the syntax: 
!    op X
!  to indicate this.)
- > functor Ok : {}->{}
- > functor OK : {}->{}
- > functor Ok : ({}->{})->{}->{}
- > functor OK : ({}->{})->{}->{}
- > functor Ok : {}->{}
- ! Toplevel input:
! functor Fail(X:S) = let in op X end;
!                            ^^^^
! Unbound functor identifier: X
! (In this context, it is assumed that 
!    op X
!  refers to a functor.
!  If you actually meant the structure of the same name,
!  you must use the syntax: 
!    X
!  to indicate this.)
- > functor Ok : ({}->{})->{}->{}
- ! Toplevel input:
! functor Fail(X:F) = let in X end;
!                            ^
! Cannot access unit X before it has been loaded.
! (In this context, it is assumed that 
!    X
!  refers to a structure.
!  If you actually meant the functor of the same name,
!  you must use the syntax: 
!    op X
!  to indicate this.)
- > functor Ok : {}->{}
- > functor OK : {}->{}
- > functor Ok : ({}->{})->{}->{}
- > functor OK : ({}->{})->{}->{}
- 
Moscow ML version 1.44cvr3 (internal release) (16th January 2000)
Enter `quit();' to quit.
- > val integer = fn : int -> int
- > val ok = fn : int -> int
- - > val ok = fn : int -> int
- > val ok = fn : int -> int
- > functor OK : !a.{type a = a, val a : a}->{val 'a x : a -> 'a -> a}
- ! Toplevel input:
! 					       else  B.b
! 					             ^^^
! Type clash: expression of type
!   b
! cannot have type
!   'a
! because of a scope violation:
! the type constructor b is a parameter 
! that is declared within the scope of 'a
- > functor OK : !a.{type a = a, val a : a}->{val 'a x : 'a -> 'a -> 'a}
- - ! Toplevel input:
!             		                     (if true then j else B.b))
!             		                                          ^^^
! Type clash: expression of type
!   b
! cannot have type
!   'a
! because of a scope violation:
! the type constructor b is a parameter 
! that is declared within the scope of 'a
- 
Moscow ML version 1.44cvr3 (internal release) (16th January 2000)
Enter `quit();' to quit.
[opening file "test.sml"]
> structure Real :
  {type real = real,
   val != : real * real -> bool,
   val * : real * real -> real,
   val + : real * real -> real,
   val - : real * real -> real,
   val / : real * real -> real,
   val < : real * real -> bool,
   val <= : real * real -> bool,
   val == : real * real -> bool,
   val > : real * real -> bool,
   val >= : real * real -> bool,
   val ?= : real * real -> bool,
   exn Div : exn,
   exn Overflow : exn,
   val abs : real -> real,
   val ceil : real -> int,
   val compare : real * real -> order,
   val floor : real -> int,
   val fmt : realfmt -> real -> string,
   val fromDefault : real -> real,
   val fromInt : int -> real,
   val fromString : string -> real option,
   val max : real * real -> real,
   val min : real * real -> real,
   val round : real -> int,
   val sameSign : real * real -> bool,
   val 'a scan : ('a -> (char * 'a) option) -> 'a -> (real * 'a) option,
   val sign : real -> int,
   val toDefault : real -> real,
   val toString : real -> string,
   val trunc : real -> int,
   val ~ : real -> real}
[opening file "sample2.sml"]
> val henryV =
    {born = 1387, crowned = 1413, died = 1422, name = "Henry V",
     quote = "Bid them achieve me and then sell my bones"} :
  {born : int, crowned : int, died : int, name : string, quote : string}
> val henryVI =
    {born = 1421, crowned = 1422, died = 1471, name = "Henry VI",
     quote = "Weep, wretched man, I'll aid thee tear for tear."} :
  {born : int, crowned : int, died : int, name : string, quote : string}
> val richardIII =
    {born = 1452, crowned = 1483, died = 1485, name = "Richard III",
     quote = "Plots have I laid, inductions dangerous..."} :
  {born : int, crowned : int, died : int, name : string, quote : string}
> type king =
  {born : int, crowned : int, died : int, name : string, quote : string}
> val power = fn : real * int -> real
> val naive_fib = fn : int -> int
> val nextfib = fn : int * int -> int * int
> val fibpair = fn : int -> int * int
> val itfib = fn : int * int * int -> int
> val fib = fn : int -> int
> val findroot = fn : real * real * real -> real
> val sqroot = fn : real -> real
> val sqroot = fn : real -> real
> val pos = fn : real -> real
  val neg = fn : real -> real
> val piapprox = fn : int -> real
> structure Complex :
  {type t = real * real,
   val diff : (real * real) * (real * real) -> real * real,
   val prod : (real * real) * (real * real) -> real * real,
   val quo : (real * real) * (real * real) -> real * real,
   val recip : real * real -> real * real,
   val sum : (real * real) * (real * real) -> real * real,
   val zero : real * real}
> signature ARITH =
  /\t.
    {type t = t,
     val zero : t,
     val sum : t * t -> t,
     val diff : t * t -> t,
     val prod : t * t -> t,
     val quo : t * t -> t}
[closing file "sample2.sml"]
> val it = () : unit
[opening file "sample3.sml"]
File "sample3.sml", line 27-30, characters 4-178:
! ....change (coinvals, 0)         = []
!   | change (c::coinvals, amount) =
!       if amount<c then change(coinvals, amount)
!                   else c :: change(c::coinvals, amount-c).
! Warning: pattern matching is not exhaustive

> val change = fn : int list * int -> int list
> val gb_coins = [50, 20, 10, 5, 2, 1] : int list
  val us_coins = [25, 10, 5, 1] : int list
> val allChange = fn : int list * int list * int -> int list list
File "sample3.sml", line 46-48, characters 4-103:
! ....bincarry (0, ps) = ps
!   | bincarry (1, []) = [1]
!   | bincarry (1, p::ps) = (1-p) :: bincarry(p, ps).
! Warning: pattern matching is not exhaustive

> val bincarry = fn : int * int list -> int list
> val binsum = fn : int * int list * int list -> int list
File "sample3.sml", line 57-59, characters 4-127:
! ....binprod ([], _) = []
!   | binprod (0::ps, qs) = 0::binprod(ps,qs)
!   | binprod (1::ps, qs) = binsum(0, qs, 0::binprod(ps,qs)).
! Warning: pattern matching is not exhaustive

> val binprod = fn : int list * int list -> int list
File "sample3.sml", line 64-65, characters 4-71:
! ....headcol []    = []
!   | headcol ((x::_) :: rows) = x :: headcol rows.
! Warning: pattern matching is not exhaustive

> val 'a headcol = fn : 'a list list -> 'a list
File "sample3.sml", line 67-68, characters 4-76:
! ....tailcols []    = []
!   | tailcols ((_::xs) :: rows) = xs :: tailcols rows.
! Warning: pattern matching is not exhaustive

> val 'a tailcols = fn : 'a list list -> 'a list list
> val 'a transp = fn : 'a list list -> 'a list list
File "sample3.sml", line 77-78, characters 4-73:
! ....dotprod([], []) = 0.0
!   | dotprod(x::xs,y::ys) = x*y + dotprod(xs,ys).
! Warning: pattern matching is not exhaustive

> val dotprod = fn : real list * real list -> real
> val rowprod = fn : real list * real list list -> real list
> val rowlistprod = fn : real list list * real list list -> real list list
> val matprod = fn : real list list * real list list -> real list list
File "sample3.sml", line 94-98, characters 4-172:
! ....pivotrow [row] = row : real list
!   | pivotrow (row1::row2::rows) =
!       if abs(hd row1) >= abs(hd row2)
!       then pivotrow(row1::rows)
!       else pivotrow(row2::rows).
! Warning: pattern matching is not exhaustive

> val pivotrow = fn : real list list -> real list
> val delrow = fn : real * real list list -> real list list
> val scalarprod = fn : real * real list -> real list
File "sample3.sml", line 109-110, characters 4-93:
! ....vectorsum ([], []) = [] : real list
!   | vectorsum (x::xs,y::ys) = x+y :: vectorsum(xs,ys).
! Warning: pattern matching is not exhaustive

> val vectorsum = fn : real list * real list -> real list
File "sample3.sml", line 115-118, characters 14-159:
! ..............elimcol [] = []
!             | elimcol ((x::xs)::rows) =
!                   vectorsum(xs, scalarprod(~x/p, prow))
!                   :: elimcol rows
! Warning: pattern matching is not exhaustive

File "sample3.sml", line 114, characters 14-21:
!       let val p::prow = pivotrow rows
!               ^^^^^^^
! Warning: pattern matching is not exhaustive

> val gausselim = fn : real list list -> real list list
File "sample3.sml", line 122-125, characters 4-139:
! ....solutions [] = [~1.0]
!   | solutions((x::xs)::rows) =
!       let val solns = solutions rows
!       in ~(dotprod(solns,xs)/x) :: solns  end.
! Warning: pattern matching is not exhaustive

> val solutions = fn : real list list -> real list
> val squares = fn : int -> (int * int) list
File "sample3.sml", line 153-156, characters 14-174:
! ..............swap [x] = y::x::ys
!             | swap (x::xk::xs) =          (*x >= xk *)
!                 if xk>y then x::swap(xk::xs)
!                 else (y::xk::xs)@(x::ys)
! Warning: pattern matching is not exhaustive

File "sample3.sml", line 150-158, characters 4-409:
! ....next(xlist, y::ys) : int list =
!     if hd xlist <= y then  next(y::xlist, ys)  (*still increasing*)
!     else  (*swap y with greatest xk such that x>=xk>y *)
!       let fun swap [x] = y::x::ys
!             | swap (x::xk::xs) =          (*x >= xk *)
!                 if xk>y then x::swap(xk::xs)
!                 else (y::xk::xs)@(x::ys)
!                          (* x > y >= xk >= xs *)
!       in swap(xlist) end.
! Warning: pattern matching is not exhaustive

> val next = fn : int list * int list -> int list
File "sample3.sml", line 160, characters 4-36:
! fun nextperm (y::ys) = next([y], ys);
!     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Warning: pattern matching is not exhaustive

> val nextperm = fn : int list -> int list
> infix 0 mem
> val ''a mem = fn : ''a * ''a list -> bool
> val ''a newmem = fn : ''a * ''a list -> ''a list
> val ''a union = fn : ''a list * ''a list -> ''a list
> val ''a inter = fn : ''a list * ''a list -> ''a list
> val 'a powset = fn : 'a list * 'a list -> 'a list list
> val ('a, 'b) cartprod = fn : 'a list * 'b list -> ('a * 'b) list
> val (''a, 'b) nexts = fn : ''a * (''a * 'b) list -> 'b list
> val ''a depthf = fn : ''a list * (''a * ''a) list * ''a list -> ''a list
> val ''a depth = fn : ''a list * (''a * ''a) list * ''a list -> ''a list
> val ''a topsort = fn : (''a * ''a) list -> ''a list
> val ''a pathsort = fn : (''a * ''a) list -> ''a list
> val ('a, 'b) newvisit = fn : 'a * ('a list * 'b) -> 'a list * 'b
> val ''a cyclesort = fn : (''a * ''a) list -> ''a list * ''a list
> val nextrandom = fn : real -> real
  val truncto = fn : int -> real -> int
> val randlist = fn : int * real * real list -> real * real list
> val ins = fn : real * real list -> real list
> val insort = fn : real list -> real list
> val quick = fn : real list -> real list
> val merge = fn : real list * real list -> real list
> val tmergesort = fn : real list -> real list
> val tmergesort' = fn : real list -> real list
File "sample3.sml", line 317-320, characters 4-146:
! ....mergepairs([l], k) = [l]
!   | mergepairs(l1::l2::ls, k) =
!       if k mod 2 = 1 then l1::l2::ls
!       else mergepairs(merge(l1,l2)::ls, k div 2).
! Warning: pattern matching is not exhaustive

> val mergepairs = fn : real list list * int -> real list list
> val sorting = fn : real list * real list list * int -> real list
> val sort = fn : real list -> real list
> val nextrun = fn : real list * real list -> real list * real list
> val samsorting = fn : real list * real list list * int -> real list
> val samsort = fn : real list -> real list
> nonfix rem
File "sample3.sml", line 381-387, characters 6-265:
! ......quorem (ts, (n,b)::us) =
!     let fun dividing ([],        qs) = (rev qs, [])
! 	  | dividing ((m,a)::ts, qs) =
! 	      if m<n then (rev qs, (m,a)::ts)
! 	      else dividing (sum (ts, termprod ((m-n, ~a/b), us)),
! 			(m-n, a/b) :: qs)
!     in  dividing (ts, [])  end.
! Warning: pattern matching is not exhaustive

> structure Poly :
  {type t = (int * real) list,
   val gcd : (int * real) list * (int * real) list -> (int * real) list,
   val prod : (int * real) list * (int * real) list -> (int * real) list,
   val quo : (int * real) list * (int * real) list -> (int * real) list,
   val quorem :
     (int * real) list * (int * real) list ->
     (int * real) list * (int * real) list,
   val rem : (int * real) list * (int * real) list -> (int * real) list,
   val sum : (int * real) list * (int * real) list -> (int * real) list,
   val termprod : (int * real) * (int * real) list -> (int * real) list,
   val 'a zero : 'a list}
[closing file "sample3.sml"]
> val it = () : unit
[opening file "sample4.sml"]
> New type names: =person
  datatype person =
  (person,
   {con King : person,
    con Peer : string * string * int -> person,
    con Knight : string -> person,
    con Peasant : string -> person})
  con King = King : person
  con Peer = fn : string * string * int -> person
  con Knight = fn : string -> person
  con Peasant = fn : string -> person
> val title = fn : person -> string
> val sirs = fn : person list -> string list
> val superior = fn : person * person -> bool
> New type names: =degree
  datatype degree =
  (degree,
   {con Duke : degree,
    con Marquis : degree,
    con Earl : degree,
    con Viscount : degree,
    con Baron : degree})
  con Duke = Duke : degree
  con Marquis = Marquis : degree
  con Earl = Earl : degree
  con Viscount = Viscount : degree
  con Baron = Baron : degree
> val lady = fn : degree -> string
> exn Change = Change : exn
> val backChange = fn : int list * int -> int list
> New type names: =tree
  datatype 'a tree =
  ('a tree,
   {con 'a Lf : 'a tree, con 'a Br : 'a * 'a tree * 'a tree -> 'a tree})
  con 'a Lf = Lf : 'a tree
  con 'a Br = fn : 'a * 'a tree * 'a tree -> 'a tree
File "sample4.sml", line 106, characters 9-14:
! 	    val y::ys = List.drop(xs,k)
! 	        ^^^^^
! Warning: pattern matching is not exhaustive

> structure Tree :
  {val 'a balin : 'a list -> 'a tree,
   val 'a balpost : 'a list -> 'a tree,
   val 'a balpre : 'a list -> 'a tree,
   val 'a depth : 'a tree -> int,
   val 'a inord : 'a tree * 'a list -> 'a list,
   val 'a postord : 'a tree * 'a list -> 'a list,
   val 'a preord : 'a tree * 'a list -> 'a list,
   val 'a reflect : 'a tree -> 'a tree,
   val 'a size : 'a tree -> int}
> signature DICTIONARY =
  /\key t.
    {type key = key,
     type 'a t = 'a t,
     exn E : key -> exn,
     val 'a empty : 'a t,
     val 'a lookup : 'a t * key -> 'a,
     val 'a insert : 'a t * key * 'a -> 'a t,
     val 'a update : 'a t * key * 'a -> 'a t}
> structure Dict :
  {type key = string,
   type 'a t = (string * 'a) tree,
   exn E : string -> exn,
   val 'a empty : (string * 'a) tree,
   val 'a insert : (string * 'a) tree * string * 'a -> (string * 'a) tree,
   val 'a lookup : (string * 'a) tree * string -> 'a,
   val 'a update : (string * 'a) tree * string * 'a -> (string * 'a) tree}
File "sample4.sml", line 195-197, characters 6-161:
! ......lorem Lf = raise Size
!     | lorem (Br(_,Lf,Lf)) = Lf 	(*No evens, therefore no odds either*)
!     | lorem (Br(_, t1 as Br(v,_,_), t2)) = Br(v, t2, lorem t1).
! Warning: pattern matching is not exhaustive

> structure Braun :
  {val 'a delete : 'a tree * int -> 'a tree,
   val 'a loext : 'a tree * 'a -> 'a tree,
   val 'a lorem : 'a tree -> 'a tree,
   val 'a sub : 'a tree * int -> 'a,
   val 'a update : 'a tree * int * 'a -> 'a tree}
> signature FLEXARRAY =
  /\array.
    {type 'a array = 'a array,
     val 'a empty : 'a array,
     val 'a length : 'a array -> int,
     val 'a sub : 'a array * int -> 'a,
     val 'a update : 'a array * int * 'a -> 'a array,
     val 'a loext : 'a array * 'a -> 'a array,
     val 'a lorem : 'a array -> 'a array,
     val 'a hiext : 'a array * 'a -> 'a array,
     val 'a hirem : 'a array -> 'a array}
> New type names: =array
  structure Flex :
  {type 'a array = 'a array,
   val 'a empty : 'a array,
   val 'a hiext : 'a array * 'a -> 'a array,
   val 'a hirem : 'a array -> 'a array,
   val 'a length : 'a array -> int,
   val 'a loext : 'a array * 'a -> 'a array,
   val 'a lorem : 'a array -> 'a array,
   val 'a sub : 'a array * int -> 'a,
   val 'a update : 'a array * int * 'a -> 'a array}
> signature PRIORITY_QUEUE =
  /\item t.
    {type item = item,
     type t = t,
     val empty : t,
     val null : t -> bool,
     val insert : item * t -> t,
     val min : t -> item,
     val delmin : t -> t,
     val fromList : item list -> t,
     val toList : t -> item list,
     val sort : item list -> item list}
File "sample4.sml", line 276, characters 6-25:
!   fun min (Br(v,_,_)) = v;
!       ^^^^^^^^^^^^^^^^^^^
! Warning: pattern matching is not exhaustive

File "sample4.sml", line 283-286, characters 6-130:
! ......leftrem (Br(v,Lf,Lf)) = (v, Lf)
!     | leftrem (Br(v,t1,t2)) = 
!         let val (w, t) = leftrem t1
! 	in  (w, Br(v,t2,t))  end.
! Warning: pattern matching is not exhaustive

File "sample4.sml", line 288-295, characters 6-403:
! ......siftdown (w:real, Lf, Lf) = Br(w,Lf,Lf)
!     | siftdown (w, t as Br(v,Lf,Lf), Lf) =
!         if w <= v then Br(w, t, Lf)
!                   else Br(v, Br(w,Lf,Lf), Lf)
!     | siftdown (w, t1 as Br(v1,p1,q1), t2 as Br(v2,p2,q2)) =
!         if w <= v1 andalso w <= v2 then Br(w,t1,t2)
!         else if v1 <= v2 then Br(v1, siftdown(w,p1,q1), t2)
!            (* v2 < v1 *) else Br(v2, t1, siftdown(w,p2,q2)).
! Warning: pattern matching is not exhaustive

File "sample4.sml", line 303-307, characters 6-186:
! ......heapify (0, vs) = (Lf, vs)
!     | heapify (n, v::vs) =
! 	let val (t1, vs1) = heapify (n div 2, vs)
! 	    val (t2, vs2) = heapify ((n-1) div 2, vs1)
! 	in  (siftdown (v,t1,t2), vs2)  end.
! Warning: pattern matching is not exhaustive

> structure Heap :
  {type item = real,
   type t = real tree,
   val delmin : real tree -> real tree,
   val empty : real tree,
   val fromList : real list -> real tree,
   val insert : real * real tree -> real tree,
   val min : real tree -> real,
   val null : real tree -> bool,
   val sort : real list -> real list,
   val toList : real tree -> real list}
> New type names: =prop
  datatype prop =
  (prop,
   {con Atom : string -> prop,
    con Neg : prop -> prop,
    con Conj : prop * prop -> prop,
    con Disj : prop * prop -> prop})
  con Atom = fn : string -> prop
  con Neg = fn : prop -> prop
  con Conj = fn : prop * prop -> prop
  con Disj = fn : prop * prop -> prop
> val show = fn : prop -> string
> val nnf = fn : prop -> prop
> val nnfpos = fn : prop -> prop
  val nnfneg = fn : prop -> prop
> val distrib = fn : prop * prop -> prop
> val cnf = fn : prop -> prop
> exn NonCNF = NonCNF : exn
> val positives = fn : prop -> string list
> val negatives = fn : prop -> string list
> val taut = fn : prop -> bool
[closing file "sample4.sml"]
> val it = () : unit
[opening file "sample5.sml"]
> val 'a insort = fn : ('a * 'a -> bool) -> 'a list -> 'a list
> val ('a, 'b, 'c) secl = fn : 'a -> ('a * 'b -> 'c) -> 'b -> 'c
> val ('a, 'b, 'c) secr = fn : ('a * 'b -> 'c) -> 'b -> 'a -> 'c
> val summation = fn : (int -> real) -> int -> real
> val 'a takewhile = fn : ('a -> bool) -> 'a list -> 'a list
> val 'a dropwhile = fn : ('a -> bool) -> 'a list -> 'a list
> infix 0 mem
> val ''a mem = fn : ''a * ''a list -> bool
> val ('a, 'b) pair = fn : 'a -> 'b -> 'a * 'b
> val ('a, 'b) cartprod = fn : 'a list * 'b list -> ('a * 'b) list
> val 'a repeat = fn : ('a -> 'a) -> int -> 'a -> 'a
> New type names: seq
  datatype 'a seq =
  ('a seq,{con 'a Nil : 'a seq, con 'a Cons : 'a * (unit -> 'a seq) -> 'a seq})
  con 'a Nil = Nil : 'a seq
  con 'a Cons = fn : 'a * (unit -> 'a seq) -> 'a seq
> signature SEQUENCE =
  {exn Empty : exn,
   val 'a cons : 'a * 'a seq -> 'a seq,
   val 'a null : 'a seq -> bool,
   val 'a hd : 'a seq -> 'a,
   val 'a tl : 'a seq -> 'a seq,
   val 'a fromList : 'a list -> 'a seq,
   val 'a toList : 'a seq -> 'a list,
   val 'a take : 'a seq * int -> 'a list,
   val 'a drop : 'a seq * int -> 'a seq,
   val 'a @ : 'a seq * 'a seq -> 'a seq,
   val 'a interleave : 'a seq * 'a seq -> 'a seq,
   val ('a, 'b) map : ('a -> 'b) -> 'a seq -> 'b seq,
   val 'a filter : ('a -> bool) -> 'a seq -> 'a seq,
   val 'a iterates : ('a -> 'a) -> 'a -> 'a seq,
   val from : int -> int seq}
> structure Seq :
  {val 'a @ : 'a seq * 'a seq -> 'a seq,
   exn Empty : exn,
   val 'a cons : 'a * 'a seq -> 'a seq,
   val 'a drop : 'a seq * int -> 'a seq,
   val 'a filter : ('a -> bool) -> 'a seq -> 'a seq,
   val from : int -> int seq,
   val 'a fromList : 'a list -> 'a seq,
   val 'a hd : 'a seq -> 'a,
   val 'a interleave : 'a seq * 'a seq -> 'a seq,
   val 'a iterates : ('a -> 'a) -> 'a -> 'a seq,
   val ('a, 'b) map : ('a -> 'b) -> 'a seq -> 'b seq,
   val 'a null : 'a seq -> bool,
   val 'a take : 'a seq * int -> 'a list,
   val 'a tl : 'a seq -> 'a seq,
   val 'a toList : 'a seq -> 'a list}
> val seqChange = fn :
  int list * int list * int * (unit -> int list seq) -> int list seq
> val randseq = fn : int -> real seq
> val sift = fn : int -> int seq -> int seq
File "sample5.sml", line 172, characters 4-62:
! fun sieve (Cons(p,nf)) = Cons(p, fn()=> sieve (sift p (nf())));
!     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Warning: pattern matching is not exhaustive

> val sieve = fn : int seq -> int seq
> val primes = Cons(2, fn) : int seq
> val nextApprox = fn : real -> real -> real
File "sample5.sml", line 182, characters 14-24:
!       let val Cons(y,yf) = xf() 
!               ^^^^^^^^^^
! Warning: pattern matching is not exhaustive

File "sample5.sml", line 181-185, characters 4-151:
! ....within (eps:real) (Cons(x,xf)) =
!       let val Cons(y,yf) = xf() 
!       in  if Real.abs(x-y) < eps then y
! 	  else within eps (Cons(y,yf))
!       end.
! Warning: pattern matching is not exhaustive

> val within = fn : real -> real seq -> real
> val qroot = fn : real -> real
> val ('a, 'b) makeqq = fn : 'a seq * 'b seq -> ('a * 'b) seq seq
> val 'a takeqq = fn : 'a seq seq * (int * int) -> 'a list list
> val 'a enumerate = fn : 'a seq seq -> 'a seq
> val double = fn : int -> int
> val powof2 = fn : int -> int
> val pack_ = fn : int * int -> int
> val pairqq = Cons(Cons((1, 1), fn), fn) : (int * int) seq seq
> val nqq = Cons(Cons(1, fn), fn) : int seq seq
> val 'a depthFirst = fn : ('a -> 'a list) -> 'a -> 'a seq
> val 'a breadthFirst = fn : ('a -> 'a list) -> 'a -> 'a seq
> val nextChar = fn : char list -> char list list
> val ''a isPalin = fn : ''a list -> bool
> val show = fn : int -> char list seq -> string list
> val it = ["", "A", "B", "C", "AA", "BB", "CC", "AAA"] : string list
> val safeQueen = fn : int list -> int -> bool
> val upto = fn : int * int -> int list
> val nextQueen = fn : int -> int list -> int list list
> val 'a isFull = fn : int -> 'a list -> bool
> val depthQueen = fn : int -> int list seq
> val 'a depthIter = fn : ('a -> 'a list) -> 'a -> 'a seq
[closing file "sample5.sml"]
> val it = () : unit
[opening file "sample7.sml"]
> structure Queue1 :
  {type 'a t = 'a list,
   exn E : exn,
   val 'a deq : 'a list -> 'a list,
   val 'a empty : 'a list,
   val 'a enq : 'a list * 'a -> 'a list,
   val 'a hd : 'a list -> 'a,
   val 'a null : 'a list -> bool}
> New type names: =t
  structure Queue2 :
  {datatype 'a t =
     ('a t,{con 'a empty : 'a t, con 'a enq : 'a t * 'a -> 'a t}),
   exn E : exn,
   val 'a deq : 'a t -> 'a t,
   con 'a empty : 'a t,
   con 'a enq : 'a t * 'a -> 'a t,
   val 'a hd : 'a t -> 'a,
   val 'a null : 'a t -> bool}
> New type names: =t'
  structure Queue3 :
  {datatype 'a t = ('a t',{con 'a Queue : 'a list * 'a list -> 'a t'}),
   exn E : exn,
   con 'a Queue : 'a list * 'a list -> 'a t',
   val 'a deq : 'a t' -> 'a t',
   val 'a empty : 'a t',
   val 'a enq : 'a t' * 'a -> 'a t',
   val 'a hd : 'a t' -> 'a,
   val 'a norm : 'a t' -> 'a t',
   val 'a null : 'a t' -> bool}
> signature QUEUE =
  /\t''.
    {type 'a t = 'a t'',
     exn E : exn,
     val 'a empty : 'a t'',
     val 'a enq : 'a t'' * 'a -> 'a t'',
     val 'a null : 'a t'' -> bool,
     val 'a hd : 'a t'' -> 'a,
     val 'a deq : 'a t'' -> 'a t''}
> New type names: t''
  structure Queue :
  {type 'a t = 'a t'',
   exn E : exn,
   val 'a deq : 'a t'' -> 'a t'',
   val 'a empty : 'a t'',
   val 'a enq : 'a t'' * 'a -> 'a t'',
   val 'a hd : 'a t'' -> 'a,
   val 'a null : 'a t'' -> bool}
File "sample7.sml", line 147, characters 6-23:
!   fun qhd(Q1(x::q)) = x;
!       ^^^^^^^^^^^^^^^^^
! Warning: pattern matching is not exhaustive

File "sample7.sml", line 149, characters 6-26:
!   fun deq(Q1(x::q)) = Q1 q;
!       ^^^^^^^^^^^^^^^^^^^^
! Warning: pattern matching is not exhaustive

> New type names: queue1
  type 'a queue1 = 'a queue1
  val 'a empty = <queue1> : 'a queue1
  val 'a enq = fn : 'a queue1 * 'a -> 'a queue1
  val 'a qnull = fn : 'a queue1 -> bool
  val 'a qhd = fn : 'a queue1 -> 'a
  val 'a deq = fn : 'a queue1 -> 'a queue1
File "sample7.sml", line 163-164, characters 6-57:
! ......qhd (Enq(Empty,x)) = x
!     | qhd (Enq(q,x)) = qhd q.
! Warning: pattern matching is not exhaustive

File "sample7.sml", line 166-167, characters 6-69:
! ......deq (Enq(Empty,x)) = Empty
!     | deq (Enq(q,x)) = Enq(deq q, x).
! Warning: pattern matching is not exhaustive

> New type names: queue2
  type 'a queue2 = 'a queue2
  val 'a empty = <queue2> : 'a queue2
  val 'a enq = fn : 'a queue2 * 'a -> 'a queue2
  val 'a qnull = fn : 'a queue2 -> bool
  val 'a qhd = fn : 'a queue2 -> 'a
  val 'a deq = fn : 'a queue2 -> 'a queue2
> functor TestQueue :
  !t'''.
   {type 'a t = 'a t''',
    exn E : exn,
    val 'a empty : 'a t''',
    val 'a enq : 'a t''' * 'a -> 'a t''',
    val 'a null : 'a t''' -> bool,
    val 'a hd : 'a t''' -> 'a,
    val 'a deq : 'a t''' -> 'a t'''}->
       {val 'a fromList : 'a list -> 'a t''',
        val 'a toList : 'a t''' -> 'a list}
> functor BreadthFirst :
  !t'''.
   {type 'a t = 'a t''',
    exn E : exn,
    val 'a empty : 'a t''',
    val 'a enq : 'a t''' * 'a -> 'a t''',
    val 'a null : 'a t''' -> bool,
    val 'a hd : 'a t''' -> 'a,
    val 'a deq : 'a t''' -> 'a t'''}->
       {val 'a enqlist : 'a t''' -> 'a list -> 'a t''',
        val 'a search : ('a -> 'a list) -> 'a -> 'a seq}
> structure Breadth :
  {val 'a enqlist : 'a t'' -> 'a list -> 'a t'',
   val 'a search : ('a -> 'a list) -> 'a -> 'a seq}
> val brQueen = fn : int -> int list seq
> structure Breadth1 :
  {val 'a enqlist : 'a list -> 'a list -> 'a list,
   val 'a search : ('a -> 'a list) -> 'a -> 'a seq}
> val brQueen1 = fn : int -> int list seq
> signature ZSP =
  /\t'''.
    {type t = t''',
     val zero : t''',
     val sum : t''' * t''' -> t''',
     val prod : t''' * t''' -> t'''}
> functor MatrixZSP :
  !t'''.
   {type t = t''',
    val zero : t''',
    val sum : t''' * t''' -> t''',
    val prod : t''' * t''' -> t'''}->
       {type t = t''' list list,
        val prod : t''' list list * t''' list list -> t''' list list,
        val sum : t''' list list * t''' list list -> t''' list list,
        val zero : t''' list list}
> structure IntZSP :
  {type t = int,
   val prod : int * int -> int,
   val sum : int * int -> int,
   val zero : int}
> structure BoolZSP :
  {type t = bool,
   val prod : bool * bool -> bool,
   val sum : bool * bool -> bool,
   val zero : bool}
File "sample7.sml", line 265, characters 6-15:
!   val SOME zero = Int.maxInt;
!       ^^^^^^^^^
! Warning: pattern matching is not exhaustive

> structure PathZSP :
  {type t = int,
   val prod : int * int -> int,
   val sum : int * int -> int,
   val zero : int}
> structure PathMatrix :
  {type t = int list list,
   val prod : int list list * int list list -> int list list,
   val sum : int list list * int list list -> int list list,
   val zero : int list list}
> val fast_paths = fn : int list list -> int list list
> val zz = 1073741823 : int
> val mat =
    [[0, 3, 8, 1073741823, ~4], [1073741823, 0, 1073741823, 1, 7],
     [1073741823, 4, 0, 1073741823, 1073741823],
     [2, 1073741823, ~5, 0, 1073741823],
     [1073741823, 1073741823, 1073741823, 6, 0]] : int list list
> signature ORDER = /\t'''.{type t = t''', val compare : t''' * t''' -> order}
> structure StringOrder :
  {type t = string, val compare : string * string -> order}
> functor Dictionary :
  !t'''.
   {type t = t''', val compare : t''' * t''' -> order}->
       ?t''''.
        {type key = t''',
         type 'a t = 'a t'''',
         exn E : t''' -> exn,
         val 'a empty : 'a t'''',
         val 'a insert : 'a t'''' * t''' * 'a -> 'a t'''',
         val 'a lookup : 'a t'''' * t''' -> 'a,
         val 'a update : 'a t'''' * t''' * 'a -> 'a t''''}
> New type names: t'''
  structure StringDict :
  {type key = string,
   type 'a t = 'a t''',
   exn E : string -> exn,
   val 'a empty : 'a t''',
   val 'a insert : 'a t''' * string * 'a -> 'a t''',
   val 'a lookup : 'a t''' * string -> 'a,
   val 'a update : 'a t''' * string * 'a -> 'a t'''}
> signature PRIORITY_QUEUE =
  /\t'''' t'''''.
    {structure Item : {type t = t'''', val compare : t'''' * t'''' -> order},
     type t = t''''',
     val empty : t''''',
     val null : t''''' -> bool,
     val insert : t'''' * t''''' -> t''''',
     val min : t''''' -> t'''',
     val delmin : t''''' -> t''''',
     val fromList : t'''' list -> t''''',
     val toList : t''''' -> t'''' list,
     val sort : t'''' list -> t'''' list}
> functor AssocList :
  !=key.
   {type key = key}->
       {type key = key,
        type 'a t = (key * 'a) list,
        exn E : key -> exn,
        val 'a empty : (key * 'a) list,
        val 'a insert : (key * 'a) list * key * 'a -> (key * 'a) list,
        val 'a lookup : (key * 'a) list * key -> 'a,
        val 'a update : (key * 'a) list * key * 'a -> (key * 'a) list}
> signature TREE =
  /\=tree'.
    {datatype 'a tree =
       ('a tree',
        {con 'a Lf : 'a tree',
         con 'a Br : 'a * 'a tree' * 'a tree' -> 'a tree'}),
     con 'a Lf : 'a tree',
     con 'a Br : 'a * 'a tree' * 'a tree' -> 'a tree',
     val 'a size : 'a tree' -> int,
     val 'a depth : 'a tree' -> int,
     val 'a reflect : 'a tree' -> 'a tree'}
> signature BRAUN =
  /\=tree'.
    {structure Tree :
       {datatype 'a tree =
          ('a tree',
           {con 'a Lf : 'a tree',
            con 'a Br : 'a * 'a tree' * 'a tree' -> 'a tree'}),
        con 'a Lf : 'a tree',
        con 'a Br : 'a * 'a tree' * 'a tree' -> 'a tree',
        val 'a size : 'a tree' -> int,
        val 'a depth : 'a tree' -> int,
        val 'a reflect : 'a tree' -> 'a tree'},
     val 'a sub : 'a tree' * int -> 'a,
     val 'a update : 'a tree' * int * 'a -> 'a tree',
     val 'a delete : 'a tree' * int -> 'a tree',
     val 'a loext : 'a tree' * 'a -> 'a tree',
     val 'a lorem : 'a tree' -> 'a tree'}
File "sample7.sml", line 425, characters 10-33:
!       fun min (PQ(Br(v,_,_))) = v;
!           ^^^^^^^^^^^^^^^^^^^^^^^
! Warning: pattern matching is not exhaustive

File "sample7.sml", line 434-437, characters 10-131:
! ..........leftrem (Br(v,Lf,_)) = (v, Lf)
! 	| leftrem (Br(v,t1,t2)) = 
! 	    let val (w, t) = leftrem t1
! 	    in  (w, Br(v,t2,t))  end.
! Warning: pattern matching is not exhaustive

File "sample7.sml", line 454-458, characters 10-192:
! ..........heapify (0, vs) = (Lf, vs)
! 	| heapify (n, v::vs) =
! 	    let val (t1, vs1) = heapify (n div 2, vs)
! 		val (t2, vs2) = heapify ((n-1) div 2, vs1)
! 	    in  (siftdown (v,t1,t2), vs2)  end.
! Warning: pattern matching is not exhaustive

> functor PriorityQueue :
  !t'''' =tree'.
   {structure Item : {type t = t'''', val compare : t'''' * t'''' -> order},
    structure Tree :
      {datatype 'a tree =
         ('a tree',
          {con 'a Lf : 'a tree',
           con 'a Br : 'a * 'a tree' * 'a tree' -> 'a tree'}),
       con 'a Lf : 'a tree',
       con 'a Br : 'a * 'a tree' * 'a tree' -> 'a tree',
       val 'a size : 'a tree' -> int,
       val 'a depth : 'a tree' -> int,
       val 'a reflect : 'a tree' -> 'a tree'}}->
       ?t'''''.
        {structure Item :
           {type t = t'''', val compare : t'''' * t'''' -> order},
         type t = t''''',
         val delmin : t''''' -> t''''',
         val empty : t''''',
         val fromList : t'''' list -> t''''',
         val insert : t'''' * t''''' -> t''''',
         val min : t''''' -> t'''',
         val null : t''''' -> bool,
         val sort : t'''' list -> t'''' list,
         val toList : t''''' -> t'''' list}
> functor FlexArray :
  !=tree'.
   {structure Tree :
      {datatype 'a tree =
         ('a tree',
          {con 'a Lf : 'a tree',
           con 'a Br : 'a * 'a tree' * 'a tree' -> 'a tree'}),
       con 'a Lf : 'a tree',
       con 'a Br : 'a * 'a tree' * 'a tree' -> 'a tree',
       val 'a size : 'a tree' -> int,
       val 'a depth : 'a tree' -> int,
       val 'a reflect : 'a tree' -> 'a tree'},
    val 'a sub : 'a tree' * int -> 'a,
    val 'a update : 'a tree' * int * 'a -> 'a tree',
    val 'a delete : 'a tree' * int -> 'a tree',
    val 'a loext : 'a tree' * 'a -> 'a tree',
    val 'a lorem : 'a tree' -> 'a tree'}->
       ?=array'.
        {type 'a array = 'a array',
         val 'a empty : 'a array',
         val 'a hiext : 'a array' * 'a -> 'a array',
         val 'a hirem : 'a array' -> 'a array',
         val 'a length : 'a array' -> int,
         val 'a loext : 'a array' * 'a -> 'a array',
         val 'a lorem : 'a array' -> 'a array',
         val 'a sub : 'a array' * int -> 'a,
         val 'a update : 'a array' * int * 'a -> 'a array'}
> functor BraunFunctor :
  !=tree'.
   {datatype 'a tree =
      ('a tree',
       {con 'a Lf : 'a tree',
        con 'a Br : 'a * 'a tree' * 'a tree' -> 'a tree'}),
    con 'a Lf : 'a tree',
    con 'a Br : 'a * 'a tree' * 'a tree' -> 'a tree',
    val 'a size : 'a tree' -> int,
    val 'a depth : 'a tree' -> int,
    val 'a reflect : 'a tree' -> 'a tree'}->
       {structure Tree :
          {datatype 'a tree =
             ('a tree',
              {con 'a Lf : 'a tree',
               con 'a Br : 'a * 'a tree' * 'a tree' -> 'a tree'}),
           con 'a Br : 'a * 'a tree' * 'a tree' -> 'a tree',
           con 'a Lf : 'a tree',
           val 'a depth : 'a tree' -> int,
           val 'a reflect : 'a tree' -> 'a tree',
           val 'a size : 'a tree' -> int},
        val 'a delete : 'a tree' * int -> 'a tree',
        val 'a loext : 'a tree' * 'a -> 'a tree',
        val 'a lorem : 'a tree' -> 'a tree',
        val 'a sub : 'a tree' * int -> 'a,
        val 'a update : 'a tree' * int * 'a -> 'a tree'}
File "sample7.sml", line 577, characters 9-14:
! 	    val y::ys = List.drop(xs,k)
! 	        ^^^^^
! Warning: pattern matching is not exhaustive

> functor TreeFunctor :
  {}->
      ?=tree'.
       {datatype 'a tree =
          ('a tree',
           {con 'a Lf : 'a tree',
            con 'a Br : 'a * 'a tree' * 'a tree' -> 'a tree'}),
        con 'a Br : 'a * 'a tree' * 'a tree' -> 'a tree',
        con 'a Lf : 'a tree',
        val 'a depth : 'a tree' -> int,
        val 'a reflect : 'a tree' -> 'a tree',
        val 'a size : 'a tree' -> int}
> New type names: =tree'
  structure Tree :
  {datatype 'a tree =
     ('a tree',
      {con 'a Lf : 'a tree',
       con 'a Br : 'a * 'a tree' * 'a tree' -> 'a tree'}),
   con 'a Br : 'a * 'a tree' * 'a tree' -> 'a tree',
   con 'a Lf : 'a tree',
   val 'a depth : 'a tree' -> int,
   val 'a reflect : 'a tree' -> 'a tree',
   val 'a size : 'a tree' -> int}
> structure Braun :
  {structure Tree :
     {datatype 'a tree =
        ('a tree',
         {con 'a Lf : 'a tree',
          con 'a Br : 'a * 'a tree' * 'a tree' -> 'a tree'}),
      con 'a Br : 'a * 'a tree' * 'a tree' -> 'a tree',
      con 'a Lf : 'a tree',
      val 'a depth : 'a tree' -> int,
      val 'a reflect : 'a tree' -> 'a tree',
      val 'a size : 'a tree' -> int},
   val 'a delete : 'a tree' * int -> 'a tree',
   val 'a loext : 'a tree' * 'a -> 'a tree',
   val 'a lorem : 'a tree' -> 'a tree',
   val 'a sub : 'a tree' * int -> 'a,
   val 'a update : 'a tree' * int * 'a -> 'a tree'}
> New type names: =array'
  structure Flex :
  {type 'a array = 'a array',
   val 'a empty : 'a array',
   val 'a hiext : 'a array' * 'a -> 'a array',
   val 'a hirem : 'a array' -> 'a array',
   val 'a length : 'a array' -> int,
   val 'a loext : 'a array' * 'a -> 'a array',
   val 'a lorem : 'a array' -> 'a array',
   val 'a sub : 'a array' * int -> 'a,
   val 'a update : 'a array' * int * 'a -> 'a array'}
> New type names: t''''
  structure StringPQueue :
  {structure Item : {type t = string, val compare : string * string -> order},
   type t = t'''',
   val delmin : t'''' -> t'''',
   val empty : t'''',
   val fromList : string list -> t'''',
   val insert : string * t'''' -> t'''',
   val min : t'''' -> string,
   val null : t'''' -> bool,
   val sort : string list -> string list,
   val toList : t'''' -> string list}
[closing file "sample7.sml"]
> val it = () : unit
[opening file "sample8.sml"]
> val impFact = fn : int -> int
> val pFact = fn : int * int ref -> unit
> val 'a irev = fn : 'a list -> 'a list
> signature IMP_SEQUENCE =
  /\t'''''.
    {type 'a t = 'a t''''',
     exn Empty : exn,
     val 'a empty : 'a t''''',
     val 'a cons : 'a * (unit -> 'a t''''') -> 'a t''''',
     val 'a null : 'a t''''' -> bool,
     val 'a hd : 'a t''''' -> 'a,
     val 'a tl : 'a t''''' -> 'a t''''',
     val 'a take : 'a t''''' * int -> 'a list,
     val 'a toList : 'a t''''' -> 'a list,
     val 'a fromList : 'a list -> 'a t''''',
     val 'a @ : 'a t''''' * 'a t''''' -> 'a t''''',
     val 'a interleave : 'a t''''' * 'a t''''' -> 'a t''''',
     val 'a concat : 'a t''''' t''''' -> 'a t''''',
     val ('a, 'b) map : ('a -> 'b) -> 'a t''''' -> 'b t''''',
     val 'a filter : ('a -> bool) -> 'a t''''' -> 'a t''''',
     val 'a cycle : ((unit -> 'a t''''') -> 'a t''''') -> 'a t'''''}
File "sample8.sml", line 102-103, characters 6-49:
! ......null Nil = true
!     | null (Cons _) = false.
! Warning: pattern matching is not exhaustive

File "sample8.sml", line 105-106, characters 6-51:
! ......hd Nil = raise Empty
!     | hd (Cons(x,_)) = x.
! Warning: pattern matching is not exhaustive

File "sample8.sml", line 108-109, characters 6-59:
! ......tl Nil = raise Empty
!     | tl (Cons(_,xp)) = force xp.
! Warning: pattern matching is not exhaustive

File "sample8.sml", line 111-113, characters 6-103:
! ......take (xq, 0) = []
!     | take (Nil, n) = []
!     | take (Cons(x,xp), n) = x :: take (force xp, n-1).
! Warning: pattern matching is not exhaustive

File "sample8.sml", line 115-116, characters 6-72:
! ......toList Nil = []
!     | toList (Cons(x,xp)) = x :: toList (force xp).
! Warning: pattern matching is not exhaustive

File "sample8.sml", line 121-123, characters 6-87:
! ......Nil @ yq = yq
!     | (Cons(x,xp)) @ yq =
! 	  Cons(x, delay(fn()=> (force xp) @ yq)).
! Warning: pattern matching is not exhaustive

File "sample8.sml", line 125-127, characters 6-123:
! ......interleave (Nil,    yq) = yq
!     | interleave (Cons(x,xp), yq) = 
! 	  Cons(x, delay (fn()=> interleave(yq, force xp))).
! Warning: pattern matching is not exhaustive

File "sample8.sml", line 137-139, characters 6-102:
! ......map f Nil  = Nil
!     | map f (Cons(x,xp)) = 
!           Cons(f x, delay(fn()=> map f (force xp))).
! Warning: pattern matching is not exhaustive

File "sample8.sml", line 141-145, characters 6-166:
! ......filter pred Nil = Nil
!     | filter pred (Cons(x,xp)) =
! 	  if pred x 
!           then Cons(x, delay(fn()=> filter pred (force xp)))
! 	  else filter pred (force xp).
! Warning: pattern matching is not exhaustive

> New type names: t'''''
  structure ImpSeq :
  {type 'a t = 'a t''''',
   val 'a @ : 'a t''''' * 'a t''''' -> 'a t''''',
   exn Empty : exn,
   val 'a concat : 'a t''''' t''''' -> 'a t''''',
   val 'a cons : 'a * (unit -> 'a t''''') -> 'a t''''',
   val 'a cycle : ((unit -> 'a t''''') -> 'a t''''') -> 'a t''''',
   val 'a empty : 'a t''''',
   val 'a filter : ('a -> bool) -> 'a t''''' -> 'a t''''',
   val 'a fromList : 'a list -> 'a t''''',
   val 'a hd : 'a t''''' -> 'a,
   val 'a interleave : 'a t''''' * 'a t''''' -> 'a t''''',
   val ('a, 'b) map : ('a -> 'b) -> 'a t''''' -> 'b t''''',
   val 'a null : 'a t''''' -> bool,
   val 'a take : 'a t''''' * int -> 'a list,
   val 'a tl : 'a t''''' -> 'a t''''',
   val 'a toList : 'a t''''' -> 'a list}
> val ('a, 'b) pairs = fn : 'a t''''' * 'b t''''' -> ('a * 'b) t'''''
> val add = fn : int t''''' * int t''''' -> int t'''''
> val fib = <t> : int t'''''
> val it =
    [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584,
     4181, 6765, 10946, 17711, 28657, 46368, 75025, 121393, 196418, 317811,
     514229, 832040, 1346269, 2178309, 3524578, 5702887, 9227465, 14930352,
     24157817, 39088169, 63245986, 102334155] : int list
> signature RINGBUF =
  /\=t''''''.
    {type 'a t = 'a t'''''',
     exn Empty : exn,
     val 'a empty : unit -> 'a t'''''',
     val 'a null : 'a t'''''' -> bool,
     val 'a label : 'a t'''''' -> 'a,
     val 'a moveLeft : 'a t'''''' -> unit,
     val 'a moveRight : 'a t'''''' -> unit,
     val 'a insert : 'a t'''''' * 'a -> unit,
     val 'a delete : 'a t'''''' -> 'a}
> New type names: =t''''''
  structure RingBuf :
  {type 'a t = 'a t'''''',
   exn Empty : exn,
   val 'a delete : 'a t'''''' -> 'a,
   val 'a empty : unit -> 'a t'''''',
   val 'a insert : 'a t'''''' * 'a -> unit,
   val 'a label : 'a t'''''' -> 'a,
   val 'a moveLeft : 'a t'''''' -> unit,
   val 'a moveRight : 'a t'''''' -> unit,
   val 'a null : 'a t'''''' -> bool}
> signature VARRAY =
  /\t'''''''.
    {type 'a t = 'a t''''''',
     val 'a array : int * 'a -> 'a t''''''',
     val 'a reroot : 'a t''''''' -> 'a t''''''',
     val 'a sub : 'a t''''''' * int -> 'a,
     val 'a justUpdate : 'a t''''''' * int * 'a -> 'a t''''''',
     val 'a update : 'a t''''''' * int * 'a -> 'a t'''''''}
File "sample8.sml", line 280, characters 12-20:
! 	       val Main ary = !bnext
! 	           ^^^^^^^^
! Warning: pattern matching is not exhaustive

File "sample8.sml", line 278, characters 12-57:
! 	   let val Modif{index=bindex,elem=belem,next=bnext,...} =
! 	           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Warning: pattern matching is not exhaustive

File "sample8.sml", line 274-287, characters 6-417:
! ......reroot (va as Modif{index, elem, next,...}) =
!       case !next of
! 	 Main _ => va  (*have reached root*)
!        | Modif _ => 
! ..........
! 	       next := !bnext;
! 	       bnext := va;
! 	       va
! 	   end.
! Warning: pattern matching is not exhaustive

File "sample8.sml", line 290-294, characters 6-168:
! ......sub (Modif{index,elem,next,...}, i) =
!        case !next of
! 	  Main ary => Array.sub(ary,i)
! 	| Modif _ =>    if !index = i then !elem  
! 				      else sub(!next,i).
! Warning: pattern matching is not exhaustive

File "sample8.sml", line 297-301, characters 6-169:
! ......justUpdate(va as Modif{limit,...}, i, x) = 
! 	if  0<=i andalso i<limit  
! 	then Modif{limit=limit, index= ref i, 
! 		   elem=ref x, next=ref va}
! 	else raise Subscript.
! Warning: pattern matching is not exhaustive

> New type names: t'''''''
  structure Varray :
  {type 'a t = 'a t''''''',
   val 'a array : int * 'a -> 'a t''''''',
   val 'a justUpdate : 'a t''''''' * int * 'a -> 'a t''''''',
   val 'a reroot : 'a t''''''' -> 'a t''''''',
   val 'a sub : 'a t''''''' * int -> 'a,
   val 'a update : 'a t''''''' * int * 'a -> 'a t'''''''}
> val months =
    ["JAN", "FEB", "MAR", "APR", "MAY", "JUN", "JUL", "AUG", "SEP", "OCT",
     "NOV", "DEC"] : string list
File "sample8.sml", line 322, characters 10-19:
!       val SOME year = Int.fromString syear
!           ^^^^^^^^^
! Warning: pattern matching is not exhaustive

File "sample8.sml", line 320, characters 10-18:
!       val SOME day = Int.fromString sday
!           ^^^^^^^^
! Warning: pattern matching is not exhaustive

File "sample8.sml", line 319, characters 10-30:
!   let val sday::smon::syear::_ = String.tokens (fn c => c = #"-") s
!           ^^^^^^^^^^^^^^^^^^^^
! Warning: pattern matching is not exhaustive

> val dateFromString = fn : string -> (int * string * int) option
> val firstChar = fn : string -> char
> val initials = fn : string -> string
> val it = "Mritfawt" : string
> val batchInitials = fn : instream * outstream -> unit
> val promptInitials = fn : instream * outstream -> unit
> val firstLine = fn : string -> string
> val htmlCvt = fn : string -> unit
> signature PRETTY =
  /\t''''''''.
    {type t = t'''''''',
     val blo : int * t'''''''' list -> t'''''''',
     val str : string -> t'''''''',
     val brk : int -> t'''''''',
     val pr : outstream * t'''''''' * int -> unit}
> New type names: =t''''''''
  structure Pretty :
  {type t = t'''''''',
   val blo : int * t'''''''' list -> t'''''''',
   val brk : int -> t'''''''',
   val pr : outstream * t'''''''' * int -> unit,
   val str : string -> t''''''''}
> val prettyshow = fn : prop -> t''''''''
[closing file "sample8.sml"]
> val it = () : unit
[opening file "sample9.sml"]
> signature KEYWORD = {val alphas : string list, val symbols : string list}
> signature LEXICAL =
  /\=token.
    {datatype token =
       (token,{con Key : string -> token, con Id : string -> token}),
     con Key : string -> token,
     con Id : string -> token,
     val scan : string -> token list}
> functor Lexical :
  {val alphas : string list, val symbols : string list}->
      ?=token.
       {datatype token =
          (token,{con Key : string -> token, con Id : string -> token}),
        con Id : string -> token,
        con Key : string -> token,
        val scan : string -> token list}
> infix 6 $--
> infix 5 --
> infix 3 >>
> infix 0 ||
> signature PARSE =
  /\token.
    {exn SyntaxErr : string -> exn,
     type token = token,
     val id : token list -> string * token list,
     val $ : string -> token list -> string * token list,
     val ('b, 'a) empty : 'a -> 'b list * 'a,
     val ('a, 'b) || : ('a -> 'b) * ('a -> 'b) -> 'a -> 'b,
     val ('a, 'b, 'c) !! : ('a -> 'b * 'c) -> 'a -> 'b * 'c,
     val ('c, 'a, 'b, 'd, 'e) -- :
       ('a -> 'b * 'c) * ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e,
     val ('a, 'b) $-- :
       string * (token list -> 'a * 'b) -> token list -> 'a * 'b,
     val ('b, 'a, 'd, 'c) >> : ('a -> 'b * 'c) * ('b -> 'd) -> 'a -> 'd * 'c,
     val ('b, 'a) repeat : ('a -> 'b * 'a) -> 'a -> 'b list * 'a,
     val 'a infixes :
       (token list -> 'a * token list) * (string -> int) *
       (string -> 'a -> 'a -> 'a) -> token list -> 'a * token list,
     val ('b, 'a) reader : (token list -> 'a * 'b list) -> string -> 'a}
> functor Parsing :
  !=token.
   {datatype token =
      (token,{con Key : string -> token, con Id : string -> token}),
    con Key : string -> token,
    con Id : string -> token,
    val scan : string -> token list}->
       {type token = token,
        val ('a, 'b, 'c) !! : ('a -> 'b * 'c) -> 'a -> 'b * 'c,
        val $ : string -> token list -> string * token list,
        val ('a, 'b) $-- :
          string * (token list -> 'a * 'b) -> token list -> 'a * 'b,
        val ('c, 'a, 'b, 'd, 'e) -- :
          ('a -> 'b * 'c) * ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e,
        val ('b, 'a, 'd, 'c) >> :
          ('a -> 'b * 'c) * ('b -> 'd) -> 'a -> 'd * 'c,
        exn SyntaxErr : string -> exn,
        val ('b, 'a) empty : 'a -> 'b list * 'a,
        val id : token list -> string * token list,
        val 'a infixes :
          (token list -> 'a * token list) * (string -> int) *
          (string -> 'a -> 'a -> 'a) -> token list -> 'a * token list,
        val ('b, 'a) reader : (token list -> 'a * 'b list) -> string -> 'a,
        val ('b, 'a) repeat : ('a -> 'b * 'a) -> 'a -> 'b list * 'a,
        val ('a, 'b) || : ('a -> 'b) * ('a -> 'b) -> 'a -> 'b}
> signature TYPE =
  /\=t'''''''''.
    {datatype t =
       (t''''''''',
        {con Con : string * t''''''''' list -> t''''''''',
         con Var : string -> t'''''''''}),
     con Con : string * t''''''''' list -> t''''''''',
     con Var : string -> t''''''''',
     val pr : t''''''''' -> unit,
     val read : string -> t'''''''''}
> structure LamKey : {val 'a alphas : 'a list, val symbols : string list}
> New type names: =token
  structure LamLex :
  {datatype token =
     (token,{con Key : string -> token, con Id : string -> token}),
   con Id : string -> token,
   con Key : string -> token,
   val scan : string -> token list}
> structure LamParsing :
  {type token = token,
   val ('a, 'b, 'c) !! : ('a -> 'b * 'c) -> 'a -> 'b * 'c,
   val $ : string -> token list -> string * token list,
   val ('a, 'b) $-- :
     string * (token list -> 'a * 'b) -> token list -> 'a * 'b,
   val ('c, 'a, 'b, 'd, 'e) -- :
     ('a -> 'b * 'c) * ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e,
   val ('b, 'a, 'd, 'c) >> : ('a -> 'b * 'c) * ('b -> 'd) -> 'a -> 'd * 'c,
   exn SyntaxErr : string -> exn,
   val ('b, 'a) empty : 'a -> 'b list * 'a,
   val id : token list -> string * token list,
   val 'a infixes :
     (token list -> 'a * token list) * (string -> int) *
     (string -> 'a -> 'a -> 'a) -> token list -> 'a * token list,
   val ('b, 'a) reader : (token list -> 'a * 'b list) -> string -> 'a,
   val ('b, 'a) repeat : ('a -> 'b * 'a) -> 'a -> 'b list * 'a,
   val ('a, 'b) || : ('a -> 'b) * ('a -> 'b) -> 'a -> 'b}
File "sample9.sml", line 212-216, characters 8-161:
! ........typ (Var a) = Pretty.str a
!       | typ (Con("->",[ty1,ty2])) = Pretty.blo(0, [atom ty1, 
! 						 Pretty.str " ->", 
! 						 Pretty.brk 1, 
! 						 typ ty2])
! Warning: pattern matching is not exhaustive

> New type names: =t'''''''''
  structure Type :
  {datatype t =
     (t''''''''',
      {con Con : string * t''''''''' list -> t''''''''',
       con Var : string -> t'''''''''}),
   con Con : string * t''''''''' list -> t''''''''',
   con Var : string -> t''''''''',
   val pr : t''''''''' -> unit,
   val read : string -> t'''''''''}
> signature LAMBDA =
  /\=t''''''''''.
    {datatype t =
       (t'''''''''',
        {con Free : string -> t'''''''''',
         con Bound : int -> t'''''''''',
         con Abs : string * t'''''''''' -> t'''''''''',
         con Apply : t'''''''''' * t'''''''''' -> t''''''''''}),
     con Free : string -> t'''''''''',
     con Bound : int -> t'''''''''',
     con Abs : string * t'''''''''' -> t'''''''''',
     con Apply : t'''''''''' * t'''''''''' -> t'''''''''',
     val abstract : int -> string -> t'''''''''' -> t'''''''''',
     val absList : string list * t'''''''''' -> t'''''''''',
     val applyList : t'''''''''' * t'''''''''' list -> t'''''''''',
     val subst : int -> t'''''''''' -> t'''''''''' -> t'''''''''',
     val inst : t'''''''''' t''' -> t'''''''''' -> t''''''''''}
> New type names: =t''''''''''
  structure Lambda :
  {datatype t =
     (t'''''''''',
      {con Free : string -> t'''''''''',
       con Bound : int -> t'''''''''',
       con Abs : string * t'''''''''' -> t'''''''''',
       con Apply : t'''''''''' * t'''''''''' -> t''''''''''}),
   con Abs : string * t'''''''''' -> t'''''''''',
   con Apply : t'''''''''' * t'''''''''' -> t'''''''''',
   con Bound : int -> t'''''''''',
   con Free : string -> t'''''''''',
   val absList : string list * t'''''''''' -> t'''''''''',
   val abstract : int -> string -> t'''''''''' -> t'''''''''',
   val applyList : t'''''''''' * t'''''''''' list -> t'''''''''',
   val inst : t'''''''''' t''' -> t'''''''''' -> t'''''''''',
   val subst : int -> t'''''''''' -> t'''''''''' -> t''''''''''}
> signature PARSE_TERM = {val read : string -> t''''''''''}
> structure ParseTerm : {val read : string -> t''''''''''}
> signature DISPLAY_TERM =
  {val rename : string list * string -> string,
   val stripAbs : t'''''''''' -> string list * t'''''''''',
   val pr : t'''''''''' -> unit}
File "sample9.sml", line 352, characters 11-20:
! 	  let val (b::bs,u) = stripAbs t
! 	          ^^^^^^^^^
! Warning: pattern matching is not exhaustive

> structure DisplayTerm :
  {val pr : t'''''''''' -> unit,
   val rename : string list * string -> string,
   val stripAbs : t'''''''''' -> string list * t''''''''''}
> signature REDUCE =
  {val eval : t'''''''''' -> t'''''''''',
   val byValue : t'''''''''' -> t'''''''''',
   val headNF : t'''''''''' -> t'''''''''',
   val byName : t'''''''''' -> t''''''''''}
> structure Reduce :
  {val byName : t'''''''''' -> t'''''''''',
   val byValue : t'''''''''' -> t'''''''''',
   val eval : t'''''''''' -> t'''''''''',
   val headNF : t'''''''''' -> t''''''''''}
> val insertEnv = fn : (string * string) * t'''''''''' t''' -> t'''''''''' t'''
> val stdEnv = <t> : t'''''''''' t'''
> val stdRead = fn : string -> t''''''''''
> val try = fn : (t'''''''''' -> t'''''''''') -> string -> unit
[closing file "sample9.sml"]
> val it = () : unit
[opening file "sample10.sml"]
> signature FOL =
  /\=term =form.
    {datatype term =
       (term,
        {con Var : string -> term,
         con Param : string * string list -> term,
         con Bound : int -> term,
         con Fun : string * term list -> term}),
     con Var : string -> term,
     con Param : string * string list -> term,
     con Bound : int -> term,
     con Fun : string * term list -> term,
     datatype form =
       (form,
        {con Pred : string * term list -> form,
         con Conn : string * form list -> form,
         con Quant : string * string * form -> form}),
     con Pred : string * term list -> form,
     con Conn : string * form list -> form,
     con Quant : string * string * form -> form,
     type goal = form list * form list,
     val precOf : string -> int,
     val abstract : int -> term -> form -> form,
     val subst : int -> term -> form -> form,
     val termVars : term * string list -> string list,
     val goalVars : (form list * form list) * string list -> string list,
     val termParams :
       term * (string * string list) list -> (string * string list) list,
     val goalParams :
       (form list * form list) * (string * string list) list ->
       (string * string list) list}
> New type names: =term, =form
  structure Fol :
  {datatype term =
     (term,
      {con Var : string -> term,
       con Param : string * string list -> term,
       con Bound : int -> term,
       con Fun : string * term list -> term}),
   datatype form =
     (form,
      {con Pred : string * term list -> form,
       con Conn : string * form list -> form,
       con Quant : string * string * form -> form}),
   type goal = form list * form list,
   con Bound : int -> term,
   con Conn : string * form list -> form,
   con Fun : string * term list -> term,
   con Param : string * string list -> term,
   con Pred : string * term list -> form,
   con Quant : string * string * form -> form,
   con Var : string -> term,
   val abstract : int -> term -> form -> form,
   val goalParams :
     (form list * form list) * (string * string list) list ->
     (string * string list) list,
   val goalVars : (form list * form list) * string list -> string list,
   val precOf : string -> int,
   val subst : int -> term -> form -> form,
   val termParams :
     term * (string * string list) list -> (string * string list) list,
   val termVars : term * string list -> string list}
> structure FolKey : {val alphas : string list, val symbols : string list}
> New type names: =token'
  structure FolLex :
  {datatype token =
     (token',{con Key : string -> token', con Id : string -> token'}),
   con Id : string -> token',
   con Key : string -> token',
   val scan : string -> token' list}
> structure FolParsing :
  {type token = token',
   val ('a, 'b, 'c) !! : ('a -> 'b * 'c) -> 'a -> 'b * 'c,
   val $ : string -> token' list -> string * token' list,
   val ('a, 'b) $-- :
     string * (token' list -> 'a * 'b) -> token' list -> 'a * 'b,
   val ('c, 'a, 'b, 'd, 'e) -- :
     ('a -> 'b * 'c) * ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e,
   val ('b, 'a, 'd, 'c) >> : ('a -> 'b * 'c) * ('b -> 'd) -> 'a -> 'd * 'c,
   exn SyntaxErr : string -> exn,
   val ('b, 'a) empty : 'a -> 'b list * 'a,
   val id : token' list -> string * token' list,
   val 'a infixes :
     (token' list -> 'a * token' list) * (string -> int) *
     (string -> 'a -> 'a -> 'a) -> token' list -> 'a * token' list,
   val ('b, 'a) reader : (token' list -> 'a * 'b list) -> string -> 'a,
   val ('b, 'a) repeat : ('a -> 'b * 'a) -> 'a -> 'b list * 'a,
   val ('a, 'b) || : ('a -> 'b) * ('a -> 'b) -> 'a -> 'b}
> signature PARSE_FOL = {val read : string -> form}
> structure ParseFol : {val read : string -> form}
> signature DISPLAY_FOL =
  {val form : form -> unit, val goal : int -> form list * form list -> unit}
File "sample10.sml", line 192, characters 6-62:
!   fun list (sexp::sexps) = Pretty.blo(0, sexp :: commas sexps);  
!       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Warning: pattern matching is not exhaustive

> structure DisplayFol :
  {val form : form -> unit, val goal : int -> form list * form list -> unit}
> signature UNIFY =
  {exn Failed : exn,
   val atoms : form * form -> term t''',
   val instTerm : term t''' -> term -> term,
   val instForm : term t''' -> form -> form,
   val instGoal : term t''' -> form list * form list -> form list * form list}
> structure Unify :
  {exn Failed : exn,
   val atoms : form * form -> term t''',
   val instForm : term t''' -> form -> form,
   val instGoal : term t''' -> form list * form list -> form list * form list,
   val instTerm : term t''' -> term -> term}
> signature RULE =
  /\state.
    {type state = state,
     type tactic = state -> state t''''',
     val main : state -> form,
     val subgoals : state -> (form list * form list) list,
     val initial : form -> state,
     val final : state -> bool,
     val basic : int -> state -> state t''''',
     val unify : int -> state -> state t''''',
     val conjL : int -> state -> state t''''',
     val conjR : int -> state -> state t''''',
     val disjL : int -> state -> state t''''',
     val disjR : int -> state -> state t''''',
     val impL : int -> state -> state t''''',
     val impR : int -> state -> state t''''',
     val negL : int -> state -> state t''''',
     val negR : int -> state -> state t''''',
     val iffL : int -> state -> state t''''',
     val iffR : int -> state -> state t''''',
     val allL : int -> state -> state t''''',
     val allR : int -> state -> state t''''',
     val exL : int -> state -> state t''''',
     val exR : int -> state -> state t'''''}
File "sample10.sml", line 409, characters 25-69:
!   val conjL = propL "&" (fn (([p1,p2], ps), qs) => [(p1::p2::ps, qs)]);
!                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Warning: pattern matching is not exhaustive

File "sample10.sml", line 412, characters 7-62:
!       (fn (ps, ([q1,q2], qs)) => [(ps, q1::qs),  (ps, q2::qs)]);
!        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Warning: pattern matching is not exhaustive

File "sample10.sml", line 415, characters 7-62:
!       (fn (([p1,p2], ps), qs) => [(p1::ps, qs),  (p2::ps, qs)]);
!        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Warning: pattern matching is not exhaustive

File "sample10.sml", line 417, characters 25-69:
!   val disjR = propR "|" (fn (ps, ([q1,q2], qs)) => [(ps, q1::q2::qs)]);
!                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Warning: pattern matching is not exhaustive

File "sample10.sml", line 420, characters 7-62:
!       (fn (([p1,p2], ps), qs) => [(p2::ps, qs),  (ps, p1::qs)]);
!        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Warning: pattern matching is not exhaustive

File "sample10.sml", line 422, characters 26-70:
!   val impR = propR "-->" (fn (ps, ([q1,q2], qs)) => [(q1::ps, q2::qs)]);
!                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Warning: pattern matching is not exhaustive

File "sample10.sml", line 424, characters 24-59:
!   val negL = propL "~" (fn (([p], ps), qs) => [(ps, p::qs)]);
!                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Warning: pattern matching is not exhaustive

File "sample10.sml", line 426, characters 24-59:
!   val negR = propR "~" (fn (ps, ([q], qs)) => [(q::ps, qs)]);
!                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Warning: pattern matching is not exhaustive

File "sample10.sml", line 429, characters 7-70:
!       (fn (([p1,p2], ps), qs) => [(p1::p2::ps, qs),  (ps, p1::p2::qs)]);
!        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Warning: pattern matching is not exhaustive

File "sample10.sml", line 432, characters 7-70:
!       (fn (ps, ([q1,q2], qs)) => [(q1::ps, q2::qs),  (q2::ps, q1::qs)]);
!        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Warning: pattern matching is not exhaustive

File "sample10.sml", line 461, characters 14-48:
!       let val (qntForm as Fol.Quant(_,_,p), ps') = splitQuant "ALL" ps
!               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Warning: pattern matching is not exhaustive

File "sample10.sml", line 466, characters 14-37:
!       let val (Fol.Quant(_,_,q), qs') = splitQuant "ALL" qs
!               ^^^^^^^^^^^^^^^^^^^^^^^
! Warning: pattern matching is not exhaustive

File "sample10.sml", line 472, characters 14-37:
!       let val (Fol.Quant(_,_,p), ps') = splitQuant "EX" ps
!               ^^^^^^^^^^^^^^^^^^^^^^^
! Warning: pattern matching is not exhaustive

File "sample10.sml", line 478, characters 14-48:
!       let val (qntForm as Fol.Quant(_,_,q), qs') = splitQuant "EX" qs
!               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Warning: pattern matching is not exhaustive

> New type names: state
  structure Rule :
  {type state = state,
   type tactic = state -> state t''''',
   val allL : int -> state -> state t''''',
   val allR : int -> state -> state t''''',
   val basic : int -> state -> state t''''',
   val conjL : int -> state -> state t''''',
   val conjR : int -> state -> state t''''',
   val disjL : int -> state -> state t''''',
   val disjR : int -> state -> state t''''',
   val exL : int -> state -> state t''''',
   val exR : int -> state -> state t''''',
   val final : state -> bool,
   val iffL : int -> state -> state t''''',
   val iffR : int -> state -> state t''''',
   val impL : int -> state -> state t''''',
   val impR : int -> state -> state t''''',
   val initial : form -> state,
   val main : state -> form,
   val negL : int -> state -> state t''''',
   val negR : int -> state -> state t''''',
   val subgoals : state -> (form list * form list) list,
   val unify : int -> state -> state t'''''}
> signature COMMAND =
  {val goal : string -> unit,
   val by : (state -> state t''''') -> unit,
   val pr : state -> unit,
   val getState : unit -> state}
> structure Command :
  {val by : (state -> state t''''') -> unit,
   val getState : unit -> state,
   val goal : string -> unit,
   val pr : state -> unit}
> infix 0 |@|
> signature TACTICAL =
  /\multifun.
    {type ('a, 'b) multifun = ('a, 'b) multifun,
     val ('b, 'a, 'c) -- :
       ('a, 'b) multifun * ('b, 'c) multifun -> ('a, 'c) multifun,
     val ('a, 'b) || :
       ('a, 'b) multifun * ('a, 'b) multifun -> ('a, 'b) multifun,
     val ('a, 'b) |@| :
       ('a, 'b) multifun * ('a, 'b) multifun -> ('a, 'b) multifun,
     val 'a all : ('a, 'a) multifun,
     val ('a, 'b) no : ('a, 'b) multifun,
     val 'a try : ('a, 'a) multifun -> ('a, 'a) multifun,
     val 'a repeat : ('a, 'a) multifun -> ('a, 'a) multifun,
     val 'a repeatDeterm : ('a, 'a) multifun -> ('a, 'a) multifun,
     val 'a depthFirst :
       ('a -> bool) -> ('a, 'a) multifun -> ('a, 'a) multifun,
     val 'a depthIter :
       ('a -> bool) * int -> ('a, 'a) multifun -> ('a, 'a) multifun,
     val ('a, 'b, 'c) firstF :
       ('a -> ('b, 'c) multifun) list -> 'a -> ('b, 'c) multifun}
> structure Tactical :
  {type ('a, 'b) multifun = 'a -> 'b t''''',
   val ('b, 'a, 'c) -- :
     ('a -> 'b t''''') * ('b -> 'c t''''') -> 'a -> 'c t''''',
   val 'a all : 'a -> 'a t''''',
   val 'a depthFirst : ('a -> bool) -> ('a -> 'a t''''') -> 'a -> 'a t''''',
   val 'a depthIter :
     ('a -> bool) * int -> ('a -> 'a t''''') -> 'a -> 'a t''''',
   val ('a, 'b, 'c) firstF :
     ('a -> 'b -> 'c t''''') list -> 'a -> 'b -> 'c t''''',
   val ('a, 'b) no : 'a -> 'b t''''',
   val 'a repeat : ('a -> 'a t''''') -> 'a -> 'a t''''',
   val 'a repeatDeterm : ('a -> 'a t''''') -> 'a -> 'a t''''',
   val 'a try : ('a -> 'a t''''') -> 'a -> 'a t''''',
   val ('a, 'b) |@| : ('a -> 'b t''''') * ('a -> 'b t''''') -> 'a -> 'b t''''',
   val ('a, 'b) || : ('a -> 'b t''''') * ('a -> 'b t''''') -> 'a -> 'b t'''''}
> signature TAC =
  {val safeSteps : int -> state -> state t''''',
   val quant : int -> state -> state t''''',
   val step : int -> state -> state t''''',
   val depth : state -> state t''''',
   val depthIt : int -> state -> state t'''''}
> structure Tac :
  {val depth : state -> state t''''',
   val depthIt : int -> state -> state t''''',
   val quant : int -> state -> state t''''',
   val safeSteps : int -> state -> state t''''',
   val step : int -> state -> state t'''''}
[closing file "sample10.sml"]
> val it = () : unit
[opening file "test10.sml"]
> val by = fn : (state -> state t''''') -> unit
  val getState = fn : unit -> state
  val goal = fn : string -> unit
  val pr = fn : state -> unit
> type ('a, 'b) multifun = 'a -> 'b t'''''
  val ('b, 'a, 'c) -- = fn :
  ('a -> 'b t''''') * ('b -> 'c t''''') -> 'a -> 'c t'''''
  val 'a all = fn : 'a -> 'a t'''''
  val 'a depthFirst = fn : ('a -> bool) -> ('a -> 'a t''''') -> 'a -> 'a t'''''
  val 'a depthIter = fn :
  ('a -> bool) * int -> ('a -> 'a t''''') -> 'a -> 'a t'''''
  val ('a, 'b, 'c) firstF = fn :
  ('a -> 'b -> 'c t''''') list -> 'a -> 'b -> 'c t'''''
  val ('a, 'b) no = fn : 'a -> 'b t'''''
  val 'a repeat = fn : ('a -> 'a t''''') -> 'a -> 'a t'''''
  val 'a repeatDeterm = fn : ('a -> 'a t''''') -> 'a -> 'a t'''''
  val 'a try = fn : ('a -> 'a t''''') -> 'a -> 'a t'''''
  val ('a, 'b) |@| = fn :
  ('a -> 'b t''''') * ('a -> 'b t''''') -> 'a -> 'b t'''''
  val ('a, 'b) || = fn :
  ('a -> 'b t''''') * ('a -> 'b t''''') -> 'a -> 'b t'''''
> val showResult = fn : unit -> unit
> val checkFailed = fn : unit -> string
P & Q --> Q & P
 1. empty  |-  P & Q --> Q & P
> val it = () : unit
P & Q --> Q & P
 1. P & Q  |-  Q & P
> val it = () : unit
P & Q --> Q & P
 1. P, Q  |-  Q & P
> val it = () : unit
P & Q --> Q & P
 1. P, Q  |-  Q
 2. P, Q  |-  P
> val it = () : unit
P & Q --> Q & P
 1. P, Q  |-  Q
> val it = () : unit
P & Q --> Q & P
No subgoals left!
> val it = () : unit
P & Q --> Q & P
> val it = () : unit
(ALL x. P(x)) --> (ALL x. P(x) | Q(x))
 1. empty
    |-  (ALL x. P(x)) --> (ALL x. P(x) | Q(x))
> val it = () : unit
(ALL x. P(x)) --> (ALL x. P(x) | Q(x))
 1. ALL x. P(x)  |-  ALL x. P(x) | Q(x)
> val it = () : unit
(ALL x. P(x)) --> (ALL x. P(x) | Q(x))
 1. ALL x. P(x)  |-  P(_a) | Q(_a)
> val it = () : unit
(ALL x. P(x)) --> (ALL x. P(x) | Q(x))
 1. ALL x. P(x)  |-  P(_a), Q(_a)
> val it = () : unit
(ALL x. P(x)) --> (ALL x. P(x) | Q(x))
 1. P(?_b), ALL x. P(x)  |-  P(_a), Q(_a)
> val it = () : unit
(ALL x. P(x)) --> (ALL x. P(x) | Q(x))
No subgoals left!
> val it = () : unit
(ALL x. P(x)) --> (ALL x. P(x) | Q(x))
> val it = () : unit
EX z. P(z) --> (ALL x. P(x))
 1. empty  |-  EX z. P(z) --> (ALL x. P(x))
> val it = () : unit
EX z. P(z) --> (ALL x. P(x))
 1. empty
    |-  P(?_a) --> (ALL x. P(x)),
        EX z. P(z) --> (ALL x. P(x))
> val it = () : unit
EX z. P(z) --> (ALL x. P(x))
 1. P(?_a)
    |-  ALL x. P(x), EX z. P(z) --> (ALL x. P(x))
> val it = () : unit
EX z. P(z) --> (ALL x. P(x))
 1. P(?_a)
    |-  P(_b), EX z. P(z) --> (ALL x. P(x))
_b not in  ?_a
> val it = () : unit
** Tactic FAILED! **
> val it = () : unit
EX z. P(z) --> (ALL x. P(x))
 1. P(?_a)
    |-  P(?_c) --> (ALL x. P(x)), P(_b),
        EX z. P(z) --> (ALL x. P(x))
_b not in  ?_a
> val it = () : unit
EX z. P(z) --> (ALL x. P(x))
 1. P(?_c), P(?_a)
    |-  ALL x. P(x), P(_b),
        EX z. P(z) --> (ALL x. P(x))
_b not in  ?_a
> val it = () : unit
EX z. P(z) --> (ALL x. P(x))
No subgoals left!
> val it = () : unit
EX z. P(z) --> (ALL x. P(x))
> val it = () : unit
(P & Q) & R --> P & (Q & R)
 1. empty  |-  (P & Q) & R --> P & (Q & R)
> val it = () : unit
(P & Q) & R --> P & (Q & R)
 1. (P & Q) & R  |-  P & (Q & R)
> val it = () : unit
(P & Q) & R --> P & (Q & R)
 1. P & Q, R  |-  P & (Q & R)
> val it = () : unit
(P & Q) & R --> P & (Q & R)
 1. P, Q, R  |-  P & (Q & R)
> val it = () : unit
(P & Q) & R --> P & (Q & R)
 1. P, Q, R  |-  P
 2. P, Q, R  |-  Q & R
> val it = () : unit
(P & Q) & R --> P & (Q & R)
 1. P, Q, R  |-  P
 2. P, Q, R  |-  Q
 3. P, Q, R  |-  R
> val it = () : unit
(P & Q) & R --> P & (Q & R)
 1. P, Q, R  |-  Q
 2. P, Q, R  |-  R
> val it = () : unit
(P & Q) & R --> P & (Q & R)
 1. P, Q, R  |-  R
> val it = () : unit
(P & Q) & R --> P & (Q & R)
No subgoals left!
> val it = () : unit
(P & Q) & R --> P & (Q & R)
> val it = () : unit
(P & Q) & R --> P & (Q & R)
 1. empty  |-  (P & Q) & R --> P & (Q & R)
> val it = () : unit
(P & Q) & R --> P & (Q & R)
 1. P, Q, R  |-  P & (Q & R)
> val it = () : unit
(P & Q) & R --> P & (Q & R)
No subgoals left!
> val it = () : unit
(P & Q) & R --> P & (Q & R)
> val it = () : unit
EX z. P(z) --> (ALL x. P(x))
 1. empty  |-  EX z. P(z) --> (ALL x. P(x))
> val it = () : unit
EX z. P(z) --> (ALL x. P(x))
No subgoals left!
> val it = () : unit
EX z. P(z) --> (ALL x. P(x))
> val it = () : unit
P & Q | R --> (P | R) & (Q | R)
 1. empty  |-  P & Q | R --> (P | R) & (Q | R)
> val it = () : unit
P & Q | R --> (P | R) & (Q | R)
 1. P & Q | R  |-  (P | R) & (Q | R)
> val it = () : unit
P & Q | R --> (P | R) & (Q | R)
 1. P & Q  |-  (P | R) & (Q | R)
 2. R  |-  (P | R) & (Q | R)
> val it = () : unit
P & Q | R --> (P | R) & (Q | R)
 1. P, Q  |-  (P | R) & (Q | R)
 2. R  |-  (P | R) & (Q | R)
> val it = () : unit
P & Q | R --> (P | R) & (Q | R)
 1. P, Q  |-  P | R
 2. P, Q  |-  Q | R
 3. R  |-  (P | R) & (Q | R)
> val it = () : unit
P & Q | R --> (P | R) & (Q | R)
 1. P, Q  |-  P, R
 2. P, Q  |-  Q | R
 3. R  |-  (P | R) & (Q | R)
> val it = () : unit
P & Q | R --> (P | R) & (Q | R)
 1. P, Q  |-  P, R
 2. P, Q  |-  Q, R
 3. R  |-  (P | R) & (Q | R)
> val it = () : unit
P & Q | R --> (P | R) & (Q | R)
 1. P, Q  |-  P, R
 2. P, Q  |-  Q, R
 3. R  |-  P | R
 4. R  |-  Q | R
> val it = () : unit
P & Q | R --> (P | R) & (Q | R)
 1. P, Q  |-  P, R
 2. P, Q  |-  Q, R
 3. R  |-  P, R
 4. R  |-  Q | R
> val it = () : unit
P & Q | R --> (P | R) & (Q | R)
 1. P, Q  |-  P, R
 2. P, Q  |-  Q, R
 3. R  |-  P, R
 4. R  |-  Q, R
> val it = () : unit
P & Q | R --> (P | R) & (Q | R)
 1. P, Q  |-  Q, R
 2. R  |-  P, R
 3. R  |-  Q, R
> val it = () : unit
P & Q | R --> (P | R) & (Q | R)
 1. R  |-  P, R
 2. R  |-  Q, R
> val it = () : unit
P & Q | R --> (P | R) & (Q | R)
 1. R  |-  Q, R
> val it = () : unit
P & Q | R --> (P | R) & (Q | R)
No subgoals left!
> val it = () : unit
P & Q | R --> (P | R) & (Q | R)
> val it = () : unit
(ALL x. P(x) & Q(x)) <->
(ALL x. P(x)) & (ALL x. Q(x))
 1. empty
    |-  (ALL x. P(x) & Q(x)) <->
        (ALL x. P(x)) & (ALL x. Q(x))
> val it = () : unit
(ALL x. P(x) & Q(x)) <->
(ALL x. P(x)) & (ALL x. Q(x))
 1. ALL x. P(x) & Q(x)
    |-  (ALL x. P(x)) & (ALL x. Q(x))
 2. (ALL x. P(x)) & (ALL x. Q(x))
    |-  ALL x. P(x) & Q(x)
> val it = () : unit
(ALL x. P(x) & Q(x)) <->
(ALL x. P(x)) & (ALL x. Q(x))
 1. ALL x. P(x) & Q(x)  |-  ALL x. P(x)
 2. ALL x. P(x) & Q(x)  |-  ALL x. Q(x)
 3. (ALL x. P(x)) & (ALL x. Q(x))
    |-  ALL x. P(x) & Q(x)
> val it = () : unit
(ALL x. P(x) & Q(x)) <->
(ALL x. P(x)) & (ALL x. Q(x))
 1. ALL x. P(x) & Q(x)  |-  P(_a)
 2. ALL x. P(x) & Q(x)  |-  ALL x. Q(x)
 3. (ALL x. P(x)) & (ALL x. Q(x))
    |-  ALL x. P(x) & Q(x)
> val it = () : unit
(ALL x. P(x) & Q(x)) <->
(ALL x. P(x)) & (ALL x. Q(x))
 1. P(?_b) & Q(?_b), ALL x. P(x) & Q(x)  |-  P(_a)
 2. ALL x. P(x) & Q(x)  |-  ALL x. Q(x)
 3. (ALL x. P(x)) & (ALL x. Q(x))
    |-  ALL x. P(x) & Q(x)
> val it = () : unit
(ALL x. P(x) & Q(x)) <->
(ALL x. P(x)) & (ALL x. Q(x))
 1. P(?_b), Q(?_b), ALL x. P(x) & Q(x)  |-  P(_a)
 2. ALL x. P(x) & Q(x)  |-  ALL x. Q(x)
 3. (ALL x. P(x)) & (ALL x. Q(x))
    |-  ALL x. P(x) & Q(x)
> val it = () : unit
(ALL x. P(x) & Q(x)) <->
(ALL x. P(x)) & (ALL x. Q(x))
 1. ALL x. P(x) & Q(x)  |-  ALL x. Q(x)
 2. (ALL x. P(x)) & (ALL x. Q(x))
    |-  ALL x. P(x) & Q(x)
> val it = () : unit
(ALL x. P(x) & Q(x)) <->
(ALL x. P(x)) & (ALL x. Q(x))
 1. ALL x. P(x) & Q(x)  |-  Q(_c)
 2. (ALL x. P(x)) & (ALL x. Q(x))
    |-  ALL x. P(x) & Q(x)
> val it = () : unit
(ALL x. P(x) & Q(x)) <->
(ALL x. P(x)) & (ALL x. Q(x))
 1. P(?_d) & Q(?_d), ALL x. P(x) & Q(x)  |-  Q(_c)
 2. (ALL x. P(x)) & (ALL x. Q(x))
    |-  ALL x. P(x) & Q(x)
> val it = () : unit
(ALL x. P(x) & Q(x)) <->
(ALL x. P(x)) & (ALL x. Q(x))
 1. P(?_d), Q(?_d), ALL x. P(x) & Q(x)  |-  Q(_c)
 2. (ALL x. P(x)) & (ALL x. Q(x))
    |-  ALL x. P(x) & Q(x)
> val it = () : unit
(ALL x. P(x) & Q(x)) <->
(ALL x. P(x)) & (ALL x. Q(x))
 1. (ALL x. P(x)) & (ALL x. Q(x))
    |-  ALL x. P(x) & Q(x)
> val it = () : unit
(ALL x. P(x) & Q(x)) <->
(ALL x. P(x)) & (ALL x. Q(x))
 1. (ALL x. P(x)) & (ALL x. Q(x))
    |-  P(_e) & Q(_e)
> val it = () : unit
(ALL x. P(x) & Q(x)) <->
(ALL x. P(x)) & (ALL x. Q(x))
 1. ALL x. P(x), ALL x. Q(x)  |-  P(_e) & Q(_e)
> val it = () : unit
(ALL x. P(x) & Q(x)) <->
(ALL x. P(x)) & (ALL x. Q(x))
 1. P(?_f), ALL x. Q(x), ALL x. P(x)
    |-  P(_e) & Q(_e)
> val it = () : unit
(ALL x. P(x) & Q(x)) <->
(ALL x. P(x)) & (ALL x. Q(x))
 1. Q(?_g), P(?_f), ALL x. P(x), ALL x. Q(x)
    |-  P(_e) & Q(_e)
> val it = () : unit
(ALL x. P(x) & Q(x)) <->
(ALL x. P(x)) & (ALL x. Q(x))
 1. Q(?_g), P(?_f), ALL x. P(x), ALL x. Q(x)
    |-  P(_e)
 2. Q(?_g), P(?_f), ALL x. P(x), ALL x. Q(x)
    |-  Q(_e)
> val it = () : unit
(ALL x. P(x) & Q(x)) <->
(ALL x. P(x)) & (ALL x. Q(x))
 1. Q(?_g), P(_e), ALL x. P(x), ALL x. Q(x)
    |-  Q(_e)
> val it = () : unit
(ALL x. P(x) & Q(x)) <->
(ALL x. P(x)) & (ALL x. Q(x))
No subgoals left!
> val it = () : unit
(ALL x. P(x) & Q(x)) <->
(ALL x. P(x)) & (ALL x. Q(x))
> val it = () : unit
(ALL x. P(x) & Q(x)) <->
(ALL x. P(x)) & (ALL x. Q(x))
 1. empty
    |-  (ALL x. P(x) & Q(x)) <->
        (ALL x. P(x)) & (ALL x. Q(x))
> val it = () : unit
(ALL x. P(x) & Q(x)) <->
(ALL x. P(x)) & (ALL x. Q(x))
No subgoals left!
> val it = () : unit
(ALL x. P(x) & Q(x)) <->
(ALL x. P(x)) & (ALL x. Q(x))
> val it = () : unit
(EX y. ALL x. Q(x, y)) --> (ALL x. EX y. Q(x, y))
 1. empty
    |-  (EX y. ALL x. Q(x, y)) -->
        (ALL x. EX y. Q(x, y))
> val it = () : unit
(EX y. ALL x. Q(x, y)) --> (ALL x. EX y. Q(x, y))
 1. EX y. ALL x. Q(x, y)  |-  ALL x. EX y. Q(x, y)
> val it = () : unit
(EX y. ALL x. Q(x, y)) --> (ALL x. EX y. Q(x, y))
 1. ALL x. Q(x, _a)  |-  ALL x. EX y. Q(x, y)
> val it = () : unit
(EX y. ALL x. Q(x, y)) --> (ALL x. EX y. Q(x, y))
 1. ALL x. Q(x, _a)  |-  EX y. Q(_b, y)
> val it = () : unit
(EX y. ALL x. Q(x, y)) --> (ALL x. EX y. Q(x, y))
 1. Q(?_c, _a), ALL x. Q(x, _a)
    |-  EX y. Q(_b, y)
> val it = () : unit
(EX y. ALL x. Q(x, y)) --> (ALL x. EX y. Q(x, y))
 1. Q(?_c, _a), ALL x. Q(x, _a)
    |-  Q(_b, ?_d), EX y. Q(_b, y)
> val it = () : unit
(EX y. ALL x. Q(x, y)) --> (ALL x. EX y. Q(x, y))
No subgoals left!
> val it = () : unit
(EX y. ALL x. Q(x, y)) --> (ALL x. EX y. Q(x, y))
> val it = () : unit
(ALL x. EX y. Q(x, y)) --> (EX y. ALL x. Q(x, y))
 1. empty
    |-  (ALL x. EX y. Q(x, y)) -->
        (EX y. ALL x. Q(x, y))
> val it = () : unit
(ALL x. EX y. Q(x, y)) --> (EX y. ALL x. Q(x, y))
 1. ALL x. EX y. Q(x, y)  |-  EX y. ALL x. Q(x, y)
> val it = () : unit
(ALL x. EX y. Q(x, y)) --> (EX y. ALL x. Q(x, y))
 1. EX y. Q(?_a, y), ALL x. EX y. Q(x, y)
    |-  EX y. ALL x. Q(x, y)
> val it = () : unit
(ALL x. EX y. Q(x, y)) --> (EX y. ALL x. Q(x, y))
 1. Q(?_a, _b), ALL x. EX y. Q(x, y)
    |-  EX y. ALL x. Q(x, y)
_b not in  ?_a
> val it = () : unit
(ALL x. EX y. Q(x, y)) --> (EX y. ALL x. Q(x, y))
 1. Q(?_a, _b), ALL x. EX y. Q(x, y)
    |-  ALL x. Q(x, ?_c), EX y. ALL x. Q(x, y)
_b not in  ?_a
> val it = () : unit
(ALL x. EX y. Q(x, y)) --> (EX y. ALL x. Q(x, y))
 1. Q(?_a, _b), ALL x. EX y. Q(x, y)
    |-  Q(_d, ?_c), EX y. ALL x. Q(x, y)
_b not in  ?_a
_d not in  ?_a ?_c
> val it = () : unit
** Tactic FAILED! **
> val it = () : unit
> val it = "Failed, as expected..." : string
(EX x. P(x) --> Q) <-> ((ALL x. P(x)) --> Q)
 1. empty
    |-  (EX x. P(x) --> Q) <->
        ((ALL x. P(x)) --> Q)
> val it = () : unit
(EX x. P(x) --> Q) <-> ((ALL x. P(x)) --> Q)
 1. EX x. P(x) --> Q  |-  (ALL x. P(x)) --> Q
 2. (ALL x. P(x)) --> Q  |-  EX x. P(x) --> Q
> val it = () : unit
(EX x. P(x) --> Q) <-> ((ALL x. P(x)) --> Q)
 1. ALL x. P(x), EX x. P(x) --> Q  |-  Q
 2. (ALL x. P(x)) --> Q  |-  EX x. P(x) --> Q
> val it = () : unit
(EX x. P(x) --> Q) <-> ((ALL x. P(x)) --> Q)
 1. P(_a) --> Q, ALL x. P(x)  |-  Q
 2. (ALL x. P(x)) --> Q  |-  EX x. P(x) --> Q
> val it = () : unit
(EX x. P(x) --> Q) <-> ((ALL x. P(x)) --> Q)
 1. P(?_b), P(_a) --> Q, ALL x. P(x)  |-  Q
 2. (ALL x. P(x)) --> Q  |-  EX x. P(x) --> Q
> val it = () : unit
(EX x. P(x) --> Q) <-> ((ALL x. P(x)) --> Q)
 1. Q, P(?_b), ALL x. P(x)  |-  Q
 2. P(?_b), ALL x. P(x)  |-  P(_a), Q
 3. (ALL x. P(x)) --> Q  |-  EX x. P(x) --> Q
> val it = () : unit
(EX x. P(x) --> Q) <-> ((ALL x. P(x)) --> Q)
 1. P(?_b), ALL x. P(x)  |-  P(_a), Q
 2. (ALL x. P(x)) --> Q  |-  EX x. P(x) --> Q
> val it = () : unit
(EX x. P(x) --> Q) <-> ((ALL x. P(x)) --> Q)
 1. (ALL x. P(x)) --> Q  |-  EX x. P(x) --> Q
> val it = () : unit
(EX x. P(x) --> Q) <-> ((ALL x. P(x)) --> Q)
 1. Q  |-  EX x. P(x) --> Q
 2. empty  |-  ALL x. P(x), EX x. P(x) --> Q
> val it = () : unit
(EX x. P(x) --> Q) <-> ((ALL x. P(x)) --> Q)
 1. Q  |-  P(?_c) --> Q, EX x. P(x) --> Q
 2. empty  |-  ALL x. P(x), EX x. P(x) --> Q
> val it = () : unit
(EX x. P(x) --> Q) <-> ((ALL x. P(x)) --> Q)
 1. P(?_c), Q  |-  Q, EX x. P(x) --> Q
 2. empty  |-  ALL x. P(x), EX x. P(x) --> Q
> val it = () : unit
(EX x. P(x) --> Q) <-> ((ALL x. P(x)) --> Q)
 1. empty  |-  ALL x. P(x), EX x. P(x) --> Q
> val it = () : unit
(EX x. P(x) --> Q) <-> ((ALL x. P(x)) --> Q)
 1. empty  |-  P(_d), EX x. P(x) --> Q
> val it = () : unit
(EX x. P(x) --> Q) <-> ((ALL x. P(x)) --> Q)
 1. empty
    |-  P(?_e) --> Q, P(_d), EX x. P(x) --> Q
> val it = () : unit
(EX x. P(x) --> Q) <-> ((ALL x. P(x)) --> Q)
 1. P(?_e)  |-  Q, P(_d), EX x. P(x) --> Q
> val it = () : unit
(EX x. P(x) --> Q) <-> ((ALL x. P(x)) --> Q)
No subgoals left!
> val it = () : unit
(EX x. P(x) --> Q) <-> ((ALL x. P(x)) --> Q)
> val it = () : unit
commutative laws of & and | 
> val it = () : unit
P & Q --> Q & P
 1. empty  |-  P & Q --> Q & P
> val it = () : unit
P & Q --> Q & P
No subgoals left!
> val it = () : unit
P & Q --> Q & P
> val it = () : unit
P | Q --> Q | P
 1. empty  |-  P | Q --> Q | P
> val it = () : unit
P | Q --> Q | P
No subgoals left!
> val it = () : unit
P | Q --> Q | P
> val it = () : unit
associative laws of & and | 
> val it = () : unit
(P & Q) & R --> P & (Q & R)
 1. empty  |-  (P & Q) & R --> P & (Q & R)
> val it = () : unit
(P & Q) & R --> P & (Q & R)
No subgoals left!
> val it = () : unit
(P & Q) & R --> P & (Q & R)
> val it = () : unit
(P | Q) | R --> P | (Q | R)
 1. empty  |-  (P | Q) | R --> P | (Q | R)
> val it = () : unit
(P | Q) | R --> P | (Q | R)
No subgoals left!
> val it = () : unit
(P | Q) | R --> P | (Q | R)
> val it = () : unit
distributive laws of & and | 
> val it = () : unit
P & Q | R --> (P | R) & (Q | R)
 1. empty  |-  P & Q | R --> (P | R) & (Q | R)
> val it = () : unit
P & Q | R --> (P | R) & (Q | R)
No subgoals left!
> val it = () : unit
P & Q | R --> (P | R) & (Q | R)
> val it = () : unit
(P | R) & (Q | R) --> P & Q | R
 1. empty  |-  (P | R) & (Q | R) --> P & Q | R
> val it = () : unit
(P | R) & (Q | R) --> P & Q | R
No subgoals left!
> val it = () : unit
(P | R) & (Q | R) --> P & Q | R
> val it = () : unit
(P | Q) & R --> P & R | Q & R
 1. empty  |-  (P | Q) & R --> P & R | Q & R
> val it = () : unit
(P | Q) & R --> P & R | Q & R
No subgoals left!
> val it = () : unit
(P | Q) & R --> P & R | Q & R
> val it = () : unit
P & R | Q & R --> (P | Q) & R
 1. empty  |-  P & R | Q & R --> (P | Q) & R
> val it = () : unit
P & R | Q & R --> (P | Q) & R
No subgoals left!
> val it = () : unit
P & R | Q & R --> (P | Q) & R
> val it = () : unit
Laws involving implication
> val it = () : unit
(P --> R) & (Q --> R) <-> (P | Q --> R)
 1. empty
    |-  (P --> R) & (Q --> R) <-> (P | Q --> R)
> val it = () : unit
(P --> R) & (Q --> R) <-> (P | Q --> R)
No subgoals left!
> val it = () : unit
(P --> R) & (Q --> R) <-> (P | Q --> R)
> val it = () : unit
(P & Q --> R) <-> (P --> (Q --> R))
 1. empty  |-  (P & Q --> R) <-> (P --> (Q --> R))
> val it = () : unit
(P & Q --> R) <-> (P --> (Q --> R))
No subgoals left!
> val it = () : unit
(P & Q --> R) <-> (P --> (Q --> R))
> val it = () : unit
((P --> R) --> R) -->
(((Q --> R) --> R) --> ((P & Q --> R) --> R))
 1. empty
    |-  ((P --> R) --> R) -->
        (((Q --> R) --> R) -->
         ((P & Q --> R) --> R))
> val it = () : unit
((P --> R) --> R) -->
(((Q --> R) --> R) --> ((P & Q --> R) --> R))
No subgoals left!
> val it = () : unit
((P --> R) --> R) -->
(((Q --> R) --> R) --> ((P & Q --> R) --> R))
> val it = () : unit
~(P --> R) --> (~(Q --> R) --> ~((P & Q) --> R))
 1. empty
    |-  ~(P --> R) -->
        (~(Q --> R) --> ~((P & Q) --> R))
> val it = () : unit
~(P --> R) --> (~(Q --> R) --> ~((P & Q) --> R))
No subgoals left!
> val it = () : unit
~(P --> R) --> (~(Q --> R) --> ~((P & Q) --> R))
> val it = () : unit
(P --> Q & R) <-> (P --> Q) & (P --> R)
 1. empty
    |-  (P --> Q & R) <-> (P --> Q) & (P --> R)
> val it = () : unit
(P --> Q & R) <-> (P --> Q) & (P --> R)
No subgoals left!
> val it = () : unit
(P --> Q & R) <-> (P --> Q) & (P --> R)
> val it = () : unit
Propositions-as-types
> val it = () : unit
P --> (Q --> P)
 1. empty  |-  P --> (Q --> P)
> val it = () : unit
P --> (Q --> P)
No subgoals left!
> val it = () : unit
P --> (Q --> P)
> val it = () : unit
(P --> (Q --> R)) --> ((P --> Q) --> (P --> R))
 1. empty
    |-  (P --> (Q --> R)) -->
        ((P --> Q) --> (P --> R))
> val it = () : unit
(P --> (Q --> R)) --> ((P --> Q) --> (P --> R))
No subgoals left!
> val it = () : unit
(P --> (Q --> R)) --> ((P --> Q) --> (P --> R))
> val it = () : unit
(P --> Q) | (P --> R) --> (P --> Q | R)
 1. empty
    |-  (P --> Q) | (P --> R) --> (P --> Q | R)
> val it = () : unit
(P --> Q) | (P --> R) --> (P --> Q | R)
No subgoals left!
> val it = () : unit
(P --> Q) | (P --> R) --> (P --> Q | R)
> val it = () : unit
(P --> Q) --> (~Q --> ~P)
 1. empty  |-  (P --> Q) --> (~Q --> ~P)
> val it = () : unit
(P --> Q) --> (~Q --> ~P)
No subgoals left!
> val it = () : unit
(P --> Q) --> (~Q --> ~P)
> val it = () : unit
Classical examples
> val it = () : unit
(P --> Q | R) --> (P --> Q) | (P --> R)
 1. empty
    |-  (P --> Q | R) --> (P --> Q) | (P --> R)
> val it = () : unit
(P --> Q | R) --> (P --> Q) | (P --> R)
No subgoals left!
> val it = () : unit
(P --> Q | R) --> (P --> Q) | (P --> R)
> val it = () : unit
(P <-> Q) <-> (Q <-> P)
 1. empty  |-  (P <-> Q) <-> (Q <-> P)
> val it = () : unit
(P <-> Q) <-> (Q <-> P)
No subgoals left!
> val it = () : unit
(P <-> Q) <-> (Q <-> P)
> val it = () : unit
~(P <-> ~P)
 1. empty  |-  ~(P <-> ~P)
> val it = () : unit
~(P <-> ~P)
No subgoals left!
> val it = () : unit
~(P <-> ~P)
> val it = () : unit
*** Quantifier examples ***
> val it = () : unit
(ALL x. ALL y. P(x, y)) -->
(ALL y. ALL x. P(x, y))
 1. empty
    |-  (ALL x. ALL y. P(x, y)) -->
        (ALL y. ALL x. P(x, y))
> val it = () : unit
(ALL x. ALL y. P(x, y)) -->
(ALL y. ALL x. P(x, y))
No subgoals left!
> val it = () : unit
(ALL x. ALL y. P(x, y)) -->
(ALL y. ALL x. P(x, y))
> val it = () : unit
(EX x. EX y. P(x, y)) --> (EX y. EX x. P(x, y))
 1. empty
    |-  (EX x. EX y. P(x, y)) -->
        (EX y. EX x. P(x, y))
> val it = () : unit
(EX x. EX y. P(x, y)) --> (EX y. EX x. P(x, y))
No subgoals left!
> val it = () : unit
(EX x. EX y. P(x, y)) --> (EX y. EX x. P(x, y))
> val it = () : unit
(ALL x. P(x)) | (ALL x. Q(x)) -->
(ALL x. P(x) | Q(x))
 1. empty
    |-  (ALL x. P(x)) | (ALL x. Q(x)) -->
        (ALL x. P(x) | Q(x))
> val it = () : unit
(ALL x. P(x)) | (ALL x. Q(x)) -->
(ALL x. P(x) | Q(x))
No subgoals left!
> val it = () : unit
(ALL x. P(x)) | (ALL x. Q(x)) -->
(ALL x. P(x) | Q(x))
> val it = () : unit
(ALL x. P --> Q(x)) <-> (P --> (ALL x. Q(x)))
 1. empty
    |-  (ALL x. P --> Q(x)) <->
        (P --> (ALL x. Q(x)))
> val it = () : unit
(ALL x. P --> Q(x)) <-> (P --> (ALL x. Q(x)))
No subgoals left!
> val it = () : unit
(ALL x. P --> Q(x)) <-> (P --> (ALL x. Q(x)))
> val it = () : unit
(ALL x. P(x) --> Q) <-> ((EX x. P(x)) --> Q)
 1. empty
    |-  (ALL x. P(x) --> Q) <->
        ((EX x. P(x)) --> Q)
> val it = () : unit
(ALL x. P(x) --> Q) <-> ((EX x. P(x)) --> Q)
No subgoals left!
> val it = () : unit
(ALL x. P(x) --> Q) <-> ((EX x. P(x)) --> Q)
> val it = () : unit
Some harder ones
> val it = () : unit
(EX x. P(x) | Q(x)) <->
(EX x. P(x)) | (EX x. Q(x))
 1. empty
    |-  (EX x. P(x) | Q(x)) <->
        (EX x. P(x)) | (EX x. Q(x))
> val it = () : unit
(EX x. P(x) | Q(x)) <->
(EX x. P(x)) | (EX x. Q(x))
No subgoals left!
> val it = () : unit
(EX x. P(x) | Q(x)) <->
(EX x. P(x)) | (EX x. Q(x))
> val it = () : unit
(EX x. P(x) & Q(x)) -->
(EX x. P(x)) & (EX x. Q(x))
 1. empty
    |-  (EX x. P(x) & Q(x)) -->
        (EX x. P(x)) & (EX x. Q(x))
> val it = () : unit
(EX x. P(x) & Q(x)) -->
(EX x. P(x)) & (EX x. Q(x))
No subgoals left!
> val it = () : unit
(EX x. P(x) & Q(x)) -->
(EX x. P(x)) & (EX x. Q(x))
> val it = () : unit
Basic test of quantifier reasoning
> val it = () : unit
(EX y. ALL x. Q(x, y)) --> (ALL x. EX y. Q(x, y))
 1. empty
    |-  (EX y. ALL x. Q(x, y)) -->
        (ALL x. EX y. Q(x, y))
> val it = () : unit
(EX y. ALL x. Q(x, y)) --> (ALL x. EX y. Q(x, y))
No subgoals left!
> val it = () : unit
(EX y. ALL x. Q(x, y)) --> (ALL x. EX y. Q(x, y))
> val it = () : unit
(ALL x. Q(x)) --> (EX x. Q(x))
 1. empty  |-  (ALL x. Q(x)) --> (EX x. Q(x))
> val it = () : unit
(ALL x. Q(x)) --> (EX x. Q(x))
No subgoals left!
> val it = () : unit
(ALL x. Q(x)) --> (EX x. Q(x))
> val it = () : unit
The following should fail, as they are false!
> val it = () : unit
(EX x. Q(x)) --> (ALL x. Q(x))
 1. empty  |-  (EX x. Q(x)) --> (ALL x. Q(x))
> val it = () : unit
** Tactic FAILED! **
> val it = () : unit
> val it = "Failed, as expected..." : string
P(?a) --> (ALL x. P(x))
 1. empty  |-  P(?a) --> (ALL x. P(x))
> val it = () : unit
** Tactic FAILED! **
> val it = () : unit
> val it = "Failed, as expected..." : string
(P(?a) --> (ALL x. Q(x))) -->
(ALL x. P(x) --> Q(x))
 1. empty
    |-  (P(?a) --> (ALL x. Q(x))) -->
        (ALL x. P(x) --> Q(x))
> val it = () : unit
** Tactic FAILED! **
> val it = () : unit
> val it = "Failed, as expected..." : string
Back to things that are provable...
> val it = () : unit
(ALL x. P(x) --> Q(x)) & (EX x. P(x)) -->
(EX x. Q(x))
 1. empty
    |-  (ALL x. P(x) --> Q(x)) & (EX x. P(x)) -->
        (EX x. Q(x))
> val it = () : unit
(ALL x. P(x) --> Q(x)) & (EX x. P(x)) -->
(EX x. Q(x))
No subgoals left!
> val it = () : unit
(ALL x. P(x) --> Q(x)) & (EX x. P(x)) -->
(EX x. Q(x))
> val it = () : unit
(P --> (EX x. Q(x))) & P --> (EX x. Q(x))
 1. empty
    |-  (P --> (EX x. Q(x))) & P --> (EX x. Q(x))
> val it = () : unit
(P --> (EX x. Q(x))) & P --> (EX x. Q(x))
No subgoals left!
> val it = () : unit
(P --> (EX x. Q(x))) & P --> (EX x. Q(x))
> val it = () : unit
(ALL x. P(x) --> Q(f(x))) &
((ALL x. Q(x) --> R(g(x))) & P(d)) --> R(?a)
 1. empty
    |-  (ALL x. P(x) --> Q(f(x))) &
        ((ALL x. Q(x) --> R(g(x))) & P(d)) -->
        R(?a)
> val it = () : unit
(ALL x. P(x) --> Q(f(x))) &
((ALL x. Q(x) --> R(g(x))) & P(d)) --> R(g(f(d)))
No subgoals left!
> val it = () : unit
(ALL x. P(x) --> Q(f(x))) &
((ALL x. Q(x) --> R(g(x))) & P(d)) --> R(g(f(d)))
> val it = () : unit
(ALL x. Q(x)) --> (EX x. Q(x))
 1. empty  |-  (ALL x. Q(x)) --> (EX x. Q(x))
> val it = () : unit
(ALL x. Q(x)) --> (EX x. Q(x))
No subgoals left!
> val it = () : unit
(ALL x. Q(x)) --> (EX x. Q(x))
> val it = () : unit
Classical Logic: examples with quantifiers.
> val it = () : unit
(ALL x. P(x) & Q(x)) <->
(ALL x. P(x)) & (ALL x. Q(x))
 1. empty
    |-  (ALL x. P(x) & Q(x)) <->
        (ALL x. P(x)) & (ALL x. Q(x))
> val it = () : unit
(ALL x. P(x) & Q(x)) <->
(ALL x. P(x)) & (ALL x. Q(x))
No subgoals left!
> val it = () : unit
(ALL x. P(x) & Q(x)) <->
(ALL x. P(x)) & (ALL x. Q(x))
> val it = () : unit
(EX x. P --> Q(x)) <-> (P --> (EX x. Q(x)))
 1. empty
    |-  (EX x. P --> Q(x)) <->
        (P --> (EX x. Q(x)))
> val it = () : unit
(EX x. P --> Q(x)) <-> (P --> (EX x. Q(x)))
No subgoals left!
> val it = () : unit
(EX x. P --> Q(x)) <-> (P --> (EX x. Q(x)))
> val it = () : unit
(EX x. P(x) --> Q) <-> ((ALL x. P(x)) --> Q)
 1. empty
    |-  (EX x. P(x) --> Q) <->
        ((ALL x. P(x)) --> Q)
> val it = () : unit
(EX x. P(x) --> Q) <-> ((ALL x. P(x)) --> Q)
No subgoals left!
> val it = () : unit
(EX x. P(x) --> Q) <-> ((ALL x. P(x)) --> Q)
> val it = () : unit
(ALL x. P(x)) | Q <-> (ALL x. P(x) | Q)
 1. empty
    |-  (ALL x. P(x)) | Q <-> (ALL x. P(x) | Q)
> val it = () : unit
(ALL x. P(x)) | Q <-> (ALL x. P(x) | Q)
No subgoals left!
> val it = () : unit
(ALL x. P(x)) | Q <-> (ALL x. P(x) | Q)
> val it = () : unit
Harder proofs 
> val it = () : unit
(ALL x. P(x) --> P(f(x))) & P(d) --> P(f(f(f(d))))
 1. empty
    |-  (ALL x. P(x) --> P(f(x))) & P(d) -->
        P(f(f(f(d))))
> val it = () : unit
(ALL x. P(x) --> P(f(x))) & P(d) --> P(f(f(f(d))))
No subgoals left!
> val it = () : unit
(ALL x. P(x) --> P(f(x))) & P(d) --> P(f(f(f(d))))
> val it = () : unit
EX x. P(x) --> P(a) & P(b)
 1. empty  |-  EX x. P(x) --> P(a) & P(b)
> val it = () : unit
EX x. P(x) --> P(a) & P(b)
No subgoals left!
> val it = () : unit
EX x. P(x) --> P(a) & P(b)
> val it = () : unit
EX z. P(z) --> (ALL x. P(x))
 1. empty  |-  EX z. P(z) --> (ALL x. P(x))
> val it = () : unit
EX z. P(z) --> (ALL x. P(x))
No subgoals left!
> val it = () : unit
EX z. P(z) --> (ALL x. P(x))
> val it = () : unit
Some slow ones
> val it = () : unit
(ALL x. ALL y. P(x) --> Q(y)) <->
((EX x. P(x)) --> (ALL y. Q(y)))
 1. empty
    |-  (ALL x. ALL y. P(x) --> Q(y)) <->
        ((EX x. P(x)) --> (ALL y. Q(y)))
> val it = () : unit
(ALL x. ALL y. P(x) --> Q(y)) <->
((EX x. P(x)) --> (ALL y. Q(y)))
No subgoals left!
> val it = () : unit
(ALL x. ALL y. P(x) --> Q(y)) <->
((EX x. P(x)) --> (ALL y. Q(y)))
> val it = () : unit
(EX x. EX y. P(x) & Q(x, y)) <->
(EX x. P(x) & (EX y. Q(x, y)))
 1. empty
    |-  (EX x. EX y. P(x) & Q(x, y)) <->
        (EX x. P(x) & (EX y. Q(x, y)))
> val it = () : unit
(EX x. EX y. P(x) & Q(x, y)) <->
(EX x. P(x) & (EX y. Q(x, y)))
No subgoals left!
> val it = () : unit
(EX x. EX y. P(x) & Q(x, y)) <->
(EX x. P(x) & (EX y. Q(x, y)))
> val it = () : unit
(EX y. ALL x. P(x) --> Q(x, y)) -->
(ALL x. P(x) --> (EX y. Q(x, y)))
 1. empty
    |-  (EX y. ALL x. P(x) --> Q(x, y)) -->
        (ALL x. P(x) --> (EX y. Q(x, y)))
> val it = () : unit
(EX y. ALL x. P(x) --> Q(x, y)) -->
(ALL x. P(x) --> (EX y. Q(x, y)))
No subgoals left!
> val it = () : unit
(EX y. ALL x. P(x) --> Q(x, y)) -->
(ALL x. P(x) --> (EX y. Q(x, y)))
> val it = () : unit
(EX z. P(z)) & (EX w. Q(w)) -->
((ALL z. P(z) --> R(z)) &
 (ALL w. Q(w) --> S(w)) <->
 (ALL z. ALL w. P(z) & Q(w) --> R(z) & S(w)))
 1. empty
    |-  (EX z. P(z)) & (EX w. Q(w)) -->
        ((ALL z. P(z) --> R(z)) &
         (ALL w. Q(w) --> S(w)) <->
         (ALL z.
            ALL w. P(z) & Q(w) --> R(z) & S(w)))
> val it = () : unit
(EX z. P(z)) & (EX w. Q(w)) -->
((ALL z. P(z) --> R(z)) &
 (ALL w. Q(w) --> S(w)) <->
 (ALL z. ALL w. P(z) & Q(w) --> R(z) & S(w)))
No subgoals left!
> val it = () : unit
(EX z. P(z)) & (EX w. Q(w)) -->
((ALL z. P(z) --> R(z)) &
 (ALL w. Q(w) --> S(w)) <->
 (ALL z. ALL w. P(z) & Q(w) --> R(z) & S(w)))
> val it = () : unit
EX x.
  EX X.
    ALL y.
      EX z.
        EX Z.
          (~P(y, y) | (P(x, x) | ~S(z, x))) &
          ((S(x, y) | (~S(y, z) | Q(Z, Z))) &
           (Q(X, y) | (~Q(y, Z) | S(X, X))))
 1. empty
    |-  EX x.
          EX X.
            ALL y.
              EX z.
                EX Z.
                  (~P(y, y) |
                   (P(x, x) | ~S(z, x))) &
                  ((S(x, y) |
                    (~S(y, z) | Q(Z, Z))) &
                   (Q(X, y) |
                    (~Q(y, Z) | S(X, X))))
> val it = () : unit
Pelletier's examples
> val it = () : unit
(P --> Q) <-> (~Q --> ~P)
 1. empty  |-  (P --> Q) <-> (~Q --> ~P)
> val it = () : unit
(P --> Q) <-> (~Q --> ~P)
No subgoals left!
> val it = () : unit
(P --> Q) <-> (~Q --> ~P)
> val it = () : unit
~~P <-> P
 1. empty  |-  ~~P <-> P
> val it = () : unit
~~P <-> P
No subgoals left!
> val it = () : unit
~~P <-> P
> val it = () : unit
~(P --> Q) --> (Q --> P)
 1. empty  |-  ~(P --> Q) --> (Q --> P)
> val it = () : unit
~(P --> Q) --> (Q --> P)
No subgoals left!
> val it = () : unit
~(P --> Q) --> (Q --> P)
> val it = () : unit
(~P --> Q) <-> (~Q --> P)
 1. empty  |-  (~P --> Q) <-> (~Q --> P)
> val it = () : unit
(~P --> Q) <-> (~Q --> P)
No subgoals left!
> val it = () : unit
(~P --> Q) <-> (~Q --> P)
> val it = () : unit
(P | Q --> P | R) --> P | (Q --> R)
 1. empty  |-  (P | Q --> P | R) --> P | (Q --> R)
> val it = () : unit
(P | Q --> P | R) --> P | (Q --> R)
No subgoals left!
> val it = () : unit
(P | Q --> P | R) --> P | (Q --> R)
> val it = () : unit
P | ~P
 1. empty  |-  P | ~P
> val it = () : unit
P | ~P
No subgoals left!
> val it = () : unit
P | ~P
> val it = () : unit
P | ~~~P
 1. empty  |-  P | ~~~P
> val it = () : unit
P | ~~~P
No subgoals left!
> val it = () : unit
P | ~~~P
> val it = () : unit
((P --> Q) --> P) --> P
 1. empty  |-  ((P --> Q) --> P) --> P
> val it = () : unit
((P --> Q) --> P) --> P
No subgoals left!
> val it = () : unit
((P --> Q) --> P) --> P
> val it = () : unit
(P | Q) & ((~P | Q) & (P | ~Q)) --> ~(~P | ~Q)
 1. empty
    |-  (P | Q) & ((~P | Q) & (P | ~Q)) -->
        ~(~P | ~Q)
> val it = () : unit
(P | Q) & ((~P | Q) & (P | ~Q)) --> ~(~P | ~Q)
No subgoals left!
> val it = () : unit
(P | Q) & ((~P | Q) & (P | ~Q)) --> ~(~P | ~Q)
> val it = () : unit
(Q --> R) &
((R --> (P & Q)) & (P --> (Q | R))) --> (P <-> Q)
 1. empty
    |-  (Q --> R) &
        ((R --> (P & Q)) & (P --> (Q | R))) -->
        (P <-> Q)
> val it = () : unit
(Q --> R) &
((R --> (P & Q)) & (P --> (Q | R))) --> (P <-> Q)
No subgoals left!
> val it = () : unit
(Q --> R) &
((R --> (P & Q)) & (P --> (Q | R))) --> (P <-> Q)
> val it = () : unit
P <-> P
 1. empty  |-  P <-> P
> val it = () : unit
P <-> P
No subgoals left!
> val it = () : unit
P <-> P
> val it = () : unit
((P <-> Q) <-> R) <-> (P <-> (Q <-> R))
 1. empty
    |-  ((P <-> Q) <-> R) <-> (P <-> (Q <-> R))
> val it = () : unit
((P <-> Q) <-> R) <-> (P <-> (Q <-> R))
No subgoals left!
> val it = () : unit
((P <-> Q) <-> R) <-> (P <-> (Q <-> R))
> val it = () : unit
P | Q & R <-> (P | Q) & (P | R)
 1. empty  |-  P | Q & R <-> (P | Q) & (P | R)
> val it = () : unit
P | Q & R <-> (P | Q) & (P | R)
No subgoals left!
> val it = () : unit
P | Q & R <-> (P | Q) & (P | R)
> val it = () : unit
(P <-> Q) <-> (Q | ~P) & (~Q | P)
 1. empty  |-  (P <-> Q) <-> (Q | ~P) & (~Q | P)
> val it = () : unit
(P <-> Q) <-> (Q | ~P) & (~Q | P)
No subgoals left!
> val it = () : unit
(P <-> Q) <-> (Q | ~P) & (~Q | P)
> val it = () : unit
(P --> Q) <-> ~P | Q
 1. empty  |-  (P --> Q) <-> ~P | Q
> val it = () : unit
(P --> Q) <-> ~P | Q
No subgoals left!
> val it = () : unit
(P --> Q) <-> ~P | Q
> val it = () : unit
(P --> Q) | (Q --> P)
 1. empty  |-  (P --> Q) | (Q --> P)
> val it = () : unit
(P --> Q) | (Q --> P)
No subgoals left!
> val it = () : unit
(P --> Q) | (Q --> P)
> val it = () : unit
(P & (Q --> R) --> S) <->
(~P | (Q | S)) & (~P | (~R | S))
 1. empty
    |-  (P & (Q --> R) --> S) <->
        (~P | (Q | S)) & (~P | (~R | S))
> val it = () : unit
(P & (Q --> R) --> S) <->
(~P | (Q | S)) & (~P | (~R | S))
No subgoals left!
> val it = () : unit
(P & (Q --> R) --> S) <->
(~P | (Q | S)) & (~P | (~R | S))
> val it = () : unit
Problem 18. 
> val it = () : unit
EX y. ALL x. P(y) --> P(x)
 1. empty  |-  EX y. ALL x. P(y) --> P(x)
> val it = () : unit
EX y. ALL x. P(y) --> P(x)
No subgoals left!
> val it = () : unit
EX y. ALL x. P(y) --> P(x)
> val it = () : unit
Problem 19. 
> val it = () : unit
EX x.
  ALL y.
    ALL z. (P(y) --> Q(z)) --> (P(x) --> Q(x))
 1. empty
    |-  EX x.
          ALL y.
            ALL z.
              (P(y) --> Q(z)) --> (P(x) --> Q(x))
> val it = () : unit
EX x.
  ALL y.
    ALL z. (P(y) --> Q(z)) --> (P(x) --> Q(x))
No subgoals left!
> val it = () : unit
EX x.
  ALL y.
    ALL z. (P(y) --> Q(z)) --> (P(x) --> Q(x))
> val it = () : unit
Problem 20. 
> val it = () : unit
(ALL x.
   ALL y.
     EX z. ALL w. P(x) & Q(y) --> R(z) & S(w)) -->
((EX x. EX y. P(x) & Q(y)) --> (EX z. R(z)))
 1. empty
    |-  (ALL x.
           ALL y.
             EX z.
               ALL w.
                 P(x) & Q(y) --> R(z) & S(w)) -->
        ((EX x. EX y. P(x) & Q(y)) -->
         (EX z. R(z)))
> val it = () : unit
(ALL x.
   ALL y.
     EX z. ALL w. P(x) & Q(y) --> R(z) & S(w)) -->
((EX x. EX y. P(x) & Q(y)) --> (EX z. R(z)))
No subgoals left!
> val it = () : unit
(ALL x.
   ALL y.
     EX z. ALL w. P(x) & Q(y) --> R(z) & S(w)) -->
((EX x. EX y. P(x) & Q(y)) --> (EX z. R(z)))
> val it = () : unit
Problem 21.  
> val it = () : unit
(EX x. P --> Q(x)) & (EX x. Q(x) --> P) -->
(EX x. P <-> Q(x))
 1. empty
    |-  (EX x. P --> Q(x)) &
        (EX x. Q(x) --> P) --> (EX x. P <-> Q(x))
> val it = () : unit
(EX x. P --> Q(x)) & (EX x. Q(x) --> P) -->
(EX x. P <-> Q(x))
No subgoals left!
> val it = () : unit
(EX x. P --> Q(x)) & (EX x. Q(x) --> P) -->
(EX x. P <-> Q(x))
> val it = () : unit
Problem 22
> val it = () : unit
(ALL x. P <-> Q(x)) --> (P <-> (ALL x. Q(x)))
 1. empty
    |-  (ALL x. P <-> Q(x)) -->
        (P <-> (ALL x. Q(x)))
> val it = () : unit
(ALL x. P <-> Q(x)) --> (P <-> (ALL x. Q(x)))
No subgoals left!
> val it = () : unit
(ALL x. P <-> Q(x)) --> (P <-> (ALL x. Q(x)))
> val it = () : unit
Problem 23
> val it = () : unit
(ALL x. P | Q(x)) <-> P | (ALL x. Q(x))
 1. empty
    |-  (ALL x. P | Q(x)) <-> P | (ALL x. Q(x))
> val it = () : unit
(ALL x. P | Q(x)) <-> P | (ALL x. Q(x))
No subgoals left!
> val it = () : unit
(ALL x. P | Q(x)) <-> P | (ALL x. Q(x))
> val it = () : unit
Problem 24
> val it = () : unit
~(EX x. S(x) & Q(x)) &
((ALL x. P(x) --> Q(x) | R(x)) &
 ((~(EX x. P(x)) --> (EX x. Q(x))) &
  (ALL x. Q(x) | R(x) --> S(x)))) -->
(EX x. P(x) & R(x))
 1. empty
    |-  ~(EX x. S(x) & Q(x)) &
        ((ALL x. P(x) --> Q(x) | R(x)) &
         ((~(EX x. P(x)) --> (EX x. Q(x))) &
          (ALL x. Q(x) | R(x) --> S(x)))) -->
        (EX x. P(x) & R(x))
> val it = () : unit
~(EX x. S(x) & Q(x)) &
((ALL x. P(x) --> Q(x) | R(x)) &
 ((~(EX x. P(x)) --> (EX x. Q(x))) &
  (ALL x. Q(x) | R(x) --> S(x)))) -->
(EX x. P(x) & R(x))
No subgoals left!
> val it = () : unit
~(EX x. S(x) & Q(x)) &
((ALL x. P(x) --> Q(x) | R(x)) &
 ((~(EX x. P(x)) --> (EX x. Q(x))) &
  (ALL x. Q(x) | R(x) --> S(x)))) -->
(EX x. P(x) & R(x))
> val it = () : unit
Problem 25
> val it = () : unit
(EX x. P(x)) &
((ALL x. L(x) --> ~(M(x) & R(x))) &
 ((ALL x. P(x) --> M(x) & L(x)) &
  ((ALL x. P(x) --> Q(x)) |
   (EX x. P(x) & R(x))))) --> (EX x. Q(x) & P(x))
 1. empty
    |-  (EX x. P(x)) &
        ((ALL x. L(x) --> ~(M(x) & R(x))) &
         ((ALL x. P(x) --> M(x) & L(x)) &
          ((ALL x. P(x) --> Q(x)) |
           (EX x. P(x) & R(x))))) -->
        (EX x. Q(x) & P(x))
> val it = () : unit
(EX x. P(x)) &
((ALL x. L(x) --> ~(M(x) & R(x))) &
 ((ALL x. P(x) --> M(x) & L(x)) &
  ((ALL x. P(x) --> Q(x)) |
   (EX x. P(x) & R(x))))) --> (EX x. Q(x) & P(x))
No subgoals left!
> val it = () : unit
(EX x. P(x)) &
((ALL x. L(x) --> ~(M(x) & R(x))) &
 ((ALL x. P(x) --> M(x) & L(x)) &
  ((ALL x. P(x) --> Q(x)) |
   (EX x. P(x) & R(x))))) --> (EX x. Q(x) & P(x))
> val it = () : unit
Problem 26
> val it = () : unit
((EX x. p(x)) <-> (EX x. q(x))) &
(ALL x.
   ALL y. p(x) & q(y) --> (r(x) <-> s(y))) -->
((ALL x. p(x) --> r(x)) <->
 (ALL x. q(x) --> s(x)))
 1. empty
    |-  ((EX x. p(x)) <-> (EX x. q(x))) &
        (ALL x.
           ALL y.
             p(x) & q(y) --> (r(x) <-> s(y))) -->
        ((ALL x. p(x) --> r(x)) <->
         (ALL x. q(x) --> s(x)))
> val it = () : unit
((EX x. p(x)) <-> (EX x. q(x))) &
(ALL x.
   ALL y. p(x) & q(y) --> (r(x) <-> s(y))) -->
((ALL x. p(x) --> r(x)) <->
 (ALL x. q(x) --> s(x)))
No subgoals left!
> val it = () : unit
((EX x. p(x)) <-> (EX x. q(x))) &
(ALL x.
   ALL y. p(x) & q(y) --> (r(x) <-> s(y))) -->
((ALL x. p(x) --> r(x)) <->
 (ALL x. q(x) --> s(x)))
> val it = () : unit
Problem 27
> val it = () : unit
(EX x. P(x) & ~Q(x)) &
((ALL x. P(x) --> R(x)) &
 ((ALL x. M(x) & L(x) --> P(x)) &
  ((EX x. R(x) & ~Q(x)) -->
   (ALL x. L(x) --> ~R(x))))) -->
(ALL x. M(x) --> ~L(x))
 1. empty
    |-  (EX x. P(x) & ~Q(x)) &
        ((ALL x. P(x) --> R(x)) &
         ((ALL x. M(x) & L(x) --> P(x)) &
          ((EX x. R(x) & ~Q(x)) -->
           (ALL x. L(x) --> ~R(x))))) -->
        (ALL x. M(x) --> ~L(x))
> val it = () : unit
(EX x. P(x) & ~Q(x)) &
((ALL x. P(x) --> R(x)) &
 ((ALL x. M(x) & L(x) --> P(x)) &
  ((EX x. R(x) & ~Q(x)) -->
   (ALL x. L(x) --> ~R(x))))) -->
(ALL x. M(x) --> ~L(x))
No subgoals left!
> val it = () : unit
(EX x. P(x) & ~Q(x)) &
((ALL x. P(x) --> R(x)) &
 ((ALL x. M(x) & L(x) --> P(x)) &
  ((EX x. R(x) & ~Q(x)) -->
   (ALL x. L(x) --> ~R(x))))) -->
(ALL x. M(x) --> ~L(x))
> val it = () : unit
Problem 28.  AMENDED
> val it = () : unit
(ALL x. P(x) --> (ALL x. Q(x))) &
(((ALL x. Q(x) | R(x)) --> (EX x. Q(x) & S(x))) &
 ((EX x. S(x)) --> (ALL x. L(x) --> M(x)))) -->
(ALL x. P(x) & L(x) --> M(x))
 1. empty
    |-  (ALL x. P(x) --> (ALL x. Q(x))) &
        (((ALL x. Q(x) | R(x)) -->
          (EX x. Q(x) & S(x))) &
         ((EX x. S(x)) -->
          (ALL x. L(x) --> M(x)))) -->
        (ALL x. P(x) & L(x) --> M(x))
> val it = () : unit
(ALL x. P(x) --> (ALL x. Q(x))) &
(((ALL x. Q(x) | R(x)) --> (EX x. Q(x) & S(x))) &
 ((EX x. S(x)) --> (ALL x. L(x) --> M(x)))) -->
(ALL x. P(x) & L(x) --> M(x))
No subgoals left!
> val it = () : unit
(ALL x. P(x) --> (ALL x. Q(x))) &
(((ALL x. Q(x) | R(x)) --> (EX x. Q(x) & S(x))) &
 ((EX x. S(x)) --> (ALL x. L(x) --> M(x)))) -->
(ALL x. P(x) & L(x) --> M(x))
> val it = () : unit
Problem 29.  Essentially the same as Principia Mathematica *11.71
> val it = () : unit
(EX x. P(x)) & (EX y. Q(y)) -->
((ALL x. P(x) --> R(x)) &
 (ALL y. Q(y) --> S(y)) <->
 (ALL x. ALL y. P(x) & Q(y) --> R(x) & S(y)))
 1. empty
    |-  (EX x. P(x)) & (EX y. Q(y)) -->
        ((ALL x. P(x) --> R(x)) &
         (ALL y. Q(y) --> S(y)) <->
         (ALL x.
            ALL y. P(x) & Q(y) --> R(x) & S(y)))
> val it = () : unit
(EX x. P(x)) & (EX y. Q(y)) -->
((ALL x. P(x) --> R(x)) &
 (ALL y. Q(y) --> S(y)) <->
 (ALL x. ALL y. P(x) & Q(y) --> R(x) & S(y)))
No subgoals left!
> val it = () : unit
(EX x. P(x)) & (EX y. Q(y)) -->
((ALL x. P(x) --> R(x)) &
 (ALL y. Q(y) --> S(y)) <->
 (ALL x. ALL y. P(x) & Q(y) --> R(x) & S(y)))
> val it = () : unit
Problem 30
> val it = () : unit
(ALL x. P(x) | Q(x) --> ~R(x)) &
(ALL x. (Q(x) --> ~S(x)) --> P(x) & R(x)) -->
(ALL x. S(x))
 1. empty
    |-  (ALL x. P(x) | Q(x) --> ~R(x)) &
        (ALL x.
           (Q(x) --> ~S(x)) --> P(x) & R(x)) -->
        (ALL x. S(x))
> val it = () : unit
(ALL x. P(x) | Q(x) --> ~R(x)) &
(ALL x. (Q(x) --> ~S(x)) --> P(x) & R(x)) -->
(ALL x. S(x))
No subgoals left!
> val it = () : unit
(ALL x. P(x) | Q(x) --> ~R(x)) &
(ALL x. (Q(x) --> ~S(x)) --> P(x) & R(x)) -->
(ALL x. S(x))
> val it = () : unit
Problem 31.  
> val it = () : unit
~(EX x. P(x) & (Q(x) | R(x))) &
((EX x. L(x) & P(x)) &
 (ALL x. ~R(x) --> M(x))) --> (EX x. L(x) & M(x))
 1. empty
    |-  ~(EX x. P(x) & (Q(x) | R(x))) &
        ((EX x. L(x) & P(x)) &
         (ALL x. ~R(x) --> M(x))) -->
        (EX x. L(x) & M(x))
> val it = () : unit
~(EX x. P(x) & (Q(x) | R(x))) &
((EX x. L(x) & P(x)) &
 (ALL x. ~R(x) --> M(x))) --> (EX x. L(x) & M(x))
No subgoals left!
> val it = () : unit
~(EX x. P(x) & (Q(x) | R(x))) &
((EX x. L(x) & P(x)) &
 (ALL x. ~R(x) --> M(x))) --> (EX x. L(x) & M(x))
> val it = () : unit
Problem 32.  
> val it = () : unit
(ALL x. P(x) & (Q(x) | R(x)) --> S(x)) &
((ALL x. S(x) & R(x) --> L(x)) &
 (ALL x. M(x) --> R(x))) -->
(ALL x. P(x) & M(x) --> L(x))
 1. empty
    |-  (ALL x. P(x) & (Q(x) | R(x)) --> S(x)) &
        ((ALL x. S(x) & R(x) --> L(x)) &
         (ALL x. M(x) --> R(x))) -->
        (ALL x. P(x) & M(x) --> L(x))
> val it = () : unit
(ALL x. P(x) & (Q(x) | R(x)) --> S(x)) &
((ALL x. S(x) & R(x) --> L(x)) &
 (ALL x. M(x) --> R(x))) -->
(ALL x. P(x) & M(x) --> L(x))
No subgoals left!
> val it = () : unit
(ALL x. P(x) & (Q(x) | R(x)) --> S(x)) &
((ALL x. S(x) & R(x) --> L(x)) &
 (ALL x. M(x) --> R(x))) -->
(ALL x. P(x) & M(x) --> L(x))
> val it = () : unit
Problem 33
> val it = () : unit
(ALL x. P(a) & (P(x) --> P(b)) --> P(c)) <->
(ALL x.
   (~P(a) | (P(x) | P(c))) &
   (~P(a) | (~P(b) | P(c))))
 1. empty
    |-  (ALL x.
           P(a) & (P(x) --> P(b)) --> P(c)) <->
        (ALL x.
           (~P(a) | (P(x) | P(c))) &
           (~P(a) | (~P(b) | P(c))))
> val it = () : unit
(ALL x. P(a) & (P(x) --> P(b)) --> P(c)) <->
(ALL x.
   (~P(a) | (P(x) | P(c))) &
   (~P(a) | (~P(b) | P(c))))
No subgoals left!
> val it = () : unit
(ALL x. P(a) & (P(x) --> P(b)) --> P(c)) <->
(ALL x.
   (~P(a) | (P(x) | P(c))) &
   (~P(a) | (~P(b) | P(c))))
> val it = () : unit
Problem 34  AMENDED (TWICE!!)
> val it = () : unit
((EX x. ALL y. p(x) <-> p(y)) <->
 ((EX x. q(x)) <-> (ALL y. p(y)))) <->
((EX x. ALL y. q(x) <-> q(y)) <->
 ((EX x. p(x)) <-> (ALL y. q(y))))
 1. empty
    |-  ((EX x. ALL y. p(x) <-> p(y)) <->
         ((EX x. q(x)) <-> (ALL y. p(y)))) <->
        ((EX x. ALL y. q(x) <-> q(y)) <->
         ((EX x. p(x)) <-> (ALL y. q(y))))
> val it = () : unit
((EX x. ALL y. p(x) <-> p(y)) <->
 ((EX x. q(x)) <-> (ALL y. p(y)))) <->
((EX x. ALL y. q(x) <-> q(y)) <->
 ((EX x. p(x)) <-> (ALL y. q(y))))
No subgoals left!
> val it = () : unit
((EX x. ALL y. p(x) <-> p(y)) <->
 ((EX x. q(x)) <-> (ALL y. p(y)))) <->
((EX x. ALL y. q(x) <-> q(y)) <->
 ((EX x. p(x)) <-> (ALL y. q(y))))
> val it = () : unit
Problem 35.  
> val it = () : unit
EX x. EX y. P(x, y) --> (ALL u. ALL v. P(u, v))
 1. empty
    |-  EX x.
          EX y.
            P(x, y) --> (ALL u. ALL v. P(u, v))
> val it = () : unit
EX x. EX y. P(x, y) --> (ALL u. ALL v. P(u, v))
No subgoals left!
> val it = () : unit
EX x. EX y. P(x, y) --> (ALL u. ALL v. P(u, v))
> val it = () : unit
Problem 36. 
> val it = () : unit
(ALL x. EX y. J(x, y)) &
((ALL x. EX y. G(x, y)) &
 (ALL x.
    ALL y.
      J(x, y) | G(x, y) -->
      (ALL z. J(y, z) | G(y, z) --> H(x, z)))) -->
(ALL x. EX y. H(x, y))
 1. empty
    |-  (ALL x. EX y. J(x, y)) &
        ((ALL x. EX y. G(x, y)) &
         (ALL x.
            ALL y.
              J(x, y) | G(x, y) -->
              (ALL z.
                 J(y, z) | G(y, z) -->
                 H(x, z)))) -->
        (ALL x. EX y. H(x, y))
> val it = () : unit
(ALL x. EX y. J(x, y)) &
((ALL x. EX y. G(x, y)) &
 (ALL x.
    ALL y.
      J(x, y) | G(x, y) -->
      (ALL z. J(y, z) | G(y, z) --> H(x, z)))) -->
(ALL x. EX y. H(x, y))
No subgoals left!
> val it = () : unit
(ALL x. EX y. J(x, y)) &
((ALL x. EX y. G(x, y)) &
 (ALL x.
    ALL y.
      J(x, y) | G(x, y) -->
      (ALL z. J(y, z) | G(y, z) --> H(x, z)))) -->
(ALL x. EX y. H(x, y))
> val it = () : unit
Problem 37
> val it = () : unit
(ALL z.
   EX w.
     ALL x.
       EX y.
         (P(x, z) --> P(y, w)) &
         (P(y, z) &
          (P(y, w) --> (EX u. Q(u, w))))) &
((ALL x. ALL z. ~P(x, z) --> (EX y. Q(y, z))) &
 ((EX x. EX y. Q(x, y)) --> (ALL x. R(x, x)))) -->
(ALL x. EX y. R(x, y))
 1. empty
    |-  (ALL z.
           EX w.
             ALL x.
               EX y.
                 (P(x, z) --> P(y, w)) &
                 (P(y, z) &
                  (P(y, w) -->
                   (EX u. Q(u, w))))) &
        ((ALL x.
            ALL z. ~P(x, z) --> (EX y. Q(y, z))) &
         ((EX x. EX y. Q(x, y)) -->
          (ALL x. R(x, x)))) -->
        (ALL x. EX y. R(x, y))
> val it = () : unit
(ALL z.
   EX w.
     ALL x.
       EX y.
         (P(x, z) --> P(y, w)) &
         (P(y, z) &
          (P(y, w) --> (EX u. Q(u, w))))) &
((ALL x. ALL z. ~P(x, z) --> (EX y. Q(y, z))) &
 ((EX x. EX y. Q(x, y)) --> (ALL x. R(x, x)))) -->
(ALL x. EX y. R(x, y))
No subgoals left!
> val it = () : unit
(ALL z.
   EX w.
     ALL x.
       EX y.
         (P(x, z) --> P(y, w)) &
         (P(y, z) &
          (P(y, w) --> (EX u. Q(u, w))))) &
((ALL x. ALL z. ~P(x, z) --> (EX y. Q(y, z))) &
 ((EX x. EX y. Q(x, y)) --> (ALL x. R(x, x)))) -->
(ALL x. EX y. R(x, y))
> val it = () : unit
Problem 38. NOT PROVED
> val it = () : unit
(ALL x.
   p(a) & (p(x) --> (EX y. p(y) & r(x, y))) -->
   (EX z. EX w. p(z) & (r(x, w) & r(w, z)))) <->
(ALL x.
   (~p(a) |
    (p(x) |
     (EX z. EX w. p(z) & (r(x, w) & r(w, z))))) &
   (~p(a) |
    (~(EX y. p(y) & r(x, y)) |
     (EX z. EX w. p(z) & (r(x, w) & r(w, z))))))
 1. empty
    |-  (ALL x.
           p(a) &
           (p(x) --> (EX y. p(y) & r(x, y))) -->
           (EX z.
              EX w.
                p(z) & (r(x, w) & r(w, z)))) <->
        (ALL x.
           (~p(a) |
            (p(x) |
             (EX z.
                EX w.
                  p(z) & (r(x, w) & r(w, z))))) &
           (~p(a) |
            (~(EX y. p(y) & r(x, y)) |
             (EX z.
                EX w.
                  p(z) & (r(x, w) & r(w, z))))))
> val it = () : unit
Problem 39
> val it = () : unit
~(EX x. ALL y. J(x, y) <-> ~J(y, y))
 1. empty
    |-  ~(EX x. ALL y. J(x, y) <-> ~J(y, y))
> val it = () : unit
~(EX x. ALL y. J(x, y) <-> ~J(y, y))
No subgoals left!
> val it = () : unit
~(EX x. ALL y. J(x, y) <-> ~J(y, y))
> val it = () : unit
Problem 40. AMENDED
> val it = () : unit
(EX y. ALL x. J(y, x) <-> ~J(x, x)) -->
~(ALL x. EX y. ALL z. J(z, y) <-> ~J(z, x))
 1. empty
    |-  (EX y. ALL x. J(y, x) <-> ~J(x, x)) -->
        ~(ALL x.
            EX y. ALL z. J(z, y) <-> ~J(z, x))
> val it = () : unit
(EX y. ALL x. J(y, x) <-> ~J(x, x)) -->
~(ALL x. EX y. ALL z. J(z, y) <-> ~J(z, x))
No subgoals left!
> val it = () : unit
(EX y. ALL x. J(y, x) <-> ~J(x, x)) -->
~(ALL x. EX y. ALL z. J(z, y) <-> ~J(z, x))
> val it = () : unit
Problem 41
> val it = () : unit
(ALL z.
   EX y.
     ALL x. f(x, y) <-> f(x, z) & ~f(x, x)) -->
~(EX z. ALL x. f(x, z))
 1. empty
    |-  (ALL z.
           EX y.
             ALL x.
               f(x, y) <-> f(x, z) & ~f(x, x)) -->
        ~(EX z. ALL x. f(x, z))
> val it = () : unit
(ALL z.
   EX y.
     ALL x. f(x, y) <-> f(x, z) & ~f(x, x)) -->
~(EX z. ALL x. f(x, z))
No subgoals left!
> val it = () : unit
(ALL z.
   EX y.
     ALL x. f(x, y) <-> f(x, z) & ~f(x, x)) -->
~(EX z. ALL x. f(x, z))
> val it = () : unit
Problem 42
> val it = () : unit
~(EX y.
    ALL x. p(x, y) <-> ~(EX z. p(x, z) & p(z, x)))
 1. empty
    |-  ~(EX y.
            ALL x.
              p(x, y) <->
              ~(EX z. p(x, z) & p(z, x)))
> val it = () : unit
~(EX y.
    ALL x. p(x, y) <-> ~(EX z. p(x, z) & p(z, x)))
No subgoals left!
> val it = () : unit
~(EX y.
    ALL x. p(x, y) <-> ~(EX z. p(x, z) & p(z, x)))
> val it = () : unit
Problem 43 NOT PROVED
> val it = () : unit
(ALL x.
   ALL y.
     q(x, y) <-> (ALL z. p(z, x) <-> p(z, y))) -->
(ALL x. ALL y. q(x, y) <-> q(y, x))
 1. empty
    |-  (ALL x.
           ALL y.
             q(x, y) <->
             (ALL z. p(z, x) <-> p(z, y))) -->
        (ALL x. ALL y. q(x, y) <-> q(y, x))
> val it = () : unit
Problem 44
> val it = () : unit
(ALL x.
   f(x) -->
   (EX y.
      g(y) &
      (h(x, y) & (EX y. g(y) & ~h(x, y))))) &
(EX x. j(x) & (ALL y. g(y) --> h(x, y))) -->
(EX x. j(x) & ~f(x))
 1. empty
    |-  (ALL x.
           f(x) -->
           (EX y.
              g(y) &
              (h(x, y) &
               (EX y. g(y) & ~h(x, y))))) &
        (EX x.
           j(x) & (ALL y. g(y) --> h(x, y))) -->
        (EX x. j(x) & ~f(x))
> val it = () : unit
(ALL x.
   f(x) -->
   (EX y.
      g(y) &
      (h(x, y) & (EX y. g(y) & ~h(x, y))))) &
(EX x. j(x) & (ALL y. g(y) --> h(x, y))) -->
(EX x. j(x) & ~f(x))
No subgoals left!
> val it = () : unit
(ALL x.
   f(x) -->
   (EX y.
      g(y) &
      (h(x, y) & (EX y. g(y) & ~h(x, y))))) &
(EX x. j(x) & (ALL y. g(y) --> h(x, y))) -->
(EX x. j(x) & ~f(x))
> val it = () : unit
Problem 45
> val it = () : unit
(ALL x.
   f(x) & (ALL y. g(y) & h(x, y) --> j(x, y)) -->
   (ALL y. g(y) & h(x, y) --> k(y))) &
(~(EX y. l(y) & k(y)) &
 (EX x.
    f(x) &
    ((ALL y. h(x, y) --> l(y)) &
     (ALL y. g(y) & h(x, y) --> j(x, y))))) -->
(EX x. f(x) & ~(EX y. g(y) & h(x, y)))
 1. empty
    |-  (ALL x.
           f(x) &
           (ALL y. g(y) & h(x, y) --> j(x, y)) -->
           (ALL y. g(y) & h(x, y) --> k(y))) &
        (~(EX y. l(y) & k(y)) &
         (EX x.
            f(x) &
            ((ALL y. h(x, y) --> l(y)) &
             (ALL y.
                g(y) & h(x, y) --> j(x, y))))) -->
        (EX x. f(x) & ~(EX y. g(y) & h(x, y)))
> val it = () : unit
(ALL x.
   f(x) & (ALL y. g(y) & h(x, y) --> j(x, y)) -->
   (ALL y. g(y) & h(x, y) --> k(y))) &
(~(EX y. l(y) & k(y)) &
 (EX x.
    f(x) &
    ((ALL y. h(x, y) --> l(y)) &
     (ALL y. g(y) & h(x, y) --> j(x, y))))) -->
(EX x. f(x) & ~(EX y. g(y) & h(x, y)))
No subgoals left!
> val it = () : unit
(ALL x.
   f(x) & (ALL y. g(y) & h(x, y) --> j(x, y)) -->
   (ALL y. g(y) & h(x, y) --> k(y))) &
(~(EX y. l(y) & k(y)) &
 (EX x.
    f(x) &
    ((ALL y. h(x, y) --> l(y)) &
     (ALL y. g(y) & h(x, y) --> j(x, y))))) -->
(EX x. f(x) & ~(EX y. g(y) & h(x, y)))
> val it = () : unit
Problem 46
> val it = () : unit
(ALL x.
   f(x) & (ALL y. f(y) & h(y, x) --> g(y)) -->
   g(x)) &
(((EX x. f(x) & ~g(x)) -->
  (EX x.
     f(x) &
     (~g(x) &
      (ALL y. f(y) & ~g(y) --> j(x, y))))) &
 (ALL x.
    ALL y.
      f(x) & (f(y) & h(x, y)) --> ~j(y, x))) -->
(ALL x. f(x) --> g(x))
 1. empty
    |-  (ALL x.
           f(x) &
           (ALL y. f(y) & h(y, x) --> g(y)) -->
           g(x)) &
        (((EX x. f(x) & ~g(x)) -->
          (EX x.
             f(x) &
             (~g(x) &
              (ALL y.
                 f(y) & ~g(y) --> j(x, y))))) &
         (ALL x.
            ALL y.
              f(x) & (f(y) & h(x, y)) -->
              ~j(y, x))) -->
        (ALL x. f(x) --> g(x))
> val it = () : unit
(ALL x.
   f(x) & (ALL y. f(y) & h(y, x) --> g(y)) -->
   g(x)) &
(((EX x. f(x) & ~g(x)) -->
  (EX x.
     f(x) &
     (~g(x) &
      (ALL y. f(y) & ~g(y) --> j(x, y))))) &
 (ALL x.
    ALL y.
      f(x) & (f(y) & h(x, y)) --> ~j(y, x))) -->
(ALL x. f(x) --> g(x))
No subgoals left!
> val it = () : unit
(ALL x.
   f(x) & (ALL y. f(y) & h(y, x) --> g(y)) -->
   g(x)) &
(((EX x. f(x) & ~g(x)) -->
  (EX x.
     f(x) &
     (~g(x) &
      (ALL y. f(y) & ~g(y) --> j(x, y))))) &
 (ALL x.
    ALL y.
      f(x) & (f(y) & h(x, y)) --> ~j(y, x))) -->
(ALL x. f(x) --> g(x))
> val it = () : unit
(ALL x.
   ALL y.
     ALL z. P(x, y) --> (P(y, z) --> P(x, z))) -->
((ALL x.
    ALL y.
      ALL z.
        Q(x, y) --> (Q(y, z) --> Q(x, z))) -->
 ((ALL x. ALL y. Q(x, y) --> Q(y, x)) -->
  ((ALL x. ALL y. P(x, y) | Q(x, y)) -->
   (ALL x. ALL y. P(x, y)) |
   (ALL x. ALL y. Q(x, y)))))
 1. empty
    |-  (ALL x.
           ALL y.
             ALL z.
               P(x, y) -->
               (P(y, z) --> P(x, z))) -->
        ((ALL x.
            ALL y.
              ALL z.
                Q(x, y) -->
                (Q(y, z) --> Q(x, z))) -->
         ((ALL x. ALL y. Q(x, y) --> Q(y, x)) -->
          ((ALL x. ALL y. P(x, y) | Q(x, y)) -->
           (ALL x. ALL y. P(x, y)) |
           (ALL x. ALL y. Q(x, y)))))
> val it = () : unit
Problem 47  Schubert's Steamroller
> val it = () : unit
(ALL x. P1(x) --> P0(x)) &
((EX x. P1(x)) &
 ((ALL x. P2(x) --> P0(x)) &
  ((EX x. P2(x)) &
   ((ALL x. P3(x) --> P0(x)) &
    ((EX x. P3(x)) &
     ((ALL x. P4(x) --> P0(x)) &
      ((EX x. P4(x)) &
       ((ALL x. P5(x) --> P0(x)) &
        ((EX x. P5(x)) &
         ((ALL x. Q1(x) --> Q0(x)) &
          ((EX x. Q1(x)) &
           ((ALL x.
               P0(x) -->
               (ALL y. Q0(y) --> R(x, y)) |
               (ALL y.
                  P0(y) &
                  (S(y, x) &
                   (EX z. Q0(z) & R(y, z))) -->
                  R(x, y))) &
            ((ALL x.
                ALL y.
                  P3(y) & (P5(x) | P4(x)) -->
                  S(x, y)) &
             ((ALL x.
                 ALL y.
                   P3(x) & P2(y) --> S(x, y)) &
              ((ALL x.
                  ALL y.
                    P2(x) & P1(y) --> S(x, y)) &
               ((ALL x.
                   ALL y.
                     P1(x) & (P2(y) | Q1(y)) -->
                     ~R(x, y)) &
                ((ALL x.
                    ALL y.
                      P3(x) & P4(y) --> R(x, y)) &
                 ((ALL x.
                     ALL y.
                       P3(x) & P5(y) -->
                       ~R(x, y)) &
                  (ALL x.
                     P4(x) | P5(x) -->
                     (EX y.
                        Q0(y) &
                        R(x,
                          y))))))))))))))))))))) -->
(EX x.
   EX y.
     P0(x) &
     (P0(y) &
      (EX z. Q1(z) & (R(y, z) & R(x, y)))))
 1. empty
    |-  (ALL x. P1(x) --> P0(x)) &
        ((EX x. P1(x)) &
         ((ALL x. P2(x) --> P0(x)) &
          ((EX x. P2(x)) &
           ((ALL x. P3(x) --> P0(x)) &
            ((EX x. P3(x)) &
             ((ALL x. P4(x) --> P0(x)) &
              ((EX x. P4(x)) &
               ((ALL x. P5(x) --> P0(x)) &
                ((EX x. P5(x)) &
                 ((ALL x. Q1(x) --> Q0(x)) &
                  ((EX x. Q1(x)) &
                   ((ALL x.
                       P0(x) -->
                       (ALL y.
                          Q0(y) --> R(x, y)) |
                       (ALL y.
                          P0(y) &
                          (S(y, x) &
                           (EX z.
                              Q0(z) &
                              R(y, z))) -->
                          R(x, y))) &
                    ((ALL x.
                        ALL y.
                          P3(y) &
                          (P5(x) | P4(x)) -->
                          S(x, y)) &
                     ((ALL x.
                         ALL y.
                           P3(x) & P2(y) -->
                           S(x, y)) &
                      ((ALL x.
                          ALL y.
                            P2(x) & P1(y) -->
                            S(x, y)) &
                       ((ALL x.
                           ALL y.
                             P1(x) &
                             (P2(y) | Q1(y)) -->
                             ~R(x, y)) &
                        ((ALL x.
                            ALL y.
                              P3(x) & P4(y) -->
                              R(x, y)) &
                         ((ALL x.
                             ALL y.
                               P3(x) & P5(y) -->
                               ~R(x, y)) &
                          (ALL x.
                             P4(x) | P5(x) -->
                             (EX y.
                                Q0(y) &
                                R(x,
                                  y))))))))))))))))))))) -->
        (EX x.
           EX y.
             P0(x) &
             (P0(y) &
              (EX z.
                 Q1(z) & (R(y, z) & R(x, y)))))
> val it = () : unit
Reached end of file.
> val it = () : unit
[closing file "test10.sml"]
> val it = () : unit
