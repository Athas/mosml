<HTML><HEAD><TITLE>Structure Weak</TITLE></HEAD>
<BODY BGCOLOR="#fbf2e7">
<H1>Structure Weak</H1>
<HR><TABLE WIDTH=100%><TR ALIGN = CENTER>
<TH><A HREF="idIndex.html">Identifier index</A>
<TH><A HREF="index.html">Structure index</A>
</TABLE><HR>
<PRE>
<A NAME="line1"></A>(* Weak --- weak pointers and arrays of weak pointers *)
<A NAME="line2"></A>
<A NAME="line3"></A>signature Weak = sig
<A NAME="line4"></A>
<A NAME="line5"></A>(* Weak pointers *)
<A NAME="line6"></A>
<A NAME="line7"></A>type <A NAME="line7"></A>'a weak
<A NAME="line8"></A>val <A NAME="line8"></A><A HREF="#weak">weak</A>    : 'a -&gt; 'a weak
<A NAME="line9"></A>val <A NAME="line9"></A><A HREF="#set">set</A>     : 'a weak * 'a -&gt; unit
<A NAME="line10"></A>val <A NAME="line10"></A><A HREF="#get">get</A>     : 'a weak -&gt; 'a                  (* Raises Fail *)
<A NAME="line11"></A>val <A NAME="line11"></A><A HREF="#isweak">isweak</A>  : 'a weak -&gt; bool
<A NAME="line12"></A>
<A NAME="line13"></A>(* Arrays of weak pointers *)
<A NAME="line14"></A>
<A NAME="line15"></A>prim_EQtype 'a array
<A NAME="line16"></A>
<A NAME="line17"></A>val <A NAME="line17"></A><A HREF="#maxLen">maxLen</A>  : int
<A NAME="line18"></A>
<A NAME="line19"></A>val <A NAME="line19"></A><A HREF="#array">array</A>   : int -&gt; '_a array               (* Raises Size               *)
<A NAME="line20"></A>val <A NAME="line20"></A><A HREF="#sub">sub</A>     : 'a array * int -&gt; 'a           (* Raises Fail and Subscript *)
<A NAME="line21"></A>val <A NAME="line21"></A><A HREF="#update">update</A>  : 'a array * int * 'a -&gt; unit    (* Raises Subscript          *)
<A NAME="line22"></A>val <A NAME="line22"></A><A HREF="#isdead">isdead</A>  : 'a array * int -&gt; bool         (* Raises Subscript          *)
<A NAME="line23"></A>val <A NAME="line23"></A><A HREF="#length">length</A>  : 'a array -&gt; int
<A NAME="line24"></A>
<A NAME="line25"></A>val <A NAME="line25"></A><A HREF="#app">app</A>     : ('a -&gt; unit) -&gt; 'a array -&gt; unit
<A NAME="line26"></A>val <A NAME="line26"></A><A HREF="#foldl">foldl</A>   : ('a * 'b -&gt; 'b) -&gt; 'b -&gt; 'a array -&gt; 'b
<A NAME="line27"></A>val <A NAME="line27"></A><A HREF="#foldr">foldr</A>   : ('a * 'b -&gt; 'b) -&gt; 'b -&gt; 'a array -&gt; 'b
<A NAME="line28"></A>val <A NAME="line28"></A><A HREF="#modify">modify</A>  : ('a -&gt; 'a) -&gt; 'a array -&gt; unit
<A NAME="line29"></A>
<A NAME="line30"></A>val <A NAME="line30"></A><A HREF="#appi">appi</A>    : (int * 'a -&gt; unit) -&gt; 'a array * int * int option -&gt; unit
<A NAME="line31"></A>val <A NAME="line31"></A><A HREF="#foldli">foldli</A>  : (int * 'a * 'b -&gt; 'b) -&gt; 'b -&gt; 'a array * int * int option 
<A NAME="line32"></A>              -&gt; 'b
<A NAME="line33"></A>val <A NAME="line33"></A><A HREF="#foldri">foldri</A>  : (int * 'a * 'b -&gt; 'b) -&gt; 'b -&gt; 'a array * int * int option 
<A NAME="line34"></A>              -&gt; 'b
<A NAME="line35"></A>val <A NAME="line35"></A><A HREF="#modifyi">modifyi</A> : (int * 'a -&gt; 'a) -&gt; 'a array * int * int option -&gt; unit
<A NAME="line36"></A>
<A NAME="line37"></A>end
<A NAME="line38"></A>
<A NAME="line39"></A>(*
<A NAME="line40"></A>   Type 'a weak is the type of weak pointers to objects of type 'a.  A
<A NAME="line41"></A>   weak pointer is a pointer that cannot itself keep an object alive.
<A NAME="line42"></A>   Hence the object pointed to by a weak pointer may be deallocated by
<A NAME="line43"></A>   the garbage collector if the object is reachable only by weak
<A NAME="line44"></A>   pointers.  In this case, subsequent accesses via the `get' function
<A NAME="line45"></A>   will raise Fail "Dangling weak pointer".  (We raise an exception
<A NAME="line46"></A>   instead of returning an option value, because access via a weak
<A NAME="line47"></A>   pointer to a deallocated object is likely to be a programming
<A NAME="line48"></A>   error).
<A NAME="line49"></A>
<A NAME="line50"></A>   Integers, characters, words and booleans will not be deallocated by
<A NAME="line51"></A>   the garbage collector and will remain reachable forever by a weak
<A NAME="line52"></A>   pointer.  Reals, strings, tuples and other non-nullary constructors
<A NAME="line53"></A>   may be deallocated by the garbage collector.  Constants, even
<A NAME="line54"></A>   composite ones, will not be deallocated either.
<A NAME="line55"></A>
   [<A NAME="weak"><B>weak</B></A> v] creates and returns a weak pointer to value v.

   [<A NAME="get"><B>get</B></A> w] returns the value pointed to by weak pointer w, if the
   value is still alive.  Otherwise raises Fail "Dangling weak pointer".

   [<A NAME="set"><B>set</B></A>(w, v)] makes the weak pointer w point to the value v.

   [<A NAME="isweak"><B>isweak</B></A> w] returns true if the value pointed to by w is dead;
   returns false otherwise.  If an object is reported to be dead, it
   remains dead.  However, an object is reported to be live just if it
   has not yet been deallocated by the garbage collector.  The
   allocation of any new value may activate the garbage collector and
   cause the object to die.  Thus
        if not (isweak w) then get w else "blah" 
   will not raise exception Fail, whereas the following might:
        if not (isweak w) then ([1,2] @ [3,4]; get w) else "blah" 
   because evaluation of the list append may cause w to die.

   The value of isweak w is the same as that of
         (get w; false) handle Fail _ =&gt; true
   but evaluating the latter expression may have the side effect of
   keeping w alive for slightly longer, because a pointer to w is
   returned by get w.

   ---

   Type 'a array is the type of arrays of weak pointers to objects of
   type 'a.  

   A value of type 'a Weak.weak (above) is equivalent to, but more
   efficient than, a one-element 'a Weak.array.  On the other hand, an
   'a Weak.array is more efficient than an ('a Weak.weak) Array.array.

   [<A NAME="array"><B>array</B></A> n] creates an array of n weak pointers.  Initially, any
   access to the array will raise Fail.

   [<A NAME="sub"><B>sub</B></A>(a, i)] returns the object pointed to by cell i (counting from
   0) of the array a, if it is live.  Raises Fail "Dangling weak
   pointer" if cell i has never been updated or if the object pointed
   to has been deallocated by the garbage collector.  Raises Subscript
   if i&lt;0 or i&gt;=length a.  To make `sub' infix, use the declaration
                             infix 9 sub

   [<A NAME="update"><B>update</B></A>(a, i, v)] updates cell i of array a to point (weakly) to
   the value v.  Raises Subscript if i&lt;0 or i&gt;=length a.

   [<A NAME="isdead"><B>isdead</B></A>(a, i)] returns true if the object in cell i of array a is
   dead, and false otherwise.  Analogous to isweak; see above.

   [<A NAME="length"><B>length</B></A> a] returns the number of elements in a.

   [<A NAME="maxLen"><B>maxLen</B></A>] is the maximal number of elements in an array.

   The iterators described below operate on the live elements only.
   Note that an element a[k] may die in the course of folding f over
   earlier elements (e.g. a[1] ... a[k-1]).  Thus the functions should
   be used with great care.

   [<A NAME="foldl"><B>foldl</B></A> f e a] folds function f over the live elements of a, from
   left to right.  

   [<A NAME="foldr"><B>foldr</B></A> f e a] folds function f over the live elements of a, from
   right to left.

   [<A NAME="app"><B>app</B></A> f a] applies f to the live elements of a from left to right.

   [<A NAME="modify"><B>modify</B></A> f a] applies f to a[j] and updates a[j] with the result
   f(a[j]), for each live element a[j], from left to right.

   The following iterators generalize the above ones in two ways:

    . the index j is also being passed to the function being iterated;
    . the iterators work on a slice (subarray) of an array.

   The slice (a, i, SOME n) denotes the subarray a[i..i+n-1].  That is,
   a[i] is the first element of the slice, and n is the length of the
   slice.  Valid only if 0 &lt;= i &lt;= i+n &lt;= length a.

   The slice (a, i, NONE) denotes the subarray a[i..length a-1].  That
   is, the slice denotes the suffix of the array starting at i.  Valid
   only if 0 &lt;= i &lt;= length a.  Equivalent to (a, i, SOME(length a - i)).

       slice             meaning 
       ----------------------------------------------------------
       (a, 0, NONE)      the whole array              a[0..len-1]   
       (a, 0, SOME n)    a left subarray (prefix)     a[0..n-1]
       (a, i, NONE)      a right subarray (suffix)    a[i..len-1]
       (a, i, SOME n)    a general slice              a[i..i+n-1] 

   [<A NAME="foldli"><B>foldli</B></A> f e (a, i, SOME n)] folds function f over the live elements
   of the subarray a[i..i+n-1] from left to right.  Raises Subscript
   if i&lt;0 or n&lt;0 or i+n &gt; length a.

   [<A NAME="foldli"><B>foldli</B></A> f e (a, i, NONE)] folds function f over the live elements
   of the subarray a[i..len-1] from left to right, where len = length
   a.  Raises Subscript if i&lt;0 or i &gt; length a.

   [<A NAME="foldri"><B>foldri</B></A> f e (a, i, SOME n)] folds function f over the live elements
   of the subarray a[i..i+n-1] from right to left.  Raises Subscript
   if i&lt;0 or n&lt;0 or i+n &gt; length a.

   [<A NAME="foldri"><B>foldri</B></A> f e (a, i, NONE)] folds function f over the live elements
   of the subarray a[i..len-1] from right to left, where len = length
   a.  Raises Subscript if i&lt;0 or i &gt; length a.

   [<A NAME="appi"><B>appi</B></A> f (a, i, SOME n)] applies f to successive pairs (j, a[j]) for
   j=i,i+1,...,i+n-1, provided a[j] is live.  Raises Subscript if i&lt;0
   or n&lt;0 or i+n &gt; length a.

   [<A NAME="appi"><B>appi</B></A> f (a, i, NONE)] applies f to successive pairs (j, a[j]) for
   j=i,i+1,...,len-1, where len = length a, provided a[j] is live.
   Raises Subscript if i&lt;0 or i &gt; length a.

   [<A NAME="modifyi"><B>modifyi</B></A> f (a, i, SOME n)] applies f to (j, a[j]) and updates a[j]
   with the result f(j, a[j]) for j=i,i+1,...,i+n-1, provided a[j] is
   live.  Raises Subscript if i&lt;0 or n&lt;0 or i+n &gt; length a.

   [<A NAME="modifyi"><B>modifyi</B></A> f (a, i, NONE)] applies f to (j, a[j]) and updates a[j]
   with the result f(j, a[j]) for j=i,i+1,...,len-1, provided a[j] is
   live.  Raises Subscript if i&lt;0 or i &gt; length a.  
*)

</PRE><HR><TABLE WIDTH=100%><TR ALIGN = CENTER>
<TH><A HREF="idIndex.html">Identifier index</A>
<TH><A HREF="index.html">Structure index</A>
</TABLE><HR>
<BR><EM>Moscow ML 1.44</EM></BODY></HTML>
