<HTML><HEAD><TITLE>Structure Word8</TITLE></HEAD>
<BODY BGCOLOR="#fbf2e7">
<H1>Structure Word8</H1>
<HR><TABLE WIDTH=100%><TR ALIGN = CENTER>
<TH><A HREF="idIndex.html">Identifier index</A>
<TH><A HREF="index.html">Structure index</A>
</TABLE><HR>
<PRE>
<A NAME="line1"></A>(* Word8 -- SML Basis Library *)
<A NAME="line2"></A>
<A NAME="line3"></A>type <A NAME="line3"></A>word = word8
<A NAME="line4"></A>val <A NAME="line4"></A><A HREF="#wordSize">wordSize</A> : int
<A NAME="line5"></A>
<A NAME="line6"></A>val <A NAME="line6"></A><A HREF="#orb">orb</A>  : word * word -&gt; word
<A NAME="line7"></A>val <A NAME="line7"></A><A HREF="#andb">andb</A> : word * word -&gt; word
<A NAME="line8"></A>val <A NAME="line8"></A><A HREF="#xorb">xorb</A> : word * word -&gt; word
<A NAME="line9"></A>val <A NAME="line9"></A><A HREF="#notb">notb</A> : word -&gt; word
<A NAME="line10"></A>
<A NAME="line11"></A>val <A NAME="line11"></A><A HREF="#&lt;&lt;">&lt;&lt;</A>  : word * Word.word -&gt; word
<A NAME="line12"></A>val <A NAME="line12"></A><A HREF="#&gt;&gt;">&gt;&gt;</A>  : word * Word.word -&gt; word
<A NAME="line13"></A>val <A NAME="line13"></A><A HREF="#~&gt;&gt;">~&gt;&gt;</A> : word * Word.word -&gt; word
<A NAME="line14"></A>
<A NAME="line15"></A>val <A NAME="line15"></A><A HREF="#+">+</A>   : word * word -&gt; word
<A NAME="line16"></A>val <A NAME="line16"></A>-   : word * word -&gt; word
<A NAME="line17"></A>val <A NAME="line17"></A>*   : word * word -&gt; word
<A NAME="line18"></A>val <A NAME="line18"></A>div : word * word -&gt; word
<A NAME="line19"></A>val <A NAME="line19"></A>mod : word * word -&gt; word
<A NAME="line20"></A>
<A NAME="line21"></A>val <A NAME="line21"></A>&gt;   : word * word -&gt; bool
<A NAME="line22"></A>val <A NAME="line22"></A>&lt;   : word * word -&gt; bool
<A NAME="line23"></A>val <A NAME="line23"></A>&gt;=  : word * word -&gt; bool
<A NAME="line24"></A>val <A NAME="line24"></A>&lt;=  : word * word -&gt; bool
<A NAME="line25"></A>val <A NAME="line25"></A><A HREF="#compare">compare</A> : word * word -&gt; order
<A NAME="line26"></A>
<A NAME="line27"></A>val <A NAME="line27"></A><A HREF="#min">min</A> : word * word -&gt; word
<A NAME="line28"></A>val <A NAME="line28"></A><A HREF="#max">max</A> : word * word -&gt; word
<A NAME="line29"></A>
<A NAME="line30"></A>val <A NAME="line30"></A><A HREF="#toString">toString</A>   : word -&gt; string
<A NAME="line31"></A>val <A NAME="line31"></A><A HREF="#fromString">fromString</A> : string -&gt; word option
<A NAME="line32"></A>val <A NAME="line32"></A><A HREF="#scan">scan</A> : StringCvt.radix 
<A NAME="line33"></A>           -&gt; (char, 'a) StringCvt.reader -&gt; (word, 'a) StringCvt.reader
<A NAME="line34"></A>val <A NAME="line34"></A><A HREF="#fmt">fmt</A>  : StringCvt.radix -&gt; word -&gt; string
<A NAME="line35"></A>
<A NAME="line36"></A>val <A NAME="line36"></A><A HREF="#toInt">toInt</A>   : word -&gt; int
<A NAME="line37"></A>val <A NAME="line37"></A><A HREF="#toIntX">toIntX</A>  : word -&gt; int		(* with sign extension *)
<A NAME="line38"></A>val <A NAME="line38"></A><A HREF="#fromInt">fromInt</A> : int -&gt; word
<A NAME="line39"></A>
<A NAME="line40"></A>val <A NAME="line40"></A><A HREF="#toLargeInt">toLargeInt</A>   : word -&gt; int
<A NAME="line41"></A>val <A NAME="line41"></A><A HREF="#toLargeIntX">toLargeIntX</A>  : word -&gt; int		(* with sign extension *)
<A NAME="line42"></A>val <A NAME="line42"></A><A HREF="#fromLargeInt">fromLargeInt</A> : int -&gt; word
<A NAME="line43"></A>
<A NAME="line44"></A>val <A NAME="line44"></A><A HREF="#toLargeWord">toLargeWord</A>   : word -&gt; Word.word
<A NAME="line45"></A>val <A NAME="line45"></A><A HREF="#toLargeWordX">toLargeWordX</A>  : word -&gt; Word.word	(* with sign extension *)
<A NAME="line46"></A>val <A NAME="line46"></A><A HREF="#fromLargeWord">fromLargeWord</A> : Word.word -&gt; word
<A NAME="line47"></A>
<A NAME="line48"></A>(* [word] is the type of 8-bit words, or 8-bit unsigned integers in
<A NAME="line49"></A>   the range 0..255.
<A NAME="line50"></A>
   [<A NAME="wordSize"><B>wordSize</B></A>] is 8.

   [<A NAME="orb"><B>orb</B></A>(w1, w2)] returns the bitwise `or' of w1 and w2.

   [<A NAME="andb"><B>andb</B></A>(w1, w2)] returns the bitwise `and' of w1 and w2.

   [<A NAME="xorb"><B>xorb</B></A>(w1, w2)] returns the bitwise `exclusive or' or w1 and w2.

   [<A NAME="notb"><B>notb</B></A> w] returns the bitwise negation of w.

   [<A NAME="&lt;&lt;"><B>&lt;&lt;</B></A>(w, k)] returns the word resulting from shifting w left by k
   bits.  The bits shifted in are zero, so this is a logical shift.
   Consequently, the result is 0-bits when k &gt;= wordSize.

   [<A NAME="&gt;&gt;"><B>&gt;&gt;</B></A>(w, k)] returns the word resulting from shifting w right by k
   bits.  The bits shifted in are zero, so this is a logical shift.
   Consequently, the result is 0-bits when k &gt;= wordSize.

   [<A NAME="~&gt;&gt;"><B>~&gt;&gt;</B></A>(w, k)] returns the word resulting from shifting w right by k
   bits.  The bits shifted in are replications of the left-most bit:
   the `sign bit', so this is an arithmetical shift.  Consequently,
   for k &gt;= wordSize and wordToInt w &gt;= 0 the result is all 0-bits, and 
   for k &gt;= wordSize and wordToInt w &lt;  0 the result is all 1-bits.

   To make &lt;&lt;, &gt;&gt;, and ~&gt;&gt; infix, use the declaration:
                          infix 5 &lt;&lt; &gt;&gt; ~&gt;&gt;

   [<A NAME="+"><B>+</B></A>, -, *, div, mod] represent unsigned integer addition,
   subtraction, multiplication, division, and remainder, modulus 256.
   The operations (i div j) and (i mod j) raise Div when j = 0.
   Otherwise no exceptions are raised.

   [<A NAME="w1"><B>w1</B></A> &gt; w2] returns true if the unsigned integer represented by w1
   is larger than that of w2, and similarly for &lt;, &gt;=, &lt;=.  

   [<A NAME="compare"><B>compare</B></A>(w1, w2)] returns LESS, EQUAL, or GREATER, according 
   as w1 is less than, equal to, or greater than w2 (as unsigned integers).

   [<A NAME="min"><B>min</B></A>(w1, w2)] returns the smaller of w1 and w2 (as unsigned integers).

   [<A NAME="max"><B>max</B></A>(w1, w2)] returns the larger of w1 and w2 (as unsigned integers).

   [<A NAME="fmt"><B>fmt</B></A> radix w] returns a string representing w, in the radix (base)
   specified by radix.

     radix    description                     output format  
     ------------------------------------------------------  
      BIN     unsigned binary      (base  2)  [01]+         
      OCT     unsigned octal       (base  8)  [0-7]+          
      DEC     unsigned decimal     (base 10)  [0-9]+          
      HEX     unsigned hexadecimal (base 16)  [0-9A-F]+       

   [<A NAME="toString"><B>toString</B></A> w] returns a string representing w in unsigned
   hexadecimal format.  Equivalent to (fmt HEX w).
   
   [<A NAME="fromString"><B>fromString</B></A> s] returns SOME(w) if a hexadecimal unsigned numeral
   can be scanned from a prefix of string s, ignoring any initial
   whitespace; returns NONE otherwise.  Raises Overflow if the scanned
   number cannot be represented as a word.  An unsigned hexadecimal
   numeral must have form, after possible initial whitespace:
       [0-9a-fA-F]+

   [<A NAME="scan"><B>scan</B></A> radix {getc} charsrc] attempts to scan an unsigned numeral
   from the character source charsrc, using the accessor getc, and
   ignoring any initial whitespace.  The radix argument specifies the
   base of the numeral (BIN, OCT, DEC, HEX).  If successful, it
   returns SOME(w, rest) where w is the value of the numeral scanned,
   and rest is the unused part of the character source.  Raises
   Overflow if the scanned number cannot be represented as a word.  A
   numeral must have form, after possible initial whitespace:

     radix    input format 
     -------------------------------------
      BIN     (0w)?[0-1]+
      OCT     (0w)?[0-7]+
      DEC     (0w)?[0-9]+
      HEX     (0wx|0wX|0x|0X)?[0-9a-fA-F]+

   [<A NAME="toInt"><B>toInt</B></A> w] returns the integer in the range 0..255 represented by w.

   [<A NAME="toIntX"><B>toIntX</B></A> w] returns the signed integer (in the range ~128..127) 
   represented by bit-pattern w.
   
   [<A NAME="fromInt"><B>fromInt</B></A> i] returns the word holding the 8 least significant bits of i.

   [<A NAME="toLargeInt"><B>toLargeInt</B></A> w] returns the integer in the range 0..255 represented by w.

   [<A NAME="toLargeIntX"><B>toLargeIntX</B></A> w] returns the signed integer (in the range ~128..127) 
   represented by bit-pattern w.
   
   [<A NAME="fromLargeInt"><B>fromLargeInt</B></A> i] returns the word holding the 8 least significant bits of i.

   [<A NAME="toLargeWord"><B>toLargeWord</B></A> w] returns the Word.word value corresponding to w.

   [<A NAME="toLargeWordX"><B>toLargeWordX</B></A> w] returns the Word.word value corresponding to w,
   with sign extension.  That is, the 8 least significant bits of the
   result are those of w, and the remaining bits are all equal to the
   most significant bit of w: its `sign bit'.

   [<A NAME="fromLargeWord"><B>fromLargeWord</B></A> w] returns w modulo 256.
*)

</PRE><HR><TABLE WIDTH=100%><TR ALIGN = CENTER>
<TH><A HREF="idIndex.html">Identifier index</A>
<TH><A HREF="index.html">Structure index</A>
</TABLE><HR>
<BR><EM>Moscow ML 1.44</EM></BODY></HTML>
