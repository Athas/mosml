<HTML><HEAD><TITLE>Structure ListPair</TITLE></HEAD>
<BODY BGCOLOR="#fbf2e7">
<H1>Structure ListPair</H1>
<HR><TABLE WIDTH=100%><TR ALIGN = CENTER>
<TH><A HREF="idIndex.html">Identifier index</A>
<TH><A HREF="index.html">Structure index</A>
</TABLE><HR>
<PRE>
<A NAME="line1"></A>(* ListPair -- SML Basis Library *)
<A NAME="line2"></A>
<A NAME="line3"></A>val <A NAME="line3"></A><A HREF="#zip">zip</A>    : 'a list * 'b list -> ('a * 'b) list
<A NAME="line4"></A>val <A NAME="line4"></A><A HREF="#unzip">unzip</A>  : ('a * 'b) list -> 'a list * 'b list
<A NAME="line5"></A>val <A NAME="line5"></A><A HREF="#map">map</A>    : ('a * 'b -> 'c)   -> 'a list * 'b list -> 'c list
<A NAME="line6"></A>val <A NAME="line6"></A><A HREF="#app">app</A>    : ('a * 'b -> unit) -> 'a list * 'b list -> unit
<A NAME="line7"></A>val <A NAME="line7"></A><A HREF="#all">all</A>    : ('a * 'b -> bool) -> 'a list * 'b list -> bool
<A NAME="line8"></A>val <A NAME="line8"></A><A HREF="#exists">exists</A> : ('a * 'b -> bool) -> 'a list * 'b list -> bool
<A NAME="line9"></A>val <A NAME="line9"></A><A HREF="#foldr">foldr</A>  : ('a * 'b * 'c -> 'c) -> 'c -> 'a list * 'b list -> 'c
<A NAME="line10"></A>val <A NAME="line10"></A><A HREF="#foldl">foldl</A>  : ('a * 'b * 'c -> 'c) -> 'c -> 'a list * 'b list -> 'c
<A NAME="line11"></A>
<A NAME="line12"></A>
<A NAME="line13"></A>(* These functions process pairs of lists.  No exception is raised
<A NAME="line14"></A>   when the lists are found to be of unequal length.  Instead the
<A NAME="line15"></A>   excess elements from the longer list are disregarded.
<A NAME="line16"></A>
   [<A NAME="zip"><B>zip</B></A> (xs, ys)] returns the list of pairs of corresponding elements
   from xs and ys.  

   [<A NAME="unzip"><B>unzip</B></A> xys] returns a pair (xs, ys), where xs is the list of first
   components of xys, and ys is the list of second components from
   xys.  Hence zip (unzip xys) has the same result and effect as xys.

   [<A NAME="map"><B>map</B></A> f (xs, ys)] applies function f to the pairs of corresponding
   elements of xs and ys and returns the list of results.  Hence 
   map f (xs, ys) has the same result and effect as List.map f (zip (xs, ys)).

   [<A NAME="app"><B>app</B></A> f (xs, ys)] applies function f to the pairs of corresponding
   elements of xs and ys and returns ().  Hence app f (xs, ys) has the
   same result and effect as List.app f (zip (xs, ys)).

   [<A NAME="all"><B>all</B></A> p (xs, ys)] applies predicate p to the pairs of corresponding
   elements of xs and ys until p evaluates to false or one or both
   lists is exhausted; returns true if p is true of all such pairs;
   otherwise false.  Hence all p (xs, ys) has the same result and
   effect as Lisp.all p (zip (xs, ys)).

   [<A NAME="exists"><B>exists</B></A> p (xs, ys)] applies predicate p to the pairs of corresponding
   elements of xs and ys until p evaluates to true or one or both
   lists is exhausted; returns true if p is true of any such pair;
   otherwise false.  Hence exists p (xs, ys) has the same result and
   effect as Lisp.exists p (zip (xs, ys)).

   [<A NAME="foldr"><B>foldr</B></A> f e (xs, ys)] evaluates f(x1, y1, f(x2, y2, f(..., f(xn, yn, e))))
   where xs = [x1, x2, ..., x(n-1), xn, ...],
         ys = [y1, y2, ..., y(n-1), yn, ...], 
   and    n = min(length xs, length ys).
   Equivalent to List.foldr (fn ((x, y), r) => f(x, y, r)) e (zip(xs, ys)).

   [<A NAME="foldl"><B>foldl</B></A> f e (xs, ys)] evaluates f(xn, yn, f( ..., f(x2, y2, f(x1, y1, e))))
   where xs = [x1, x2, ..., x(n-1), xn, ...], 
         ys = [y1, y2, ..., y(n-1), yn, ...], 
   and    n = min(length xs, length ys).
   Equivalent to List.foldl (fn ((x, y), r) => f(x, y, r)) e (zip(xs, ys)).
*)

</PRE><HR><TABLE WIDTH=100%><TR ALIGN = CENTER>
<TH><A HREF="idIndex.html">Identifier index</A>
<TH><A HREF="index.html">Structure index</A>
</TABLE><HR>
<BR><EM>Moscow ML 1.44</EM></BODY></HTML>
