<HTML><HEAD><TITLE>Structure Lexing</TITLE></HEAD>
<BODY BGCOLOR="#fbf2e7">
<H1>Structure Lexing</H1>
<HR><TABLE WIDTH=100%><TR ALIGN = CENTER>
<TH><A HREF="idIndex.html">Identifier index</A>
<TH><A HREF="index.html">Structure index</A>
</TABLE><HR>
<PRE>
<A NAME="line1"></A>(* Internal run-time library for lexers generated by mosmllex.
<A NAME="line2"></A> * Closely based on the library for camllex.  Copyright 1993 INRIA, France. 
<A NAME="line3"></A> *)
<A NAME="line4"></A>
<A NAME="line5"></A>local open Obj in
<A NAME="line6"></A>
<A NAME="line7"></A>(*** Lexer buffers *)
<A NAME="line8"></A>
<A NAME="line9"></A>type lexbuf;
<A NAME="line10"></A>        (* The type of lexer buffers. A lexer buffer is the argument passed
<A NAME="line11"></A>           to the scanning functions defined by the generated scanners.
<A NAME="line12"></A>           The lexer buffer holds the current state of the scanner, plus
<A NAME="line13"></A>           a function to refill the buffer from the input. *)
<A NAME="line14"></A>
<A NAME="line15"></A>prim_val getLexBuffer     : lexbuf -> string           = 1 "field1";
<A NAME="line16"></A>prim_val getLexAbsPos     : lexbuf -> int              = 1 "field2";
<A NAME="line17"></A>prim_val getLexStartPos   : lexbuf -> int              = 1 "field3";
<A NAME="line18"></A>prim_val getLexCurrPos    : lexbuf -> int              = 1 "field4";
<A NAME="line19"></A>prim_val getLexLastPos    : lexbuf -> int              = 1 "field5";
<A NAME="line20"></A>prim_val getLexLastAction : lexbuf -> (lexbuf -> obj)  = 1 "field6";
<A NAME="line21"></A>
<A NAME="line22"></A>prim_val setLexAbsPos     : lexbuf -> int -> unit             = 2 "setfield2";
<A NAME="line23"></A>prim_val setLexStartPos   : lexbuf -> int -> unit             = 2 "setfield3";
<A NAME="line24"></A>prim_val setLexCurrPos    : lexbuf -> int -> unit             = 2 "setfield4";
<A NAME="line25"></A>prim_val setLexLastPos    : lexbuf -> int -> unit             = 2 "setfield5";
<A NAME="line26"></A>prim_val setLexLastAction : lexbuf -> (lexbuf -> obj) -> unit = 2 "setfield6";
<A NAME="line27"></A>
<A NAME="line28"></A>val <A NAME="line28"></A>createLexerString : string -> lexbuf;
<A NAME="line29"></A>        (* Create a lexer buffer which reads from
<A NAME="line30"></A>           the given string. Reading starts from the first character in
<A NAME="line31"></A>           the string. An end-of-input condition is generated when the
<A NAME="line32"></A>           end of the string is reached. *)
<A NAME="line33"></A>
<A NAME="line34"></A>val <A NAME="line34"></A>createLexer : (CharArray.array -> int -> int) -> lexbuf;
<A NAME="line35"></A>        (* Create a lexer buffer with the given function as its reading method.
<A NAME="line36"></A>           When the scanner needs more characters, it will call the given
<A NAME="line37"></A>           function, giving it a character string [s] and a character
<A NAME="line38"></A>           count [n]. The function should put [n] characters or less in [s],
<A NAME="line39"></A>           starting at character number 0, and return the number of characters
<A NAME="line40"></A>           provided. A return value of 0 means end of input. *)
<A NAME="line41"></A>
<A NAME="line42"></A>(*** Functions for lexer semantic actions *)
<A NAME="line43"></A>
<A NAME="line44"></A>        (* The following functions can be called from the semantic actions
<A NAME="line45"></A>           of lexer definitions (the ML code enclosed in braces that
<A NAME="line46"></A>           computes the value returned by lexing functions). They give
<A NAME="line47"></A>           access to the character string matched by the regular expression
<A NAME="line48"></A>           associated with the semantic action. These functions must be
<A NAME="line49"></A>           applied to the argument [lexbuf], which, in the code generated by
<A NAME="line50"></A>           camllex, is bound to the lexer buffer passed to the parsing
<A NAME="line51"></A>           function. *)
<A NAME="line52"></A>
<A NAME="line53"></A>val <A NAME="line53"></A>getLexeme : lexbuf -> string;
<A NAME="line54"></A>        (* [getLexeme lexbuf] returns the string matched by
<A NAME="line55"></A>           the regular expression. *)
<A NAME="line56"></A>
<A NAME="line57"></A>val <A NAME="line57"></A>getLexemeChar : lexbuf -> int -> char;
<A NAME="line58"></A>        (* [getLexemeChar lexbuf i] returns character number [i] in
<A NAME="line59"></A>           the matched string. *)
<A NAME="line60"></A>
<A NAME="line61"></A>val <A NAME="line61"></A>getLexemeStart : lexbuf -> int;
<A NAME="line62"></A>        (* [getLexemeStart lexbuf] returns the position in the input stream
<A NAME="line63"></A>           of the first character of the matched string. The first character
<A NAME="line64"></A>           of the stream has position 0. *)
<A NAME="line65"></A>
<A NAME="line66"></A>val <A NAME="line66"></A>getLexemeEnd : lexbuf -> int;
<A NAME="line67"></A>        (* [getLexemeEnd lexbuf] returns the position in the input stream
<A NAME="line68"></A>           of the character following the last character of the matched
<A NAME="line69"></A>           string. The first character of the stream has position 0. *)
<A NAME="line70"></A>(*--*)
<A NAME="line71"></A>
<A NAME="line72"></A>(* The following definitions are used by the generated scanners only.
<A NAME="line73"></A>   They are not intended to be used by user programs. *)
<A NAME="line74"></A>
<A NAME="line75"></A>val <A NAME="line75"></A>dummyAction : lexbuf -> obj;
<A NAME="line76"></A>prim_val getNextChar : lexbuf -> char = 1 "get_next_char";
<A NAME="line77"></A>val <A NAME="line77"></A>backtrack : lexbuf -> 'a;
<A NAME="line78"></A>
<A NAME="line79"></A>end;
<A NAME="line80"></A>
</PRE><HR><TABLE WIDTH=100%><TR ALIGN = CENTER>
<TH><A HREF="idIndex.html">Identifier index</A>
<TH><A HREF="index.html">Structure index</A>
</TABLE><HR>
<BR><EM>Moscow ML 1.44</EM></BODY></HTML>
