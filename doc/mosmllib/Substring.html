<HTML><HEAD><TITLE>Structure Substring</TITLE></HEAD>
<BODY BGCOLOR="#fbf2e7">
<H1>Structure Substring</H1>
<HR><TABLE WIDTH=100%><TR ALIGN = CENTER>
<TH><A HREF="idIndex.html">Identifier index</A>
<TH><A HREF="index.html">Structure index</A>
</TABLE><HR>
<PRE>
<A NAME="line1"></A>(* Substring -- SML Basis Library *)
<A NAME="line2"></A>
<A NAME="line3"></A>type substring
<A NAME="line4"></A>
<A NAME="line5"></A>val <A NAME="line5"></A><A HREF="#substring">substring</A> : string * int * int -> substring
<A NAME="line6"></A>val <A NAME="line6"></A><A HREF="#extract">extract</A>   : string * int * int option -> substring
<A NAME="line7"></A>val <A NAME="line7"></A><A HREF="#all">all</A>       : string -> substring
<A NAME="line8"></A>val <A NAME="line8"></A><A HREF="#string">string</A>    : substring -> string
<A NAME="line9"></A>val <A NAME="line9"></A><A HREF="#base">base</A>      : substring -> (string * int * int)
<A NAME="line10"></A>
<A NAME="line11"></A>val <A NAME="line11"></A><A HREF="#isEmpty">isEmpty</A>   : substring -> bool
<A NAME="line12"></A>val <A NAME="line12"></A><A HREF="#getc">getc</A>      : substring -> (char * substring) option
<A NAME="line13"></A>val <A NAME="line13"></A><A HREF="#first">first</A>     : substring -> char option
<A NAME="line14"></A>val <A NAME="line14"></A><A HREF="#triml">triml</A>     : int -> substring -> substring
<A NAME="line15"></A>val <A NAME="line15"></A><A HREF="#trimr">trimr</A>     : int -> substring -> substring
<A NAME="line16"></A>val <A NAME="line16"></A><A HREF="#sub">sub</A>       : substring * int -> char
<A NAME="line17"></A>val <A NAME="line17"></A><A HREF="#size">size</A>      : substring -> int
<A NAME="line18"></A>val <A NAME="line18"></A><A HREF="#slice">slice</A>     : substring * int * int option -> substring
<A NAME="line19"></A>val <A NAME="line19"></A><A HREF="#concat">concat</A>    : substring list -> string
<A NAME="line20"></A>val <A NAME="line20"></A><A HREF="#explode">explode</A>   : substring -> char list
<A NAME="line21"></A>val <A NAME="line21"></A><A HREF="#isPrefix">isPrefix</A>  : string -> substring -> bool
<A NAME="line22"></A>val <A NAME="line22"></A><A HREF="#compare">compare</A>   : substring * substring -> order
<A NAME="line23"></A>val <A NAME="line23"></A><A HREF="#collate">collate</A>   : (char * char -> order) -> substring * substring -> order
<A NAME="line24"></A>
<A NAME="line25"></A>val <A NAME="line25"></A><A HREF="#dropl">dropl</A>     : (char -> bool) -> substring -> substring
<A NAME="line26"></A>val <A NAME="line26"></A><A HREF="#dropr">dropr</A>     : (char -> bool) -> substring -> substring
<A NAME="line27"></A>val <A NAME="line27"></A><A HREF="#takel">takel</A>     : (char -> bool) -> substring -> substring
<A NAME="line28"></A>val <A NAME="line28"></A><A HREF="#taker">taker</A>     : (char -> bool) -> substring -> substring
<A NAME="line29"></A>val <A NAME="line29"></A><A HREF="#splitl">splitl</A>    : (char -> bool) -> substring -> substring * substring
<A NAME="line30"></A>val <A NAME="line30"></A><A HREF="#splitr">splitr</A>    : (char -> bool) -> substring -> substring * substring
<A NAME="line31"></A>val <A NAME="line31"></A><A HREF="#splitAt">splitAt</A>   : substring * int -> substring * substring
<A NAME="line32"></A>
<A NAME="line33"></A>val <A NAME="line33"></A><A HREF="#position">position</A>  : string -> substring -> substring * substring
<A NAME="line34"></A>
<A NAME="line35"></A>exception Span
<A NAME="line36"></A>val <A NAME="line36"></A><A HREF="#span">span</A>      : substring * substring -> substring
<A NAME="line37"></A>
<A NAME="line38"></A>val <A NAME="line38"></A><A HREF="#translate">translate</A> : (char -> string) -> substring -> string
<A NAME="line39"></A>
<A NAME="line40"></A>val <A NAME="line40"></A><A HREF="#tokens">tokens</A>    : (char -> bool) -> substring -> substring list
<A NAME="line41"></A>val <A NAME="line41"></A><A HREF="#fields">fields</A>    : (char -> bool) -> substring -> substring list
<A NAME="line42"></A>
<A NAME="line43"></A>val <A NAME="line43"></A><A HREF="#foldl">foldl</A>     : (char * 'a -> 'a) -> 'a -> substring -> 'a
<A NAME="line44"></A>val <A NAME="line44"></A><A HREF="#foldr">foldr</A>     : (char * 'a -> 'a) -> 'a -> substring -> 'a
<A NAME="line45"></A>val <A NAME="line45"></A><A HREF="#app">app</A>       : (char -> unit) -> substring -> unit
<A NAME="line46"></A>
<A NAME="line47"></A>(* A substring is an abstract representation of a piece of a string.
<A NAME="line48"></A>   The type [substring] is the abstract type of substrings of a basestring.
<A NAME="line49"></A>   A substring (s,i,n) is valid if 0 <= i <= i+n <= size s, 
<A NAME="line50"></A>                  or equivalently, 0 <= i and 0 <= n and i+n <= size s.  
<A NAME="line51"></A>   A valid substring (s, i, n) represents the string s[i...i+n-1].  
<A NAME="line52"></A>   Invariant in the implementation: Any value of type substring is valid.
<A NAME="line53"></A>
   [<A NAME="substring"><B>substring</B></A>(s, i, n)] creates the substring (s, i, n), consisting of
   the substring of s with length n starting at i.  Raises Subscript
   if i<0 or n<0 or i+n > size s.  Equivalent to extract(s, i, SOME n).

   [<A NAME="extract"><B>extract</B></A>(s, i, NONE)] creates the substring (s, i, size s-i)
   consisting of the tail of s starting at i.  
   Raises Subscript if i<0 or i > size s.

   [<A NAME="extract"><B>extract</B></A>(s, i, SOME n)] creates the substring (s, i, n),
   consisting of the substring of s with length n starting at i.
   Raises Subscript if i<0 or n<0 or i+n > size s.

   [<A NAME="all"><B>all</B></A> s] is the substring (s, 0, size s).

   [<A NAME="string"><B>string</B></A> sus] is the string s[i..i+n-1] represented by sus = (s, i, n).

   [<A NAME="base"><B>base</B></A> sus] is the concrete triple (s, i, n), where sus = (s, i, n).

   [<A NAME="isEmpty"><B>isEmpty</B></A> (s, i, n)] true if the substring is empty (that is, n = 0).

   [<A NAME="getc"><B>getc</B></A> sus] returns SOME(c, rst) where c is the first character and
   rst the remainder of sus, if sus is non-empty; otherwise returns
   NONE.  Note that 
        #1 o valOf o scanFn Substring.getc
   is equivalent to, but more efficient than, 
        valOf o StringCvt.scanString scanFn o Substring.string

   [<A NAME="first"><B>first</B></A> sus] returns SOME c where c is the first character in sus,
   if sus is non-empty; otherwise returns NONE.

   [<A NAME="triml"><B>triml</B></A> k sus] returns sus less its leftmost k characters; or the
   empty string at the end of sus if it has less than k characters.
   Raises Subscript if k < 0, even in the partial application triml(k). 

   [<A NAME="trimr"><B>trimr</B></A> k sus] returns sus less its rightmost k characters; or the
   empty string at the beginning of sus if it has less than k characters.  
   Raises Subscript if k < 0, even in the partial application triml(k).

   [<A NAME="sub"><B>sub</B></A> (sus, k)] returns the k'th character of the substring; that is,
   s(i+k) where sus = (s, i, n).  Raises Subscript if k<0 or k>=n.

   [<A NAME="size"><B>size</B></A> (s, i, n)] returns the size of the substring, that is, n.

   [<A NAME="slice"><B>slice</B></A> (sus, i', NONE)] returns the substring (s, i+i', n-i'), where
   sus = (s, i, n).  Raises Subscript if i' < 0 or i' > n.

   [<A NAME="slice"><B>slice</B></A> (sus, i', SOME n')] returns the substring (s, i+i', n'), where
   sus = (s, i, n).  Raises Subscript if i' < 0 or n' < 0 or i'+n' >= n.

   [<A NAME="concat"><B>concat</B></A> suss] returns a string consisting of the concatenation of
   the substrings.  Equivalent to String.concat (List.map string suss).

   [<A NAME="explode"><B>explode</B></A> sus] returns the list of characters of sus, that is,
        [s(i), s(i+1), ..., s(i+n-1)]
   where sus = (s, i, n).  Equivalent to String.explode(string ss).

   [<A NAME="isPrefix"><B>isPrefix</B></A> s1 s2] is true if s1 is a prefix of s2. That is, if there 
   exists a string t such that string s1 ^ t = string s2.

   [<A NAME="compare"><B>compare</B></A> (sus1, sus2)] performs lexicographic comparison, using the
   standard ordering Char.compare on the characters.  Returns LESS,
   EQUAL, or GREATER, according as sus1 is less than, equal to, or
   greater than sus2.  Equivalent to, but more efficient than,
       String.compare(string sus1, string sus2).

   [<A NAME="collate"><B>collate</B></A> cmp (sus1, sus2)] performs lexicographic comparison, using the 
   given ordering cmp on characters.  Equivalent to, but more efficient 
   than, String.collate cmp (string sus1, string sus2).

   [<A NAME="dropl"><B>dropl</B></A> p sus] drops the longest prefix (left substring) of sus all
   of whose characters satisfy predicate p.  If all characters do, it
   returns the empty substring (s, i+n, 0) where sus = (s, i, n).

   [<A NAME="dropr"><B>dropr</B></A> p sus] drops the longest suffix (right substring) of sus all
   of whose characters satisfy predicate p.  If all characters do, it
   returns the empty substring (s, i, 0) where sus = (s, i, n).

   [<A NAME="takel"><B>takel</B></A> p sus] returns the longest prefix (left substring) of sus
   all of whose characters satisfy predicate p.  That is, if the
   left-most character does not satisfy p, returns the empty (s, i, 0)
   where sus = (s, i, n).

   [<A NAME="taker"><B>taker</B></A> p sus] returns the longest suffix (right substring) of sus
   all of whose characters satisfy predicate p.  That is, if the
   right-most character satisfies p, returns the empty (s, i+n, 0)
   where sus = (s, i, n).

   Let p be a predicate and xxxxfyyyyfzzzz a string where all
   characters in xxxx and zzzz satisfy p, and f a is character
   not satisfying p.  Then

                sus = xxxxfyyyyfzzzz         sus = xxxxzzzz
        ------------------------------------------------------
        dropl p sus =     fyyyyfzzzz               
        dropr p sus = xxxxfyyyyf       
        takel p sus = xxxx                         xxxxzzzz
        taker p sus =           zzzz               xxxxzzzz

   It also holds that 
        concat[takel p sus, dropl p sus] = string sus
        concat[dropr p sus, taker p sus] = string sus 

   [<A NAME="splitl"><B>splitl</B></A> p sus] splits sus into a pair (sus1, sus2) of substrings
   where sus1 is the longest prefix (left substring) all of whose
   characters satisfy p, and sus2 is the rest.  That is, sus2 begins
   with the leftmost character not satisfying p.  Disregarding
   sideeffects, we have: 
        splitl p sus = (takel p sus, dropl p sus).

   [<A NAME="splitr"><B>splitr</B></A> p sus] splits sus into a pair (sus1, sus2) of substrings
   where sus2 is the longest suffix (right substring) all of whose
   characters satisfy p, and sus1 is the rest.  That is, sus1 ends
   with the rightmost character not satisfying p.  Disregarding
   sideeffects, we have:
        splitr p sus = (dropr p sus, taker p sus)

   [<A NAME="splitAt"><B>splitAt</B></A> (sus, k)] returns the pair (sus1, sus2) of substrings,
   where sus1 contains the first k characters of sus, and sus2
   contains the rest.  Raises Subscript if k < 0 or k > size sus.

   [<A NAME="position"><B>position</B></A> s (s',i,n)] splits the substring into a pair (pref, suff)
   of substrings, where suff is the longest suffix of (s', i, n) which
   has s as a prefix.  More precisely, let m = size s.  If there is a
   least index k in i..i+n-m for which s = s'[k..k+m-1], 
   then the result is       pref = (s', i, k-i) and suff = (s', k, n-(k-i)); 
   otherwise the result is  pref = (s', i, n)   and suff = (s', i+n, 0).

   [<A NAME="span"><B>span</B></A> (sus1, sus2)] returns a substring spanning from the start of
   sus1 to the end of sus2, provided this is well-defined: sus1 and
   sus2 must have the same underlying string, and the start of sus1
   must not be to the right of the end of sus2; otherwise raises Span.

   More precisely, if base(sus1) = (s,i,n) and base(sus2) = (s',i',n') 
   and s = s' and i <= i'+n', then base(join(sus1, sus2)) = (s, i, i'+n'-i).
   This may be used to compute `span', `union', and `intersection'.

   [<A NAME="translate"><B>translate</B></A> f sus] applies f to every character of sus, from left to
   right, and returns the concatenation of the results.  Raises Size
   if the sum of their sizes is greater than String.maxSize.
   Equivalent to String.concat(List.map f (explode sus)).

   [<A NAME="tokens"><B>tokens</B></A> p sus] returns the list of tokens in sus, from left to right, 
   where a token is a non-empty maximal substring of sus not containing 
   any delimiter, and a delimiter is a character satisfying p.

   [<A NAME="fields"><B>fields</B></A> p sus] returns the list of fields in sus, from left to right, 
   where a field is a (possibly empty) maximal substring of sus not 
   containing any delimiter, and a delimiter is a character satisfying p.

   Two tokens may be separated by more than one delimiter, whereas two
   fields are separated by exactly one delimiter.  If the only delimiter 
   is the character #"|", then
        "abc||def" contains two tokens:   "abc" and "def"
        "abc||def" contains three fields: "abc" and "" and "def"

   [<A NAME="foldl"><B>foldl</B></A> f e sus] folds f over sus from left to right.  That is, 
   evaluates f(s[i+n-1], f( ... f(s[i+1], f(s[i] % e)) ...)) 
   tail-recursively, where sus = (s, i, n).  
   Equivalent to List.foldl f e (explode sus).

   [<A NAME="foldr"><B>foldr</B></A> f e sus] folds f over sus from right to left.  That is, 
   evaluates f(s[i], f(s[i+1], f(... f(s[i+n-1] % e) ...)))
   tail-recursively, where sus = (s, i, n).
   Equivalent to List.foldr f e (explode sus).

   [<A NAME="app"><B>app</B></A> f sus] applies f to all characters of sus, from left to right.
   Equivalent to List.app f (explode sus).

*)

</PRE><HR><TABLE WIDTH=100%><TR ALIGN = CENTER>
<TH><A HREF="idIndex.html">Identifier index</A>
<TH><A HREF="index.html">Structure index</A>
</TABLE><HR>
<BR><EM>Moscow ML 1.44</EM></BODY></HTML>
