<HTML><HEAD><TITLE>Structure Socket</TITLE></HEAD>
<BODY BGCOLOR="#fbf2e7">
<H1>Structure Socket</H1>
<HR><TABLE WIDTH=100%><TR ALIGN = CENTER>
<TH><A HREF="idIndex.html">Identifier index</A>
<TH><A HREF="index.html">Structure index</A>
</TABLE><HR>
<PRE>
<A NAME="line1"></A>(* Socket -- Moscow ML sockets interface       *)
<A NAME="line2"></A>(* This module requires Dynlib to be installed *)
<A NAME="line3"></A>
<A NAME="line4"></A>signature Socket =
<A NAME="line5"></A>sig
<A NAME="line6"></A>
<A NAME="line7"></A>type ('addressfam, 'socktype) sock
<A NAME="line8"></A>type 'addressfam sock_addr
<A NAME="line9"></A>
<A NAME="line10"></A>(* Socket types *)
<A NAME="line11"></A>type dgram                              (* A datagram socket             *)
<A NAME="line12"></A>type 'a stream                          (* A stream socket               *)
<A NAME="line13"></A>type passive                            (* A passive stream              *)
<A NAME="line14"></A>type active                             (* An active, connected, stream  *)
<A NAME="line15"></A>
<A NAME="line16"></A>(* Socket protocol families *)
<A NAME="line17"></A>type pf_file                            (* The Unix file protocol family *)
<A NAME="line18"></A>type pf_inet                            (* The Internet protocol family  *)
<A NAME="line19"></A>
<A NAME="line20"></A>(* Address constructors *)
<A NAME="line21"></A>val <A NAME="line21"></A><A HREF="#fileAddr">fileAddr</A> : string -> pf_file sock_addr
<A NAME="line22"></A>val <A NAME="line22"></A><A HREF="#inetAddr">inetAddr</A> : string -> int -> pf_inet sock_addr
<A NAME="line23"></A>
<A NAME="line24"></A>(* Socket constructors *)
<A NAME="line25"></A>val <A NAME="line25"></A><A HREF="#fileStream">fileStream</A> : unit -> (pf_file, 'a stream) sock
<A NAME="line26"></A>val <A NAME="line26"></A><A HREF="#fileDgram">fileDgram</A>  : unit -> (pf_file, dgram) sock
<A NAME="line27"></A>val <A NAME="line27"></A><A HREF="#inetStream">inetStream</A> : unit -> (pf_inet, 'a stream) sock
<A NAME="line28"></A>val <A NAME="line28"></A><A HREF="#inetDgram">inetDgram</A>  : unit -> (pf_inet, dgram) sock
<A NAME="line29"></A>
<A NAME="line30"></A>val <A NAME="line30"></A><A HREF="#accept">accept</A>   : ('a, passive stream) sock 
<A NAME="line31"></A>               -> ('a, active stream) sock * 'a sock_addr
<A NAME="line32"></A>val <A NAME="line32"></A><A HREF="#bind">bind</A>     : ('a, 'b) sock * 'a sock_addr -> unit
<A NAME="line33"></A>val <A NAME="line33"></A><A HREF="#connect">connect</A>  : ('a, 'b) sock * 'a sock_addr -> unit
<A NAME="line34"></A>val <A NAME="line34"></A><A HREF="#listen">listen</A>   : ('a, passive stream) sock * int -> unit
<A NAME="line35"></A>val <A NAME="line35"></A><A HREF="#close">close</A>    : ('a, 'b) sock -> unit
<A NAME="line36"></A>
<A NAME="line37"></A>(* Socket management *)
<A NAME="line38"></A>datatype shutdown_mode = 
<A NAME="line39"></A>    NO_RECVS                            (* No further receives   *)
<A NAME="line40"></A>  | NO_SENDS                            (* No further sends      *)
<A NAME="line41"></A>  | NO_RECVS_OR_SENDS                   (* No receives nor sends *)
<A NAME="line42"></A>
<A NAME="line43"></A>val <A NAME="line43"></A><A HREF="#shutdown">shutdown</A> : ('a, 'b stream) sock * shutdown_mode -> unit
<A NAME="line44"></A>
<A NAME="line45"></A>type sock_desc
<A NAME="line46"></A>
<A NAME="line47"></A>val <A NAME="line47"></A><A HREF="#sockDesc">sockDesc</A> : ('a, 'b) sock -> sock_desc
<A NAME="line48"></A>val <A NAME="line48"></A><A HREF="#sameDesc">sameDesc</A> : sock_desc * sock_desc -> bool
<A NAME="line49"></A>val <A NAME="line49"></A><A HREF="#compare">compare</A>  : sock_desc * sock_desc -> order
<A NAME="line50"></A>val <A NAME="line50"></A><A HREF="#select">select</A> : 
<A NAME="line51"></A>    { rds : sock_desc list, wrs : sock_desc list, exs : sock_desc list, 
<A NAME="line52"></A>      timeout : Time.time option } 
<A NAME="line53"></A>    -> { rds : sock_desc list, wrs : sock_desc list, exs : sock_desc list }
<A NAME="line54"></A>
<A NAME="line55"></A>val <A NAME="line55"></A><A HREF="#getinetaddr">getinetaddr</A> : pf_inet sock_addr -> string
<A NAME="line56"></A>
<A NAME="line57"></A>(* Sock I/O option types *)
<A NAME="line58"></A>type out_flags = { don't_route : bool, oob : bool }
<A NAME="line59"></A>type in_flags  = { peek : bool, oob : bool }
<A NAME="line60"></A>
<A NAME="line61"></A>type 'a buf = { buf : 'a, ofs : int, size : int option }
<A NAME="line62"></A>
<A NAME="line63"></A>
<A NAME="line64"></A>(* Socket output operations *)
<A NAME="line65"></A>val <A NAME="line65"></A><A HREF="#sendVec">sendVec</A>    : ('a, active stream) sock * Word8Vector.vector buf -> int
<A NAME="line66"></A>val <A NAME="line66"></A><A HREF="#sendArr">sendArr</A>    : ('a, active stream) sock * Word8Array.array buf -> int
<A NAME="line67"></A>val <A NAME="line67"></A><A HREF="#sendVec'">sendVec'</A>   : ('a, active stream) sock * Word8Vector.vector buf 
<A NAME="line68"></A>                 * out_flags -> int
<A NAME="line69"></A>val <A NAME="line69"></A><A HREF="#sendArr'">sendArr'</A>   : ('a, active stream) sock * Word8Array.array buf 
<A NAME="line70"></A>                 * out_flags -> int
<A NAME="line71"></A>val <A NAME="line71"></A><A HREF="#sendVecTo">sendVecTo</A>  : ('a, dgram) sock * 'a sock_addr * Word8Vector.vector buf
<A NAME="line72"></A>                 -> int
<A NAME="line73"></A>val <A NAME="line73"></A><A HREF="#sendArrTo">sendArrTo</A>  : ('a, dgram) sock * 'a sock_addr * Word8Array.array buf 
<A NAME="line74"></A>                 -> int
<A NAME="line75"></A>val <A NAME="line75"></A><A HREF="#sendVecTo'">sendVecTo'</A> : ('a, dgram) sock * 'a sock_addr * Word8Vector.vector buf
<A NAME="line76"></A>                 * out_flags -> int
<A NAME="line77"></A>val <A NAME="line77"></A><A HREF="#sendArrTo'">sendArrTo'</A> : ('a, dgram) sock * 'a sock_addr * Word8Array.array buf
<A NAME="line78"></A>                 * out_flags -> int
<A NAME="line79"></A>
<A NAME="line80"></A>(* Socket input operations *)
<A NAME="line81"></A>val <A NAME="line81"></A><A HREF="#recvVec">recvVec</A>      : ('a, active stream) sock * int -> Word8Vector.vector
<A NAME="line82"></A>val <A NAME="line82"></A><A HREF="#recvArr">recvArr</A>      : ('a, active stream) sock * Word8Array.array buf -> int
<A NAME="line83"></A>val <A NAME="line83"></A><A HREF="#recvVec'">recvVec'</A>     : ('a, active stream) sock * int * in_flags
<A NAME="line84"></A>                   -> Word8Vector.vector
<A NAME="line85"></A>val <A NAME="line85"></A><A HREF="#recvArr'">recvArr'</A>     : ('a, active stream) sock * Word8Array.array buf * in_flags
<A NAME="line86"></A>                   -> int
<A NAME="line87"></A>val <A NAME="line87"></A><A HREF="#recvVecFrom">recvVecFrom</A>  : ('a, dgram) sock * int 
<A NAME="line88"></A>                   -> Word8Vector.vector * 'a sock_addr
<A NAME="line89"></A>val <A NAME="line89"></A><A HREF="#recvArrFrom">recvArrFrom</A>  : ('a, dgram) sock * Word8Array.array buf 
<A NAME="line90"></A>                   -> int * 'a sock_addr
<A NAME="line91"></A>val <A NAME="line91"></A><A HREF="#recvVecFrom'">recvVecFrom'</A> : ('a, dgram) sock * int * in_flags
<A NAME="line92"></A>                   -> Word8Vector.vector * 'a sock_addr
<A NAME="line93"></A>val <A NAME="line93"></A><A HREF="#recvArrFrom'">recvArrFrom'</A> : ('a, dgram) sock * Word8Array.array buf * in_flags
<A NAME="line94"></A>                   -> int * 'a sock_addr
<A NAME="line95"></A>end
<A NAME="line96"></A>
<A NAME="line97"></A>(* 
<A NAME="line98"></A>   Structure Socket defines functions for creating and using sockets,
<A NAME="line99"></A>   a means for communication between SML processes on the same machine
<A NAME="line100"></A>   or via a network.
<A NAME="line101"></A>
<A NAME="line102"></A>   Type [('addressfam, 'socktype) sock] is the type of sockets with
<A NAME="line103"></A>   address family 'addressfam and having type 'socktype.  
<A NAME="line104"></A>
<A NAME="line105"></A>   The possible protocol families are 
<A NAME="line106"></A>        type pf_file    The Unix address family (file)
<A NAME="line107"></A>        type pf_inet    The Internet address family
<A NAME="line108"></A>
<A NAME="line109"></A>   The possible socket types are 
<A NAME="line110"></A>        type dgram      datagram sockets
<A NAME="line111"></A>        type 'a stream  stream sockets
<A NAME="line112"></A>        type passive    passive stream sockets
<A NAME="line113"></A>        type active     active, or connected, stream sockets
<A NAME="line114"></A>
   [<A NAME="fileAddr"><B>fileAddr</B></A> fname] returns a socket address for the Unix protocol
   family, created from the given file name fname.

   [<A NAME="inetAddr"><B>inetAddr</B></A> inetaddr portno] returns a socket address for the
   Internet protocol family, created from the given Internet number
   (e.g. "130.225.40.253") and port number (e.g. 8080).

   [<A NAME="fileStream"><B>fileStream</B></A> ()] returns a new stream socket for the Unix protocol
   family.

   [<A NAME="fileDgram"><B>fileDgram</B></A> ()] returns a new datagram socket for the Unix protocol
   family.

   [<A NAME="inetStream"><B>inetStream</B></A> ()] returns a new stream socket for the Internet
   protocol family.

   [<A NAME="inetDgram"><B>inetDgram</B></A> ()] returns a new datagram socket for the Internet
   protocol family.

   [<A NAME="accept"><B>accept</B></A> sock] extracts the first connection on the queue of pending
   connections to sock.  Returns (sock', addr) where sock' is a copy
   of the socket sock, bound to that connection, and addr is the
   address of the communications counterpart (the other end of the
   connection).  Blocks if no connections are pending.  The stream
   socket sock must have been assigned a name (with bind) and must be
   listening for connections (following a call to listen).

   [<A NAME="bind"><B>bind</B></A> sock addr] binds the socket sock to the address addr, that
   is, assigns the name addr to the socket.  Binding a name in the
   Unix protocol family creates a socket in the file system that must
   be deleted when it is no longer needed

   [<A NAME="connect"><B>connect</B></A> (sock, addr)] attempts to connect socket sock to the
   communications peer at address addr.  If sock is a datagram socket,
   then addr is the address to which datagrams is to be sent, and the
   only address from which datagrams will be accepted.  If sock is a
   stream socket, then addr specifies another socket to which to
   connect.

   [<A NAME="listen"><B>listen</B></A> (sock, queuelen)] enables the passive stream socket sock to
   accept incoming connections.  The parameter queuelen specifies the
   maximal number of pending connections.  Further connections from
   clients may be refised when this limit is reached.

   [<A NAME="close"><B>close</B></A> sock] closes the socket.

   [<A NAME="shutdown"><B>shutdown</B></A> sock shutdown_mode] shuts down socket sock for further
   communication, as specified by the shutdown_mode parameter:

   [<A NAME="NO_RECVS"><B>NO_RECVS</B></A>]           no further receives are allowed;

   [<A NAME="NO_SENDS"><B>NO_SENDS</B></A>]           no further sends are allowed;

   [<A NAME="NO_RECVS_OR_SENDS"><B>NO_RECVS_OR_SENDS</B></A>]  no further receives or sends are allowed.

   [<A NAME="getinetaddr"><B>getinetaddr</B></A> addr] returns the Internet number
   (e.g. "130.225.40.253") of the Internet socket address addr.

   [<A NAME="buf"><B>buf</B></A>] is { buf, ofs, size } which represents a subvector or subarray:
   if size = SOME s it means buf[ofs..ofs+s-1];
   if size = NONE   it means buf[ofs..len-1] where len is the length of buf.
   When the subbuffer is used in a call, exception Subscript will be raised 
   if ofs < 0 or size < 0 or ofs+size > len.   

   [<A NAME="sendVec"><B>sendVec</B></A> (sock, vecbuf)] transmits the bytes from buffer vecbuf on
   the active stream socket sock.  Returns the number of bytes sent.
   Blocks until sufficient space is available at the socket.

   [<A NAME="sendArr"><B>sendArr</B></A> (sock, arrbuf)] is analogous til sendVec.

   [<A NAME="sendVec'"><B>sendVec'</B></A> (sock, vecbuf, out_flags)] transmits the bytes from
   buffer vecbuf on the active stream socket sock, observing the
   out_flags.  Returns the number of bytes sent.  Blocks until
   sufficient space is available at the socket.

   [<A NAME="out_flags"><B>out_flags</B></A>] is { don't_route, oob } in which the field don't_route
   specifies whether routing should be bypassed, and the field oob
   specifies whether data should be sent out-of-band.

   [<A NAME="sendArr'"><B>sendArr'</B></A> (sock, arrbuf, out_flags)] is analogous til sendVec'.

   [<A NAME="sendVecTo"><B>sendVecTo</B></A> (sock, addr, vecbuf)] transmits the bytes from buffer
   vecbuf on the datagram socket sock to the target address addr.
   Returns the number of bytes sent.  Blocks until sufficient space is
   available at the socket.

   [<A NAME="sendArrTo"><B>sendArrTo</B></A> (sock, addr, arrbuf)] is analogous til sendVecTo.

   [<A NAME="sendVecTo'"><B>sendVecTo'</B></A> (sock, addr, vecbuf, out_flags)] transmits the bytes
   from buffer vecbuf on the datagram socket sock to the target
   address addr, observing the out_flags.  Returns the number of bytes
   sent.  Blocks until sufficient space is available at the socket.
   See above for a description of vecbuf and out_flags.

   [<A NAME="sendArrTo'"><B>sendArrTo'</B></A> (sock, addr, arrbuf, out_flags)] is analogous til sendVecTo'.

   [<A NAME="recvVec"><B>recvVec</B></A> (sock, n)] receives up to n bytes from the active stream
   socket sock.  Returns a byte vector containing the bytes actually
   received.  Blocks until some data become available at the socket,
   then returns any available data, up to n bytes.  Excess data are
   not lost; they are available for subsequent receive calls.

   [<A NAME="recvArr"><B>recvArr</B></A> (sock, arrbuf)] receives bytes from the active stream
   socket sock into the subarray arrbuf, up to the available space.
   If #size(arrbuf) = SOME(s) the available space is s bytes; if
   #size(arrbuf) = NONE the available space is len - #ofs(arrbuf)
   bytes.  Returns the number of bytes actually received.  Blocks
   until some data become available at the socket.  Excess data are
   not lost; they are available for subsequent receive calls.

   [<A NAME="recvVec'"><B>recvVec'</B></A> (sock, n, in_flags)] receives up to n bytes from the
   active stream socket sock, observing the in_flags.  Returns a byte
   vector containing the bytes actually received.  Blocks until some
   data become available at the socket, then returns any available
   data, up to n bytes.  Data in excess of n bytes are not lost; they
   are available for subsequent receive calls.

   [<A NAME="in_flags"><B>in_flags</B></A>] is { peek, oob } in which the field peek specifies that
   the data read should not be removed from the receive queue, and the
   field oob specifies that data may be received out-of-band.

   [<A NAME="recvArr'"><B>recvArr'</B></A> (sock, arrbuf, in_flags)] receives bytes from the active
   stream socket sock into the subarray arrbuf, observing the
   in_flags, up to the available space..  Returns the number of bytes
   actually received.  Blocks until some data become available at the
   socket.  Excess data are not lost; they are available for
   subsequent receive calls.

   [<A NAME="recvVecFrom"><B>recvVecFrom</B></A> (sock, n)] receives up to n bytes from the datagram
   socket sock.  Returns a byte vector containing the bytes actually
   received.  Blocks until some data become available at the socket,
   then returns any available data, up to n bytes.

   [<A NAME="recvArrFrom"><B>recvArrFrom</B></A> (sock, arrbuf)] receives bytes from the datagram
   socket sock into the subarray arrbuf.  Returns the number of bytes
   actually received.  Blocks until some data become available at the
   socket.

   [<A NAME="recvVecFrom'"><B>recvVecFrom'</B></A> (sock, n, in_flags)] receives up to n bytes from the
   datagram socket sock, observing the in_flags (see above).  Returns
   (vec, addr) where vec is a byte vector containing the bytes
   actually received, and addr is the source address of the message.
   Blocks until some data become available at the socket, then returns
   any available data, up to n bytes.

   [<A NAME="recvArrFrom'"><B>recvArrFrom'</B></A> (sock, arrbuf, in_flags)] receives bytes from the
   datagram socket sock into the array buffer arrbuf, observing the
   in_flags (see above).  Returns (n, addr) where n is the number of
   bytes actually received, and addr is the source address of the
   message.  Blocks until some data become available at the socket.

   [<A NAME="sockDesc"><B>sockDesc</B></A> sock] returns a descriptor for the socket sock, to be
   used in a call to select.

   [<A NAME="compare"><B>compare</B></A> (sd1, sd2)] compares sd1 and sd2 according to an
   unspecified total ordering, and returns LESS if sd1 precedes sd2,
   returns GREATER is sd1 precedes sd2, and returns EQUAL otherwise.
   
   [<A NAME="sameDesc"><B>sameDesc</B></A> (sd1, sd2)] returns true if sd1 and sd2 describe the same
   socket.  Equivalent to compare(sd1, sd2) = EQUAL.  

   [<A NAME="select"><B>select</B></A> { rds, wrs, exs, timeout }] blocks the calling process
   until some input/output operations become possible on some sockets.
   The call will check the sockets described in rds for reading, those
   in wrs for writing, and those in exs for exceptional conditions.
   Returns { rds, wrs, exs } where rds now is a list of descriptors of
   sockets ready for reading, wrs are ready for writing, and exs have
   exceptional conditions.  The order of the socket descriptors in the
   results is the same as their order in the corresponding arguments.
   If timeout is NONE then the call blocks until some input/output
   operations become possible; if timeout is SOME(t) then the call
   blocks for at most time t.

   A server socket is considered ready for reading if there is a
   pending connection which can be accepted with `accept'.  A client
   socket is ready for writing when its connection is fully
   established.

*)

</PRE><HR><TABLE WIDTH=100%><TR ALIGN = CENTER>
<TH><A HREF="idIndex.html">Identifier index</A>
<TH><A HREF="index.html">Structure index</A>
</TABLE><HR>
<BR><EM>Moscow ML 1.44</EM></BODY></HTML>
