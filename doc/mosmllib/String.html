<HTML><HEAD><TITLE>Structure String</TITLE></HEAD>
<BODY BGCOLOR="#fbf2e7">
<H1>Structure String</H1>
<HR><TABLE WIDTH=100%><TR ALIGN = CENTER>
<TH><A HREF="idIndex.html">Identifier index</A>
<TH><A HREF="index.html">Structure index</A>
</TABLE><HR>
<PRE>
<A NAME="line1"></A>(* String -- SML Basis Library *)
<A NAME="line2"></A>
<A NAME="line3"></A>local 
<A NAME="line4"></A>    type char = Char.char
<A NAME="line5"></A>in
<A NAME="line6"></A>    type string = string
<A NAME="line7"></A>    val <A NAME="line7"></A><A HREF="#maxSize">maxSize</A>   : int
<A NAME="line8"></A>    val <A NAME="line8"></A><A HREF="#size">size</A>      : string -> int
<A NAME="line9"></A>    val <A NAME="line9"></A><A HREF="#sub">sub</A>       : string * int -> char
<A NAME="line10"></A>    val <A NAME="line10"></A><A HREF="#substring">substring</A> : string * int * int -> string
<A NAME="line11"></A>    val <A NAME="line11"></A><A HREF="#extract">extract</A>   : string * int * int option -> string
<A NAME="line12"></A>    val <A NAME="line12"></A><A HREF="#concat">concat</A>    : string list -> string
<A NAME="line13"></A>    val <A NAME="line13"></A>^         : string * string -> string
<A NAME="line14"></A>    val <A NAME="line14"></A><A HREF="#str">str</A>       : char -> string
<A NAME="line15"></A>    val <A NAME="line15"></A><A HREF="#implode">implode</A>   : char list -> string 
<A NAME="line16"></A>    val <A NAME="line16"></A><A HREF="#explode">explode</A>   : string -> char list
<A NAME="line17"></A>
<A NAME="line18"></A>    val <A NAME="line18"></A><A HREF="#map">map</A>       : (char -> char) -> string -> string 
<A NAME="line19"></A>    val <A NAME="line19"></A><A HREF="#translate">translate</A> : (char -> string) -> string -> string
<A NAME="line20"></A>    val <A NAME="line20"></A><A HREF="#tokens">tokens</A>    : (char -> bool) -> string -> string list
<A NAME="line21"></A>    val <A NAME="line21"></A><A HREF="#fields">fields</A>    : (char -> bool) -> string -> string list
<A NAME="line22"></A>    val <A NAME="line22"></A><A HREF="#isPrefix">isPrefix</A>  : string -> string -> bool
<A NAME="line23"></A>
<A NAME="line24"></A>    val <A NAME="line24"></A><A HREF="#compare">compare</A>   : string * string -> order
<A NAME="line25"></A>    val <A NAME="line25"></A><A HREF="#collate">collate</A>   : (char * char -> order) -> string * string -> order
<A NAME="line26"></A>
<A NAME="line27"></A>    val <A NAME="line27"></A><A HREF="#fromString">fromString</A>  : string -> string option     (* ML escape sequences *)
<A NAME="line28"></A>    val <A NAME="line28"></A><A HREF="#toString">toString</A>    : string -> string            (* ML escape sequences *)
<A NAME="line29"></A>    val <A NAME="line29"></A><A HREF="#fromCString">fromCString</A> : string -> string option     (* C escape sequences *)
<A NAME="line30"></A>    val <A NAME="line30"></A><A HREF="#toCString">toCString</A>   : string -> string            (* C escape sequences *)
<A NAME="line31"></A>
<A NAME="line32"></A>    val <A NAME="line32"></A><A HREF="#<"><</A>  : string * string -> bool
<A NAME="line33"></A>    val <A NAME="line33"></A><= : string * string -> bool
<A NAME="line34"></A>    val <A NAME="line34"></A>>  : string * string -> bool
<A NAME="line35"></A>    val <A NAME="line35"></A>>= : string * string -> bool
<A NAME="line36"></A>end
<A NAME="line37"></A>
<A NAME="line38"></A>(* The type [string] is the type of strings of characters.
<A NAME="line39"></A>
   [<A NAME="maxSize"><B>maxSize</B></A>] is the maximal number of characters in a string.

   [<A NAME="size"><B>size</B></A> s] is the number of characters in string s.

   [<A NAME="sub"><B>sub</B></A>(s, i)] is the i'th character of s, counting from zero.  
   Raises Subscript if i<0 or i>=size s.

   [<A NAME="substring"><B>substring</B></A>(s, i, n)] is the string s[i..i+n-1].  Raises Subscript
   if i<0 or n<0 or i+n>size s.  Equivalent to extract(s, i, SOME n).

   [<A NAME="extract"><B>extract</B></A> (s, i, NONE)] is the string s[i..size s-1].
   Raises Subscript if i<0 or i>size s. 

   [<A NAME="extract"><B>extract</B></A> (s, i, SOME n)] is the string s[i..i+n-1].
   Raises Subscript if i<0 or n<0 or i+n>size s. 

   [<A NAME="concat"><B>concat</B></A> ss] is the concatenation of all the strings in ss.
   Raises Size if the sum of their sizes is greater than maxSize.

   [<A NAME="s1"><B>s1</B></A> ^ s2] is the concatenation of strings s1 and s2.

   [<A NAME="str"><B>str</B></A> c] is the string of size one which contains the character c.

   [<A NAME="implode"><B>implode</B></A> cs] is the string containing the characters in the list cs.
   Equivalent to  concat (List.map str cs).

   [<A NAME="explode"><B>explode</B></A> s] is the list of characters in the string s.

   [<A NAME="map"><B>map</B></A> f s] applies f to every character of s, from left to right,
   and returns the string consisting of the resulting characters.
   Equivalent to  CharVector.map f s   
          and to  implode (List.map f (explode s)).

   [<A NAME="translate"><B>translate</B></A> f s] applies f to every character of s, from left to
   right, and returns the concatenation of the resulting strings.
   Raises Size if the sum of their sizes is greater than maxSize.
   Equivalent to concat (List.map f (explode s)).

   [<A NAME="tokens"><B>tokens</B></A> p s] returns the list of tokens in s, from left to right, 
   where a token is a non-empty maximal substring of s not containing 
   any delimiter, and a delimiter is a character satisfying p.

   [<A NAME="fields"><B>fields</B></A> p s] returns the list of fields in s, from left to right, 
   where a field is a (possibly empty) maximal substring of s not 
   containing any delimiter, and a delimiter is a character satisfying p.

   Two tokens may be separated by more than one delimiter, whereas two
   fields are separated by exactly one delimiter.  If the only delimiter 
   is the character #"|", then
   	"abc||def" contains two tokens:   "abc" and "def"
   	"abc||def" contains three fields: "abc" and "" and "def"

   [<A NAME="isPrefix"><B>isPrefix</B></A> s1 s2] is true if s1 is a prefix of s2.  
   That is, if there exists a string t such that s1 ^ t = s2.

   [<A NAME="fromString"><B>fromString</B></A> s] scans the string s as an ML source program string,
   converting escape sequences into the appropriate characters.  Does
   not skip leading whitespace.

   [<A NAME="toString"><B>toString</B></A> s] returns a string corresponding to s, with
   non-printable characters replaced by ML escape sequences.
   Equivalent to String.translate Char.toString.

   [<A NAME="fromCString"><B>fromCString</B></A> s] scans the string s as a C source program string,
   converting escape sequences into the appropriate characters.  Does
   not skip leading whitespace.

   [<A NAME="toCString"><B>toCString</B></A> s] returns a string corresponding to s, with
   non-printable characters replaced by C escape sequences.
   Equivalent to String.translate Char.toCString.

   [<A NAME="compare"><B>compare</B></A> (s1, s2)] does lexicographic comparison, using the
   standard ordering Char.compare on the characters.  Returns LESS,
   EQUAL, or GREATER, according as s1 is less than, equal to, or
   greater than s2.

   [<A NAME="collate"><B>collate</B></A> cmp (s1, s2)] performs lexicographic comparison, using the 
   given ordering cmp on characters.  

   [<A NAME="<"><B><</B></A>], [<=], [>], and [>=] compare strings lexicographically.
*)


</PRE><HR><TABLE WIDTH=100%><TR ALIGN = CENTER>
<TH><A HREF="idIndex.html">Identifier index</A>
<TH><A HREF="index.html">Structure index</A>
</TABLE><HR>
<BR><EM>Moscow ML 1.44</EM></BODY></HTML>
