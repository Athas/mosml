<HTML><HEAD><TITLE>Structure Array2</TITLE></HEAD>
<BODY BGCOLOR="#fbf2e7">
<H1>Structure Array2</H1>
<HR><TABLE WIDTH=100%><TR ALIGN = CENTER>
<TH><A HREF="idIndex.html">Identifier index</A>
<TH><A HREF="index.html">Structure index</A>
</TABLE><HR>
<PRE>
<A NAME="line1"></A>(* Array2 -- SML Basis Library *)
<A NAME="line2"></A>
<A NAME="line3"></A>eqtype 'a array
<A NAME="line4"></A>
<A NAME="line5"></A>datatype traversal = RowMajor | ColMajor
<A NAME="line6"></A>
<A NAME="line7"></A>val <A NAME="line7"></A><A HREF="#array">array</A>      : int * int * '_a -> '_a array
<A NAME="line8"></A>val <A NAME="line8"></A>fromList   : '_a list list -> '_a array
<A NAME="line9"></A>val <A NAME="line9"></A><A HREF="#tabulate">tabulate</A>   : traversal -> int * int * (int * int -> '_a) -> '_a array
<A NAME="line10"></A>
<A NAME="line11"></A>val <A NAME="line11"></A><A HREF="#dimensions">dimensions</A> : 'a array -> int * int
<A NAME="line12"></A>val <A NAME="line12"></A><A HREF="#nCols">nCols</A>      : 'a array -> int
<A NAME="line13"></A>val <A NAME="line13"></A><A HREF="#nRows">nRows</A>      : 'a array -> int
<A NAME="line14"></A>
<A NAME="line15"></A>val <A NAME="line15"></A><A HREF="#sub">sub</A>        : 'a array * int * int -> 'a
<A NAME="line16"></A>val <A NAME="line16"></A><A HREF="#update">update</A>     : 'a array * int * int * 'a -> unit
<A NAME="line17"></A>
<A NAME="line18"></A>val <A NAME="line18"></A><A HREF="#row">row</A>        : 'a array * int -> 'a Vector.vector
<A NAME="line19"></A>val <A NAME="line19"></A><A HREF="#column">column</A>     : 'a array * int -> 'a Vector.vector
<A NAME="line20"></A>
<A NAME="line21"></A>type 'a region = { base : 'a array, row : int, col : int, 
<A NAME="line22"></A>                   nrows : int option, ncols : int option}
<A NAME="line23"></A>
<A NAME="line24"></A>val <A NAME="line24"></A><A HREF="#copy">copy</A>       : { src : 'a region, dst : 'a array, 
<A NAME="line25"></A>                   dst_row : int, dst_col : int } -> unit
<A NAME="line26"></A>
<A NAME="line27"></A>val <A NAME="line27"></A><A HREF="#app">app</A>        : traversal -> ('a -> unit) -> 'a array -> unit
<A NAME="line28"></A>val <A NAME="line28"></A><A HREF="#modify">modify</A>     : traversal -> ('a -> 'a) -> 'a array -> unit
<A NAME="line29"></A>val <A NAME="line29"></A><A HREF="#fold">fold</A>       : traversal -> ('a * 'b -> 'b) -> 'b -> 'a array -> 'b
<A NAME="line30"></A>
<A NAME="line31"></A>val <A NAME="line31"></A><A HREF="#appi">appi</A>       : traversal -> (int * int * 'a -> unit) -> 'a region -> unit
<A NAME="line32"></A>val <A NAME="line32"></A><A HREF="#modifyi">modifyi</A>    : traversal -> (int * int * 'a -> 'a) -> 'a region -> unit
<A NAME="line33"></A>val <A NAME="line33"></A><A HREF="#foldi">foldi</A>      : traversal -> (int * int * 'a * 'b -> 'b) -> 'b 
<A NAME="line34"></A>                 -> 'a region -> 'b
<A NAME="line35"></A>
<A NAME="line36"></A>(* Type [ty Array2.array] is the type of two-dimensional, mutable,
<A NAME="line37"></A>   zero-based constant-time-access arrays with elements of type ty.
<A NAME="line38"></A>   Type ty array admits equality even if ty does not.  Arrays a1 and
<A NAME="line39"></A>   a2 are equal if both were created by the same call to one of the
<A NAME="line40"></A>   primitives array, fromList, and tabulate.
<A NAME="line41"></A>
   [<A NAME="RowMajor"><B>RowMajor</B></A>] specifies that an operation must be done in row-major
   order, that is, one row at a time, from top to bottom, and from
   left to right within each row.  Row-major traversal visits the
   elements of an (m,n)-array with m rows and n columns in this 
   order:
            (0,0), (0,1), (0,2), ..., (0,n-1), 
            (1,0), (1,1), (1,2), ..., (1,n-1), 
                    ...
   that is, in order of lexicographically increasing (i, j).  In
   Moscow ML, row-major traversal is usually faster than column-major
   traversal.

   [<A NAME="ColMajor"><B>ColMajor</B></A>] specifies that an operation must be done in column-major
   order, that is, one column at a time, from left to right, and from
   top to bottom within each column.  Column-major traversal visits
   the elements of an (m,n)-array with m rows and n columns in this
   order:
            (0,0), (1,0), (2,0), ..., (m-1,0), 
            (0,1), (1,1), (2,1), ..., (m-1,1), 
                    ...
   that is, in order of lexicographically increasing (j, i).  

   [<A NAME="array"><B>array</B></A>(m, n, x)] returns a new m * n matrix whose elements are all x.  
   Raises Size if n<0 or m<0.

   [<A NAME="fromlist"><B>fromlist</B></A> xss] returns a new array whose first row has elements
   xs1, second row has elements xs2, ..., where xss = [xs1,xs2,...,xsm].  
   Raises Size if the lists in xss do not all have the same length.

   [<A NAME="tabulate"><B>tabulate</B></A> RowMajor (m, n, f)] returns a new m-by-n array whose 
   elements are f(0,0), f(0,1), ..., f(0, n-1), 
                f(1,0), f(1,1), ..., f(1, n-1),
                    ...
                f(m-1,0),    ...,    f(m-1, n-1)
   created in row-major order: f(0,0), f(0,1), ..., f(1,0), f(1,1), ...
   Raises Size if n<0 or m<0.

   [<A NAME="tabulate"><B>tabulate</B></A> ColMajor (m, n, f)] returns a new m-by-n array whose 
   elements are as above, but created in the column-major order:
   f(0,0), f(1,0), ..., f(0, 1), f(1, 1), ...  Raises Size if n<0 or m<0.

   [<A NAME="dimensions"><B>dimensions</B></A> a] returns the dimensions (m, n) of a, where m is the
   number of rows and n the number of columns.

   [<A NAME="nCols"><B>nCols</B></A> a] returns the number of n of columns of a.

   [<A NAME="nRows"><B>nRows</B></A> a] returns the number of m of rows of a.

   [<A NAME="sub"><B>sub</B></A>(a, i, j)] returns the i'th row's j'th element, counting from 0.
   Raises Subscript if i<0 or j<0 or i>=m or j>=n 
   where (m,n) = dimensions a.

   [<A NAME="update"><B>update</B></A>(a, i, j, x)] destructively replaces the (i,j)'th element of a 
   by x. Raises Subscript if i<0 or j<0 or i>=m or j>=n 
   where (m,n) = dimensions a. 

   [<A NAME="row"><B>row</B></A> (a, i)] returns a vector containing the elements of the ith
   row of a.  Raises Subscript if i < 0 or i >= height a.

   [<A NAME="column"><B>column</B></A> (a, j)] returns a vector containing the elements of the jth
   column of a.  Raises Subscript if j < 0 or j >= width a.

   [<A NAME="app"><B>app</B></A> RowMajor f a] applies f to the elements a[0,0], a[0,1], ...,
   a[0,n-1], a[1,0], ..., a[m-1, n-1] of a, where (m, n) = dimensions a.

   [<A NAME="app"><B>app</B></A> ColMajor f a] applies f to the elements a[0,0], a[1,0], ...,
   a[n-1,0], a[0,1], a[1,1], ..., a[m-1, n-1] of a, where (m, n) =
   dimensions a.

   [<A NAME="modify"><B>modify</B></A> RowMajor f a] applies f to the elements a[0,0], a[0,1],
   ..., a[0,n-1], a[1,0], ..., a[m-1, n-1] of a, updating each element
   with the result of the application, where (m, n) = dimensions a.

   [<A NAME="modify"><B>modify</B></A> ColMajor f a] applies f to the elements a[0,0], a[1,0],
   ..., a[n-1,0], a[0,1], a[1,1], ..., a[m-1, n-1] of a, updating each
   element with the result of the application, where (m, n) =
   dimensions a.

   [<A NAME="fold"><B>fold</B></A> RowMajor f b a] folds f left-right and top-down over the
   elements of a in row-major order.  That is, computes
        f(a[m-1, n-1], f(a[m-1, n-2], ..., f(a[0,1], f(a[0,0], b)) ...))
   where (m, n) = dimensions a.

   [<A NAME="fold"><B>fold</B></A> ColMajor f b a] folds f left-right and top-down over the
   elements of a in column-major order.  That is, computes
        f(a[m-1, n-1], f(a[m-2, n-1], ..., f(a[1,0], f(a[0,0], b)) ...))
   where (m, n) = dimensions a.


   The following iterators generalize the above ones in two ways:

     . the indexes i and j are also being passed to the function;
     . the iterators work on a region (submatrix) of a matrix.          

   The region { base, row, col, nrows, ncols } determines a region or
   submatrix of base whose upper left corner has index (row, col).  

   If nrows = SOME r, then the region has r rows: row, row+1, ..., row+r-1.
   If nrows = NONE, then the region extends to the bottom of the matrix.
   The field ncols similarly determines the number of columns.

   A region is valid for an array with dimensions (m, n) if 
       (1) either nrows = NONE and 0 <= row <= m 
           or nrows = SOME r and 0 <= row <= row + r <= m 
   and (2) either ncols = NONE and 0 <= col <= n
           or ncols = SOME c and 0 <= col <= col + c <= n.

   [<A NAME="appi"><B>appi</B></A> RowMajor f reg] applies f to (i, j, a[i, j]) in order of
   lexicographically increasing (i, j) within the region reg.  Raises
   Subscript if reg is not valid.  Note that app tr f a is equivalent
   to appi tr (f o #3) {base=a, row=0, col=0, nrows=NONE, ncols=NONE}

   [<A NAME="appi"><B>appi</B></A> ColMajor f reg] applies f to (i, j, a[i, j]) in order of
   lexicographically increasing (j, i) within the region reg.  Raises
   Subscript if reg is not valid.  

   [<A NAME="modifyi"><B>modifyi</B></A> RowMajor f reg)] applies f to (i, j, a[i, j]) in order of
   lexicographically increasing (i, j) within the region reg.  Raises
   Subscript if reg is not valid.  Note that modify tr f a is equivalent 
   to modifyi (f o #3) {base=a, row=0, col=0, nrows=NONE, ncols=NONE}).

   [<A NAME="modifyi"><B>modifyi</B></A> ColMajor f reg)] applies f to (i, j, a[i, j]) in order of
   lexicographically increasing (j, i) within the region reg.  Raises
   Subscript if reg is not valid.  

   [<A NAME="foldi"><B>foldi</B></A> RowMajor f b a] folds f over (i, j, a[i, j]) in row-major
   order within the region reg, that is, for lexicographically
   increasing (i, j) in the region.  Raises Subscript if reg is not
   valid.

   [<A NAME="foldi"><B>foldi</B></A> ColMajor f b a] folds f over (i, j, a[i, j]) in column-major
   order within the region reg, that is, for lexicographically
   increasing (j, i) in the region.  Raises Subscript if reg is not
   valid.

   [<A NAME="copy"><B>copy</B></A> { src, dst, dst_row, dst_col }] copies the region determined
   by src to array dst such that the upper leftmost corner of src is
   copied to dst[dst_row, dst_col].  Works correctly even when src and
   dst are the same and the source and destination regions overlap.
   Raises Subscript if the src region is invalid, or if src translated
   to (dst_row, dst_col) is invalid for dst.

*)

</PRE><HR><TABLE WIDTH=100%><TR ALIGN = CENTER>
<TH><A HREF="idIndex.html">Identifier index</A>
<TH><A HREF="index.html">Structure index</A>
</TABLE><HR>
<BR><EM>Moscow ML 1.44</EM></BODY></HTML>
