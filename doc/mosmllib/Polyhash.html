<HTML><HEAD><TITLE>Structure Polyhash</TITLE></HEAD>
<BODY BGCOLOR="#fbf2e7">
<H1>Structure Polyhash</H1>
<HR><TABLE WIDTH=100%><TR ALIGN = CENTER>
<TH><A HREF="idIndex.html">Identifier index</A>
<TH><A HREF="index.html">Structure index</A>
</TABLE><HR>
<PRE>
<A NAME="line1"></A>(* Polyhash -- polymorphic hashtables as in the SML/NJ Library *)
<A NAME="line2"></A>
<A NAME="line3"></A>type <A NAME="line3"></A>('key, 'data) hash_table
<A NAME="line4"></A>
<A NAME="line5"></A>val <A NAME="line5"></A><A HREF="#mkTable">mkTable</A>     : ('_key -&gt; int) * ('_key * '_key -&gt; bool) -&gt; int * exn 
<A NAME="line6"></A>                  -&gt; ('_key, '_data) hash_table
<A NAME="line7"></A>val <A NAME="line7"></A><A HREF="#numItems">numItems</A>    : ('key, 'data) hash_table -&gt; int
<A NAME="line8"></A>val <A NAME="line8"></A><A HREF="#insert">insert</A>      : ('_key, '_data) hash_table -&gt; '_key * '_data -&gt; unit
<A NAME="line9"></A>val <A NAME="line9"></A><A HREF="#peekInsert">peekInsert</A>  : ('_key, '_data) hash_table -&gt; '_key * '_data 
<A NAME="line10"></A>                  -&gt; '_data option
<A NAME="line11"></A>val <A NAME="line11"></A><A HREF="#find">find</A>        : ('key, 'data) hash_table -&gt; 'key -&gt; 'data
<A NAME="line12"></A>val <A NAME="line12"></A><A HREF="#peek">peek</A>        : ('key, 'data) hash_table -&gt; 'key -&gt; 'data option
<A NAME="line13"></A>val <A NAME="line13"></A><A HREF="#remove">remove</A>      : ('key, 'data) hash_table -&gt; 'key -&gt; 'data
<A NAME="line14"></A>val <A NAME="line14"></A><A HREF="#listItems">listItems</A>   : ('key, 'data) hash_table -&gt; ('key * 'data) list
<A NAME="line15"></A>val <A NAME="line15"></A><A HREF="#apply">apply</A>       : ('key * 'data -&gt; unit) -&gt; ('key, 'data) hash_table -&gt; unit
<A NAME="line16"></A>val <A NAME="line16"></A><A HREF="#map">map</A>         : ('_key * 'data -&gt; '_res) -&gt; ('_key, 'data) hash_table 
<A NAME="line17"></A>                  -&gt; ('_key, '_res) hash_table
<A NAME="line18"></A>val <A NAME="line18"></A><A HREF="#filter">filter</A>      : ('key * 'data -&gt; bool) -&gt; ('key, 'data) hash_table -&gt; unit
<A NAME="line19"></A>val <A NAME="line19"></A><A HREF="#transform">transform</A>   : ('data -&gt; '_res) -&gt; ('_key, 'data) hash_table 
<A NAME="line20"></A>                  -&gt; ('_key, '_res) hash_table
<A NAME="line21"></A>val <A NAME="line21"></A><A HREF="#copy">copy</A>        : ('_key, '_data) hash_table -&gt; ('_key, '_data) hash_table
<A NAME="line22"></A>val <A NAME="line22"></A><A HREF="#bucketSizes">bucketSizes</A> : ('key, 'data) hash_table -&gt; int list
<A NAME="line23"></A>
<A NAME="line24"></A>(*** Polymorphic hash primitives from Caml Light *)
<A NAME="line25"></A>
<A NAME="line26"></A>val <A NAME="line26"></A><A HREF="#hash">hash</A>        : 'key -&gt; int
<A NAME="line27"></A>val <A NAME="line27"></A><A HREF="#hash_param">hash_param</A>  : int -&gt; int -&gt; 'key -&gt; int
<A NAME="line28"></A>val <A NAME="line28"></A><A HREF="#mkPolyTable">mkPolyTable</A> : int * exn -&gt; (''_key, '_data) hash_table
<A NAME="line29"></A>
<A NAME="line30"></A>
<A NAME="line31"></A>(* [('key, 'data) hash_table] is the type of hashtables with keys of type
<A NAME="line32"></A>   'key and data values of type 'data.
<A NAME="line33"></A>
   [<A NAME="mkTable"><B>mkTable</B></A> (hashVal, sameKey) (sz, exc)] returns a new hashtable,
   using hash function hashVal and equality predicate sameKey.  The sz
   is a size hint, and exc is the exception raised by function find.
   It must be the case that sameKey(k1, k2) implies hashVal(k1) =
   hashVal(k2) for all k1,k2.

   [<A NAME="numItems"><B>numItems</B></A> htbl] is the number of items in the hash table.

   [<A NAME="insert"><B>insert</B></A> htbl (k, d)] inserts data d for key k.  If k already had an
   item associated with it, then the old item is overwritten.

   [<A NAME="find"><B>find</B></A> htbl k] returns d, where d is the data item associated with key k, 
   or raises the exception (given at creation of htbl) if there is no such d.

   [<A NAME="peek"><B>peek</B></A> htbl k] returns SOME d, where d is the data item associated with 
   key k, or NONE if there is no such d.

   [<A NAME="peekInsert"><B>peekInsert</B></A> htbl (k, d)] inserts data d for key k, if k is not
   already in the table, returning NONE.  If k is already in the
   table, and the associated data value is d', then returns SOME d'
   and leaves the table unmodified.

   [<A NAME="remove"><B>remove</B></A> htbl k] returns d, where d is the data item associated with key k, 
   removing d from the table; or raises the exception if there is no such d.

   [<A NAME="listItems"><B>listItems</B></A> htbl] returns a list of the (key, data) pairs in the hashtable.

   [<A NAME="apply"><B>apply</B></A> f htbl] applies function f to all (key, data) pairs in the 
   hashtable, in some order.

   [<A NAME="map"><B>map</B></A> f htbl] returns a new hashtable, whose data items have been
   obtained by applying f to the (key, data) pairs in htbl.  The new
   tables have the same keys, hash function, equality predicate, and
   exception, as htbl.

   [<A NAME="filter"><B>filter</B></A> p htbl] deletes from htbl all data items which do not
   satisfy predicate p.

   [<A NAME="transform"><B>transform</B></A> f htbl] as map, but only the (old) data values are used
   when computing the new data values.

   [<A NAME="copy"><B>copy</B></A> htbl] returns a complete copy of htbl.

   [<A NAME="bucketSizes"><B>bucketSizes</B></A> htbl] returns a list of the sizes of the buckets.
   This is to allow users to gauge the quality of their hashing
   function.  

   [<A NAME="hash"><B>hash</B></A> k] returns the hash value of k, as a positive integer. If
   k1=k2 then hash(k1) = hash(k2), so this function can be used when
   creating hashtables.  The application hash(k) always terminates,
   even on cyclic structures.  (From the Caml Light implementation).

   [<A NAME="hash_param"><B>hash_param</B></A> n m k] computes a hash value for k with the same
   properties as for hash. The parameters n and m give more precise
   control over hashing.  Hashing performs a depth-first,
   right-to-left traversal of the structure k, stopping after n
   meaningful nodes were encountered, or m nodes, meaningful or not,
   were encountered. Meaningful nodes are: integers, floating-point
   numbers, strings, characters, booleans, references, and constant
   constructors. 

   [<A NAME="mkPolyTable"><B>mkPolyTable</B></A> (sz, exc)] creates a new hashtable using the
   polymorphic hash function (hash) and ML equality (op =); the integer 
   sz is a size hint and the exception exc is to be raised by find.  
*)

</PRE><HR><TABLE WIDTH=100%><TR ALIGN = CENTER>
<TH><A HREF="idIndex.html">Identifier index</A>
<TH><A HREF="index.html">Structure index</A>
</TABLE><HR>
<BR><EM>Moscow ML 1.44</EM></BODY></HTML>
