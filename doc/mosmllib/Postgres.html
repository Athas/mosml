<HTML><HEAD><TITLE>Structure Postgres</TITLE></HEAD>
<BODY BGCOLOR="#fbf2e7">
<H1>Structure Postgres</H1>
<HR><TABLE WIDTH=100%><TR ALIGN = CENTER>
<TH><A HREF="idIndex.html">Identifier index</A>
<TH><A HREF="index.html">Structure index</A>
</TABLE><HR>
<PRE>
<A NAME="line1"></A>(* Postgres -- Moscow ML interface to the PostgreSQL database server *)
<A NAME="line2"></A>(* This module requires Dynlib and PostgreSQL to be installed        *)
<A NAME="line3"></A>
<A NAME="line4"></A>type dbconn;                            (* A connection to the server *)
<A NAME="line5"></A>type dbresult;                          (* The result of a query      *)
<A NAME="line6"></A>type oid;                               (* Internal object ids        *)
<A NAME="line7"></A>
<A NAME="line8"></A>exception Closed;                       (* The connection is closed   *)
<A NAME="line9"></A>exception Null;                         (* The field's value is NULL  *)
<A NAME="line10"></A>
<A NAME="line11"></A>(* Opening, closing, and maintaining database connections *)
<A NAME="line12"></A>
<A NAME="line13"></A>val <A NAME="line13"></A><A HREF="#openbase">openbase</A> : { dbhost    : string option, (* database server host *)
<A NAME="line14"></A>                 dbname    : string option, (* database name        *)
<A NAME="line15"></A>                 dboptions : string option, (* options              *)
<A NAME="line16"></A>                 dbport    : string option, (* database server port *)
<A NAME="line17"></A>                 dbpwd     : string option, (* user passwd          *)
<A NAME="line18"></A>                 dbtty     : string option, (* tty for error log    *)
<A NAME="line19"></A>                 dbuser    : string option  (* database user        *)
<A NAME="line20"></A>               } -> dbconn
<A NAME="line21"></A>
<A NAME="line22"></A>val <A NAME="line22"></A><A HREF="#closebase">closebase</A>    : dbconn -> unit
<A NAME="line23"></A>val <A NAME="line23"></A><A HREF="#db">db</A>           : dbconn -> string
<A NAME="line24"></A>val <A NAME="line24"></A><A HREF="#host">host</A>         : dbconn -> string option
<A NAME="line25"></A>val <A NAME="line25"></A><A HREF="#options">options</A>      : dbconn -> string
<A NAME="line26"></A>val <A NAME="line26"></A><A HREF="#port">port</A>         : dbconn -> string
<A NAME="line27"></A>val <A NAME="line27"></A><A HREF="#tty">tty</A>          : dbconn -> string
<A NAME="line28"></A>
<A NAME="line29"></A>val <A NAME="line29"></A><A HREF="#status">status</A>       : dbconn -> bool
<A NAME="line30"></A>val <A NAME="line30"></A><A HREF="#reset">reset</A>        : dbconn -> unit
<A NAME="line31"></A>val <A NAME="line31"></A><A HREF="#errormessage">errormessage</A> : dbconn -> string option
<A NAME="line32"></A>
<A NAME="line33"></A>(* Query execution and result set information *)
<A NAME="line34"></A>
<A NAME="line35"></A>datatype dbresultstatus =
<A NAME="line36"></A>    Empty_query
<A NAME="line37"></A>  | Command_ok          (* The query was a command                *)
<A NAME="line38"></A>  | Tuples_ok           (* The query successfully returned tuples *)
<A NAME="line39"></A>  | Copy_out            (* The query was "copy <table> to ..."    *)
<A NAME="line40"></A>  | Copy_in             (* The query was "copy <table> from ..."  *)
<A NAME="line41"></A>  | Bad_response        (* An unexpected response was received    *)
<A NAME="line42"></A>  | Nonfatal_error
<A NAME="line43"></A>  | Fatal_error
<A NAME="line44"></A>
<A NAME="line45"></A>val <A NAME="line45"></A><A HREF="#execute">execute</A>      : dbconn -> string -> dbresult
<A NAME="line46"></A>val <A NAME="line46"></A><A HREF="#resultstatus">resultstatus</A> : dbresult -> dbresultstatus
<A NAME="line47"></A>val <A NAME="line47"></A><A HREF="#ntuples">ntuples</A>      : dbresult -> int
<A NAME="line48"></A>val <A NAME="line48"></A><A HREF="#cmdtuples">cmdtuples</A>    : dbresult -> int
<A NAME="line49"></A>val <A NAME="line49"></A><A HREF="#nfields">nfields</A>      : dbresult -> int
<A NAME="line50"></A>val <A NAME="line50"></A><A HREF="#fname">fname</A>        : dbresult -> int -> string
<A NAME="line51"></A>val <A NAME="line51"></A><A HREF="#fnames">fnames</A>       : dbresult -> string vector
<A NAME="line52"></A>val <A NAME="line52"></A><A HREF="#fnumber">fnumber</A>      : dbresult -> string -> int option
<A NAME="line53"></A>
<A NAME="line54"></A>(* Accessing the fields of a resultset *)
<A NAME="line55"></A>
<A NAME="line56"></A>val <A NAME="line56"></A><A HREF="#getint">getint</A>       : dbresult -> int -> int -> int
<A NAME="line57"></A>val <A NAME="line57"></A><A HREF="#getreal">getreal</A>      : dbresult -> int -> int -> real
<A NAME="line58"></A>val <A NAME="line58"></A><A HREF="#getstring">getstring</A>    : dbresult -> int -> int -> string
<A NAME="line59"></A>val <A NAME="line59"></A><A HREF="#getdate">getdate</A>      : dbresult -> int -> int -> int * int * int (* Y M D *)
<A NAME="line60"></A>val <A NAME="line60"></A><A HREF="#gettime">gettime</A>      : dbresult -> int -> int -> int * int * int (* H M S *)
<A NAME="line61"></A>val <A NAME="line61"></A><A HREF="#getdatetime">getdatetime</A>  : dbresult -> int -> int -> Date.date
<A NAME="line62"></A>val <A NAME="line62"></A><A HREF="#getbool">getbool</A>      : dbresult -> int -> int -> bool
<A NAME="line63"></A>val <A NAME="line63"></A><A HREF="#isnull">isnull</A>       : dbresult -> int -> int -> bool
<A NAME="line64"></A>
<A NAME="line65"></A>datatype dynval =
<A NAME="line66"></A>    Bool of bool                        (* psql bool            *)
<A NAME="line67"></A>  | Int of int                          (* psql int4            *)
<A NAME="line68"></A>  | Real of real                        (* psql float8, float4  *)
<A NAME="line69"></A>  | String of string                    (* psql text, varchar   *)
<A NAME="line70"></A>  | Date of int * int * int             (* psql date yyyy-mm-dd *)
<A NAME="line71"></A>  | Time of int * int * int             (* psql time hh:mm:ss   *)
<A NAME="line72"></A>  | DateTime of Date.date               (* psql datetime        *)
<A NAME="line73"></A>  | Oid of oid                          (* psql oid             *)
<A NAME="line74"></A>  | Bytea of Word8Array.array           (* psql bytea           *)
<A NAME="line75"></A>  | NullVal                             (* psql NULL            *)
<A NAME="line76"></A>
<A NAME="line77"></A>val <A NAME="line77"></A><A HREF="#getdynfield">getdynfield</A>  : dbresult -> int -> (int -> dynval)
<A NAME="line78"></A>val <A NAME="line78"></A><A HREF="#getdyntup">getdyntup</A>    : dbresult -> (int -> dynval vector)
<A NAME="line79"></A>val <A NAME="line79"></A><A HREF="#getdyntups">getdyntups</A>   : dbresult -> dynval vector vector 
<A NAME="line80"></A>
<A NAME="line81"></A>(* Bulk copying to or from a table *)
<A NAME="line82"></A>
<A NAME="line83"></A>val <A NAME="line83"></A><A HREF="#copytableto">copytableto</A>   : dbconn * string * (string -> unit) -> unit
<A NAME="line84"></A>val <A NAME="line84"></A><A HREF="#copytablefrom">copytablefrom</A> : dbconn * string * ((string -> unit) -> unit) -> unit
<A NAME="line85"></A>
<A NAME="line86"></A>(* Some standard ML and Postgres types: *)
<A NAME="line87"></A>
<A NAME="line88"></A>datatype dyntype = 
<A NAME="line89"></A>    BoolTy              (* ML bool              psql bool              *)
<A NAME="line90"></A>  | IntTy               (* ML int               psql int4              *)
<A NAME="line91"></A>  | RealTy              (* ML real              psql float8, float4    *)
<A NAME="line92"></A>  | StringTy            (* ML string            psql text, varchar     *) 
<A NAME="line93"></A>  | DateTy              (* ML (yyyy, mth, day)  psql date              *)
<A NAME="line94"></A>  | TimeTy              (* ML (hh, mm, ss)      psql time              *)
<A NAME="line95"></A>  | DateTimeTy          (* ML Date.date         psql datetime, abstime *)
<A NAME="line96"></A>  | OidTy               (* ML oid               psql oid               *)
<A NAME="line97"></A>  | ByteArrTy           (* ML Word8Array.array  psql bytea             *)
<A NAME="line98"></A>  | UnknownTy of oid
<A NAME="line99"></A>
<A NAME="line100"></A>val <A NAME="line100"></A><A HREF="#fromtag">fromtag</A> : dyntype -> string
<A NAME="line101"></A>val <A NAME="line101"></A><A HREF="#ftype">ftype</A>   : dbresult -> int -> dyntype
<A NAME="line102"></A>val <A NAME="line102"></A><A HREF="#ftypes">ftypes</A>  : dbresult -> dyntype Vector.vector
<A NAME="line103"></A>
<A NAME="line104"></A>val <A NAME="line104"></A><A HREF="#applyto">applyto</A> : 'a -> ('a -> 'b) -> 'b
<A NAME="line105"></A>
<A NAME="line106"></A>(*
<A NAME="line107"></A>   Type [dbconn] is the type of connections to a PostgreSQL database.
<A NAME="line108"></A>
<A NAME="line109"></A>   Type [dbresult] is the type of result sets from SQL queries.
<A NAME="line110"></A>
<A NAME="line111"></A>   Type [oid] is the type of PostgreSQL internal object ids.
<A NAME="line112"></A>
   [<A NAME="openbase"><B>openbase</B></A> { dbhost, dbport, dboptions, dbtty, dbname, dbuser, dbpwd  }] 
   opens a connection to a PostgreSQL database server on the given
   host (default the local one) on the given port (default 5432), with
   the given options (default the empty string), with error logging on
   the given tty (default?), to the given database (defaults to the
   user's login name), for the given user name (defaults to the
   current user's login name), and the given password (default none).
   The result is a connection which may be used in subsequent queries.

   [<A NAME="closebase"><B>closebase</B></A> dbconn] closes the database connection.  No further
   queries can be executed.

   [<A NAME="db"><B>db</B></A> dbconn] returns the name of the database.

   [<A NAME="host"><B>host</B></A> dbconn] returns SOME h, where h is the database server host
   name, if the connection uses the Internet; returns NONE if the
   connection is to a socket on the local server.

   [<A NAME="options"><B>options</B></A> dbconn] returns the options given when opening the database.

   [<A NAME="port"><B>port</B></A> dbconn] returns the port number of the connection.

   [<A NAME="tty"><B>tty</B></A> dbconn] returns the name of the tty used for logging.

   [<A NAME="status"><B>status</B></A> dbconn] returns true if the connection is usable, false
   otherwise.

   [<A NAME="reset"><B>reset</B></A> dbconn] attempts to close and then reopen the connection to
   the database server.

   [<A NAME="errormessage"><B>errormessage</B></A> dbconn] returns NONE if no error occurred, and SOME msg
   if an error occurred, where msg describes the error.

   [<A NAME="execute"><B>execute</B></A> dbconn query] sends an SQL query to the database server
   for execution, and returns a resultset dbres.
   
   [<A NAME="resultstatus"><B>resultstatus</B></A> dbres] returns the status of the result set dbres.
   After a select query that succeeded, it will be Tuples_ok.
   
   [<A NAME="ntuples"><B>ntuples</B></A> dbres] returns the number of tuples in the result set
   after a query.

   [<A NAME="cmdtuples"><B>cmdtuples</B></A> dbres] returns the number of tuples affected by an
   insert, update, or delete SQL command.

   [<A NAME="nfields"><B>nfields</B></A> dbres] returns the number of fields in each tuple after a
   query.

   [<A NAME="fname"><B>fname</B></A> dbres fno] returns the name of field number fno (in the
   result set after a query).  The fields are numbered 0, 1,...

   [<A NAME="fnames"><B>fnames</B></A> dbres] returns a vector of the field names (in the result
   set after a query).

   [<A NAME="fnumber"><B>fnumber</B></A> dbres fname] returns SOME i where i is the number (0, 1,
   ...) of the field called fname (in the result set after a query),
   if the result set contains such a field name; returns NONE otherwise.

   [<A NAME="ftype"><B>ftype</B></A> dbres fno] returns the dyntype of field number fno (in the
   result set after a query).

   [<A NAME="ftypes"><B>ftypes</B></A> dbres] returns a vector of the dyntypes (in the result set
   after a query).

   [<A NAME="fromtag"><B>fromtag</B></A> dt] returns the name of the preferred PostgreSQL type used
   to represent values of the dyntype dt.  This may be used when
   building `create table' statements.

   [<A NAME="getint"><B>getint</B></A> dbres fno tupno] returns the integer value of field number
   fno in tuple tupno of result set dbres.  Raises Null if the value
   is NULL.

   [<A NAME="getreal"><B>getreal</B></A> dbres fno tupno] returns the floating-point value of field
   number fno in tuple tupno of result set dbres.  Raises Null if the
   value is NULL.

   [<A NAME="getstring"><B>getstring</B></A> dbres fno tupno] returns the string value of field
   number fno in tuple tupno of result set dbres.  Raises Null if the
   value is NULL.

   [<A NAME="getdate"><B>getdate</B></A> dbres fno tupno] returns the date (yyyy, mth, day) value
   of field number fno in tuple tupno of result set dbres.  Raises
   Null if the value is NULL.  Raises Fail if the field cannot be
   scanned as a date.

   [<A NAME="gettime"><B>gettime</B></A> dbres fno tupno] returns the time-of-day (hh, mm, ss)
   value of field number fno in tuple tupno of result set dbres.
   Raises Null if the value is NULL.  Raises Fail if the field cannot
   be scanned as a time.

   [<A NAME="getdatetime"><B>getdatetime</B></A> dbres fno tupno] returns the Date.date value of field
   number fno in tuple tupno of result set dbres.  Raises Null if the
   value is NULL.  Raises Fail if the field cannot be scanned as a
   date.

   [<A NAME="getbool"><B>getbool</B></A> dbres fno tupno] returns the boolean value of field number
   fno in tuple tupno of result set dbres.  Raises Null if the value
   is NULL.

   [<A NAME="isnull"><B>isnull</B></A> dbres fno tupno] returns true if the value of field number
   fno in tuple tupno of result set dbres is NULL; false otherwise.

   [<A NAME="getdynfield"><B>getdynfield</B></A> dbres fno tupno] returns the value of field number fno
   in tuple tupno of result set dbres as a dynval (a wrapped value).
   A NULL value is returned as NullVal.  Note that the partial
   application  (getdynfield dbres fno)  precomputes the type of the 
   field fno.  Hence it is far more efficient to compute 
        let val getfno = getdynfield dbres fno
        in tabulate(ntuples dbres, getfno) end
   than to compute
        let fun getfno tupno = getdynfield dbres fno tupno
        in tabulate(ntuples dbres, getfno) end
   because the latter repeatedly computes the type of the field.

   [<A NAME="getdyntup"><B>getdyntup</B></A> dbres tupno] returns the fields of tuple tupno in result
   set dbres as a vector of dynvals.

   [<A NAME="getdyntups"><B>getdyntups</B></A> dbres] returns all tuples of result set dbres as a
   vector of vectors of dynvals.

   [<A NAME="applyto"><B>applyto</B></A> x f] computes f(x).  This is convenient for applying
   several functions (given in a list or vector) to the same value:
      map (applyto 5) (tabulate(3, getdynfield dbres))
   equals 
      [getdynfield dbres 0 5, getdynfield dbres 1 5, getdynfield dbres 2 5]

   [<A NAME="copytableto"><B>copytableto</B></A>(dbconn, tablename, put)] executes a "COPY TABLE TO"
   statement, applies the function put to every tuple of the table,
   represented as a line of text (not terminated by newline \n), and
   cleans up at the end.  For instance, to copy the contents of a
   table t to a text stream s (one tuple on each line), define
      fun put line = 
          (TextIO.output(s, line); TextIO.output(s, "\n"))
   and execute
      copytableto(dbconn, "t", put).

   [<A NAME="copytablefrom"><B>copytablefrom</B></A>(dbconn, tablename, useput)] executes a "COPY TABLE
   FROM" statement, creates a put function for copying lines to the
   table, passes the put function to useput, and cleans up at the end.
   The put function may be called multiple times for each line
   (tuple); the end of each line is indicated with the newline
   character "\n" as usual.  For instance, to copy the contents of a
   text stream s to a table t, define
      fun useput put = 
          while not (TextIO.endOfStream s) do put(TextIO.inputLine s);
   and execute
      copytablefrom(dbconn, "t", useput).
   Note that TextIO.inputLine preserves the newline at the end of each 
   line.  
*)

</PRE><HR><TABLE WIDTH=100%><TR ALIGN = CENTER>
<TH><A HREF="idIndex.html">Identifier index</A>
<TH><A HREF="index.html">Structure index</A>
</TABLE><HR>
<BR><EM>Moscow ML 1.44</EM></BODY></HTML>
